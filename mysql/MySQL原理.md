# MySQL原理

## 一、MySQL简介

#### MySQL服务器程序

+ mysqld：这可执行文件代表MySQL服务程序，运行这可执行程序可以直接启动一个服务器进程。但是这命令不常用就。

+ mysqld_safe：是一个启动脚本，会间调用mysqld，还会顺带启动一个监控程序，可以在服务器挂了之后将其重启。

+ mysql.server：一个启动脚本，会间接调用mysqld_safe，调用mysql.server可以在后边指定start参数即可启动。
+ mysqld_mulit：一台计算机中可以运行多台服务器实例，即运行多个MySQL服务进程。mysqld_mulit可以对每一个服务器进程的启动或停止进行监控。

#### 启动MySQL客户端程序

> 使用客户端连接到MySQL服务器

```bash
mysql -h主机名 -P端口号 -u用户名 -p密码
```

> 从MySQL服务器断开连接

```bash
quit
exit
\q
```

#### 客户端连接到服务器的方式

客户端和服务器本质上两个不同的应用进程，因此客户端和服务器通信，本质上是进程间的通信。

+ TCP/IP：数据库服务器与客户端进程可能处于不同的主机中，这是可以通过TCP协议进行通信。
+ 命名管道和共享内存：在Windows中，客户端进程和服务器进程之间可以使用命名管道或共享内存方式进行通信，此时需要添加一些参数进行来连接。
  + 以命名管道进行进程间通信：--pipe
  + 以共享内存进行进程间通信：--protocol=memory（这种方式要求服务器与客户端程序位于同一台主机）
+ UNIX域套接字：在类Unix中可以使用Unix域套接字来进行进程间通信

#### 服务器处理客户端请求

无论客户端一何种方式连接到服务器，最终都是：客户端进程向服务器进程发送一点数据，服务器进程接收到数据向客户端返回响应。服务器程序处理客户端的请求主要分为三大部分：**连接管理、解析与优化、存储引擎**

![mysql_total_struct](https://gitee.com/tobing/imagebed/raw/master/mysql_total_struct.png)

+ 连接管理：服务器会使用线程池来复用与客户端交互的线程

+ 解析与优化：解析有优化比较复杂，又细分为以下三部分。

  + 查询缓存：服务器会把刚刚查询的请求和结果缓存起来，下次有一模一样的请求过来就可以直接返回缓存的信息。查询缓存信息是保存在服务器中，可以被不同客户端共享。

    需要注意的是，如果两次不同请求间存在以下请求就不会使用缓存：

    + 两次查询请求在任何字符上的不同（如：空格、注释、大小写）
    + 查询请求中使用了系统函数、用户自定义变量和函数、一些系统表，如mysql、information_schema、performance_schema数据库中的表等

    除此之外，缓存还存在失效时间，如：

    + 对表执行了INSERT、UPDATE、DELETE、TRUNCATE TABLE、ALTER TABLE、DROP TABLE或DROP DATABASE语句或**导致所有缓存无效**

  + 语法解析：查询缓存没用命中，就会正式进入查询阶段。客户端程序发送过来的请求会经过MySQL服务器进行解析，**判断请求语法是否正确，将查询的表和查询条件进行提取**，将其储存到相应的数据结构中。

  + 查询优化：语法解析之后服务器得到需要的信息（查询那些表的那些列，搜索条件等）。为了提高查询的效率，MySQL往往会对语句进行优化，如将外连接转化为内连接、表达式简化、子查询转化为连接等。

    至于具体是怎么给我们优化的，可通过Explain语句来察看语句的执行计划。

+ 存储引擎：在完成查询优化之后，MySQL需要去提前真正的数据。MySQL把数据存储和提取操作封装到存储引擎模块。存储引擎负责把数据库中的记录等映射到物理存储器中，不同的存储引擎有不同策略。主流的存储引擎有：

  + InnoDB：具有外键、支持事务
  + MyISAM：主要的非事务存储引擎
  + Memory：将表置于内存中

  人们把连接管理、查询缓存、语法解析、查询优化等不涉及真正数据存储划分到MySQL Server层；把真是存储数据的功能划分到存储引擎。各种不同的存储引擎提供通过的调用接口为MySQL Server层服务。

## 第二章、字符集与比较规则

#### 简介

计算机只能存储二进制数据，二进制与字符之间的映射通过字符集来指定。常见的字符集有：

| 字符集    | 长度    | 简介                                                         |
| --------- | ------- | ------------------------------------------------------------ |
| ASCII     | 1字节   | 128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。 |
| ISO8859-1 | 1字节   | 256个字符，别名latin1，ASCII基础上扩充128个西欧字符          |
| GB2312    | 1/2字节 | 收录汉字、拉丁字母、希腊字母、日文平假名等。兼容ASCII（ASCII采用1字节编码，否则2字节） |
| GBK       | 2字节   | 在收录字符范围上对`GB2312`字符集作了扩充，编码方式上兼容GB2312 |
| UTF8      | 1~4字节 | 收录地球上能想到的所有字符，不短在扩充，兼容ASCII            |

#### MySQL中支持的字符集和排序规则

**MySQL中的utf8和utf8mb4**

虽然utf8是占用1~4字节，但大部分常见字符只需要使用1~3字节即可表示。MySQL考虑到这一点，对utf8定义了两个该概念：

+ utf8mb3：阉割版utf8，只使用1~3字节表示字符（MySQL中指的utf8）
+ utf8mb4：正统版utf8，使用1~4字节表示字符

**MySQL中查看字符集与比较规则**

```mysql
# 查看当前MySQL中支持的字符集
SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];

# 查看MySQL中支持的比较规则
SHOW COLLATION [LIKE 匹配的模式];
```

**MySQL中各级别的字符集和比较规则**

```mysql
# 服务器级别的字符集
SHOW VARIABLES LIKE 'character_set_server';
# 服务器级别的比较规则
SHOW VARIABLES LIKE 'collation_server';

# 指定数据库级别比较规则、字符集
CREATE DATABASE 数据库名
    [[DEFAULT] CHARACTER SET 字符集名称]
    [[DEFAULT] COLLATE 比较规则名称];
ALTER DATABASE 数据库名
    [[DEFAULT] CHARACTER SET 字符集名称]
    [[DEFAULT] COLLATE 比较规则名称];
# 当前数据库的字符集
SHOW VARIABLES LIKE 'character_set_database'
# 当前数据库的比较规则
SHOW VARIABLES LIKE 'collation_database'

# 指定表的字符集和比较规则
CREATE TABLE 表名 (列的信息)
    [[DEFAULT] CHARACTER SET 字符集名称]
    [COLLATE 比较规则名称]]
ALTER TABLE 表名
    [[DEFAULT] CHARACTER SET 字符集名称]
    [COLLATE 比较规则名称]

# 指定列的字符集和比较规则
CREATE TABLE 表名(
    列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称],
    其他列...
);
ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称];
```

> 需要注意，修改字符集，对应的比较规则会变为该字符集默认的比较规则；对于修改比较规则也是如此。

## 第三章、InnoDB记录结构

#### InnoDB页简介

MySQL中存储引擎负责对表数据的读取和写入，InnoDB是MySQL默认的存储引擎。

InnoDB是一个将表数据存储到磁盘的存储引擎，即使关机重启也可以保证数据存在。

InnoDB中数据修改过程发生在内存，因此修改时需要将磁盘中的数据加载到内存中，同时修改之后的数据需要写回会到磁盘中。

由于磁盘读写速度很慢，与内存的相差了几个数量级，因此在读取数据时，InnoDB不是采用一条一条的方式将其加载到内存中，而是以页为单位将其加载到内存中。（InnoDB中页的大小一般为16KB，即每次内存与磁盘交互至少是16KB）

#### InnoDB行记录

一般情况是以记录（行）为单位插入数据，这些记录存放在磁盘中的方式称为行方式。InnoDB主要存在4种不同的行格式，分别是Compact、Redundant、Dynamic和Compressed。

**Compact行格式**

![mysql_row_compact](https://gitee.com/tobing/imagebed/raw/master/mysql_row_compact.png)

一条Compact格式的记录主要可以分为两部分：

+ 额外信息部分：这部分主要是为了描述这条记录不得不添加的额外信息。

  + 变长字段列表：确定VARCHAR、VARBINARY、TEXT、BLOB这类变长字段占用的真实长度。

  + NULL值列表：把存储了NULL值的列进行统一管理，如果所有列都是非NULL，将没有此部分。

  + 记录头列表：一些标志信息。

    | 名称         | 大小（bit） | 描述                                                         |
    | ------------ | ----------- | ------------------------------------------------------------ |
    | delete_mask  | 1           | 记录删除标记，                                               |
    | min_rec_mask | 1           | B+树最小节点标志                                             |
    | n_owned      | 4           | 当前记录拥有的记录数                                         |
    | heap_no      | 13          | 记录在记录堆中的位置信息                                     |
    | record_type  | 3           | 记录类型（0-普通；1-B+树非叶子节点；2-最小记录；3-最大记录） |
    | next_record  | 16          | 下一条记录的相对位置                                         |

+ 真实数据部分：除了自定义的列数据，MySQL还会为每个记录添加一些隐藏列。

  | 列名           | 是否必须 | 占用大小 | 描述                   |
  | -------------- | -------- | -------- | ---------------------- |
  | row_id         | 否       | 6字节    | 行ID，唯一标识一行记录 |
  | transaction_id | 是       | 6字节    | 事务ID                 |
  | roll_pointer   | 是       | 6字节    | 回滚指针               |

  > row_id在用户无定义主键、unique键的情况下才会启用

需要注意的是，对于CHAR(M)格式的列，在Compact行格式有可能会把它放到变长字段列表中。

当表中采用的是定长字符集（如ASCII、ISO 8859-1等）时，列不会被放到变长字段列表中；

当表中采用的是变长字符集（如UTF8等）时，列会被放到变长字段列表中。

**行溢出数据**

[对于VARCHAR(M)类型列，最多可以占用65535个字节(64KB)。](https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html#row-size-limits)其中在4.0时，VARCHAR(M)代表M个字节；在5.0时，VARCHAR(M)代表M个字符。因此在5.0时，需要根据使用的字符集来判断M的范围。

**记录中的数据太多溢出**

假如我们定义了一个VARCHAR(65532)长度的列，并且往其中存入了65532位ASCII字符（即65532字节，约等于64KB）。在MySQL中，内存和磁盘的基本交换单位页，页的大小一般为16KB，这时候，这个储存了65532字节数据的列就可能需要被存放到不同的页中。

在Compact和Redundant行格式中，对于占用非常大的列，会在记录的真实数据出储存该列的一部分数据，剩余部分分散的几个其他的页中，这个过程称为行溢出，如下图所示：

![mysql_outer](https://gitee.com/tobing/imagebed/raw/master/mysql_outer.png)

> 类似的，在TEXT或BLOB类型的列中也会存在类似的情况。

**行溢出的临界点**

MySQL规定一个页至少存放两行记录，可以依次为限制基础分析出行溢出的临界点。

## 第四章、InnoDB页结构

#### 简介

InnoDB中页时储存空间管理的基本单位，大小一般为16KB。为了便于管理，InnoDB设计了各种各样的页，其中包含了存放表空间头部信息的页、存放Insert Buffer信息的页、存放INODE信息的页、存放undo日志信息的页。其中最为常见的就是我们存入数据的页。（MySQL将存放数据的页称为Index页）。

#### InnoDB数据页结构

通常一个页会被划分为7部分，包含了

+ **文件头部：页的通用信息【通用部分】**
  + 除了数据页还有其他各种各样的页，这部分是用来保存各种页通用的信息
  + 如页号、页校验和、上一页页号（PREV）、下一页页号（NEXT）、页类型、页所属表空间等
  + 不同的页之间通过PREV和NEXT连成双向链表连接起来
+ **页面头部：数据页的专用信息**
  + 保存数据页中的行的状态信息，如行的数量、第一行的地址、页目录的槽的数量等等
+ **最大最小记录：两个虚拟的行记录**
  + InnoDB规定的伪记录，不存储真实数据，用于比较大小
+ **用户记录：实际储存的行记录内容（前面提到过的行记录会被记录到此处）**
+ **空闲空间：页中未使用的空间**
+ **页面目录：页中某些记录的相对位置**
  + 页中的行数据会按主键从小到大形成单链表，为了加快查询效率，这些行数据会被页面目录进行分组管理，加快检索效率
  + 页目录的主要保存了各组的最大记录的地址偏移
+ **文件尾部：校验页是否完整【通用部分】**
  + InnoDB是以页为单位将数据从磁盘加载到内存中进行操作， 文件尾部可以用来校验页的完整性

> 页与页之间通过双链表链接

![mysql_page_dobule_listnode](https://gitee.com/tobing/imagebed/raw/master/mysql_page_dobule_listnode.png)

> 页内数据行按照主键值从小到大的顺序组成一个单向链表，并通过页面目录分组管理加快检索速度

![msyql_record _single_listnode](https://gitee.com/tobing/imagebed/raw/master/msyql_record%20_single_listnode.png)

这种情况下，如果需要查找一行数据，需要先定位数据所在页，在定位数据行在页的位置。

在数据页中，通过主键查找数据行分为两步：

1. 通过二分法确定记录所在槽，找到槽分组最小记录；
2. 通过最小记录，依次遍历槽分组的各个记录。

需要注意的是，即使是通过主键的方式进行查找，在页定位的时候也需要在双链表上进行遍历。在这种方式下，数据量很大时，遍历页的速度也是很慢的。为此，人们想到使用目录项的方式来记录页的主键大小情况，即采用一个数组，维护数据页内主键情况，这种思想和数据页内通过页面目录来管理目录行的思想是类似的。这样在目录项的辅助下，对于页的查找也可以利用二分法来加快查询速度了。

但这并没有完全解决问题，随着数据量的进一步增大，目录项越来越长，这样就会存在两方面问题：一是目录项的查找是通过遍历来实现的，目录项很长查找效率会变低；二是目录项是一个数组，需要连续的内存空间，在内存中申请一片长的连续内存是困难的。

为了解决上述的问题，InnoDB提出通过创建一种特殊的页来保存这些目录项需要保存的信息，这样在数据量巨大是，可以同页分裂的方式来保存这些索引数据（这些特殊页之间仍然通过双链表来连接）。

随着数据的进一步发展，目录项记录的页越来越多，查找起来效率也开始变低，于是又有了更上以及的目录项页（管理目录项页的目录项页），于是就发展形成了以下的结构。

![mysql_index_generate](https://gitee.com/tobing/imagebed/raw/master/mysql_index_generate.png)

由于这种结构很想倒着的树木，结合这种结构具有具有平衡的特性（Balance），于是人们将这种数据结构称为B+树，而这种索引就是常说的B+索引。

在B+树索引中，存放数据的页和存放目录项的页都是作为一个**节点**。其中存放目录项的节点称为**非叶子节点**或**内节点**，包含了最上面的**根节点**。而实际的用户数据都被存放到B+树的**叶子节点**。

在这种结构下，假设每个目录项的页上储存1000条记录，真实数据页可以储存100条记录。

+ 如果B+树只有一层，最多能存放100条记录；
+ 如果B+树有2层，可以储存100x1000条记录；
+ 如果B+树有3层，可以储存100x1000x1000记录；
+ 如果B+树有4层，可以储存100x1000x1000x1000记录。

因此在一般情况下，B+树索引不会超过4层，这是主键查找最多需要经过4个页内查找，而页内又有页目录进行加速，因此定位记录的速度是很快的。

#### 索引

**聚簇索引**

B+树本是一个索引，具有两大特点：索引中的记录按照主键有序存放（页内记录按主键大小排成单链表、页间按照主键大小排成双向链表）；B+树中的叶子节点就是对应表中的完整真实数据。

具有上述特性的B+树称为**聚簇索引**。聚簇索引无需手动创建，InnoDB会为我们自动创建。

**二级索引**

由于聚簇索引的存在，按照主键查询的效率可以很高。但是，如果聚簇索引并不能加速按其他列作为查询条件的语句。此时为了提高查询效率，可以通过创建索引（根据某个/某些列创建一颗B+数，这颗B+树按照这些列的大小进行排序）来加速数据的查询。通常称这些索引为二级索引/辅助索引。

但是需要注意，这些手动创建的索引与聚簇索引有所不同，主要有以下不同：

| 不同       | 二级索引              | 聚餐索引     |
| ---------- | --------------------- | ------------ |
| 比较规则   | 按照指定的列排序      | 按照主键排序 |
| 叶子节点   | 叶子节点储存“列+主键” | 数据完整记录 |
| 目录项记录 | 列+页号               | 主键+列号    |

在二级索引下查找某项数据的流程如下：

1. 确定目录项页。从根页面开始，快速定位目录项记录页。
2. 通过目录项页找到记录页。定位到目录项记录页，可以进一步知道记录页，获取其中记录的主键信息。
3. 通过主键信息到聚餐索引中查找完整的数据。【这一步也称为「回表」，是可选】

> 需要注意的是，第三步回表操作是可选的，如果二级索引的叶子节点保存的数据已经满足用户需求，则无需再回表。

**联合索引**

除了可以给一个列创建索引，也可以为多个列创建索引，这时排序会依次按照列的顺序进行排序。这种情况下，创建处理的索引具有以下特点：

+ 每个目录项由「列A，列B，...，页号」组成，每条记录先按照列A排序，列A相同会按照列B排序，以此类推。
+ B+数叶子节点的记录数据由「列A，列B，...，主键」组成。

#### InnoDB中B+树索引注意

InnoDB中的B+树遵循以下几个基本规则：

+ **根页面不变性**：一个B+树的根节点子诞生之日开始，就不会移动。只要对某个表创建一个索引，那么它的根节点的页号就会被记录到某个地方，之后凡是InnoD引擎求需要用到这个索引，就到固定位置取出根节点的页号（可以理解为一个地址），从而访问这个索引。

+ **页内节点目录项唯一性**：由于「索引列+页号」并不能与记录一一对应，因此同一「索引列+页号」可能会指向多个页。这时就会产生歧义，一条新的「索引列+页号」来到，应该去哪个页呢？为此除了「索引列+页号」还需要添加主键联合作为唯一标识「索引列+主键值+页号」。

  因此可以说，页面节点目录项唯一性可以避免新添加数据的歧义性。

+ **一页至少储存2条记录**：B+树建立目录的目的就是为了在一级目录中索引到多个下级目录，实现快速定位数据的目的，如果一个目录只存放一条数据，则失去了创建这些目录的意义。因此，InnoDB规定一个数据页至少存放两条记录。

> B+树形成的过程：
>
> 1. 为某个表添加一个B+索引，会为这个索引创建一个根节点页面；
> 2. 随后先表中插入数据是，先把记录储存到这个根节点；
> 3. 当根节点可用空间使用完毕，将根节点所有记录复制到新的页，对这个新页进行页分裂操作，得到另一个新页。这时再将新的记录插入到指定页中。此时根节点页升级为储存目录项记录的页。

#### MyISAM索引方案简介

除了InnoDB存储引擎，MyISAM也是较为和常见的储存引擎。同InnoDB一样，MyISAM也是采用树结构来保存索引，但它将索引和数据分开存储。

+ 数据按照插入顺序，储存到一个文件中，这个文件不会按照页划分，有多少加多少，这种情况下可以通过行号快速访问；
+ 由于插入的数据没有按照主键等进行排序，不能直接在这个数据表上使用二分法快速定位；
+ MyISAM会额外为表的主键创建一个索引，这个索引的叶子节点储存的是记录的「主键+行号」，以此可以快速定位数据；
+ 从上面可以知道，MyISAM总是需要进行一次回表，也即是说MyISAM的索引都是二级索引；
+ 需要注意的是，尽管MyISAM每次需要回表，但是MyISAM回表的代价远远小于InnoDB，这是因为MyISAM会表时可以根据行号随机访问数据表中的数据，而InnoDB仍然要求聚餐索引树上查一遍。

#### MySQL中索引的使用

上面我们介绍了索引能够帮助我们快速查找数据，接下来将介绍如何为某一列/某些列创建索引

```sql
-- 创建表的时候指定需要建立索引
CREATE TALBE 表名 (
    各种列的信息 ··· , 
    [KEY|INDEX] 索引名 (需要被索引的单个列或多个列)
)

-- 修改表结构的时候添加索引
ALTER TABLE 表名 ADD [INDEX|KEY] 索引名 (需要被索引的单个列或多个列);

-- 修改表结构的时候删除索引
ALTER TABLE 表名 DROP [INDEX|KEY] 索引名;
```

> 需要注意，`KEY`和`INDEX`是同义词，任意选用一个就可以。

## 第五章、B+树索引的使用

#### B+树索引回顾与总结

+ InnoDB引擎使用B+树索引作为数据的储存结构结构；
+ 每个索引对应一颗B+树，一颗B+树分为多层，最底层是叶子节点，其余是内节点；
+ 所有的数据记录都保存在叶子节点，而所有的目录项都储存到内节点；
+ InnoDB引擎会自动为主键创建聚簇索引，聚簇索引的叶子包含完整的用户记录；
+ 除了聚簇索引，可以根据需求自定义创建新二级索引，二级所以的节点包含「索引列+主键」；
+ 如果需要通过二级节点获取完整的数据记录，需要进行回表操作，即拿到二级索引中储存的主键，到聚簇索引中再搜索一遍；
+ B+树中每层节点按索引列值从小到大排序形成双向链表，每个页内记录按照索引列大小顺序形成单链表；
+ 对于联合索引，页面先根据联合索引的前面列排好序，如果前面列相同，再按照后面列排序；
+ 通过索引查找记录从B+树根节点开始，一层一层往下寻找。由于每个页内按照索引值建立了页目录，在页查找同样非常高效。

#### 索引的代价

索引能够加快数据的查找效率，但我们不能随便来创建索引，因为索引的使用也是有代价的。主要体现在两方面：

+ 空间代价：每创建一个索引，实际上是为它创建一颗B+树，每颗树的一个节点都是一个页，一个页默认16KB。
+ 时间代价：在增删改操作时，需要维护B+树索引。增删改操作有可能会导致B+树索引的修改，如果B+树索引越多，维护的也就越多，性能也会随之下降。

因此在创建索引的时候需要进行综合考量。

#### B+树索引的适用条件

为了更好说明，下面是基于索引idx_name_birthday_phone_number（这个名字可以见名知义，不再解释）描述。

##### **全值匹配**

搜索条件中的列和索引列一致的话，这种情况就称为全值匹配。

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';
```

> 需要注意，上述语句中如果将name、birthday、phone_number等位置进行调换，也是没有影响了，MySQL的查询优化器会对其进行优化。

##### **匹配左边的列**

搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行。

```sql
-- 下面两条语句都是使用了最左边的列为查询条件，因此可以用上索引
SELECT * FROM person_info WHERE name = 'Ashburn';
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';

-- 下面这条语句的查询条件没有符合匹配左边法则，因此办法通过索引加速查询
SELECT * FROM person_info WHERE birthday = '1990-09-27';
```

> 至于为什么是这样，原因也比较简单，索引在创建的时候，会目录项页时先根据联合索引的定义的顺序来依次排序，如本例中先按照name排序，name相同的再按照birthday排序，最后birthday相同的再按照phone_number排序；这就相同的birthday（或者说后面的列）可能会分布在不同的name中，因为需要基于name排序。因此值给定了birthday条件，仍然需要去查询所有的来确保birthday没有被遗漏。

##### 匹配列前缀

在单词的模糊搜索中，如果查询条件是符合最左前缀的(XXX%)，可以利用上部分的索引。

```sql
-- 下面两条语句都是使用了列的左边部分作为查询条件，因此可以用上索引
SELECT * FROM person_info WHERE name LIKE 'Ashb%';
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = "15123983%";

-- 下面则违反了列左前缀法则
SELECT * FROM person_info WHERE name LIKE '%sh';
SELECT * FROM person_info WHERE name LIKE '%sh%';
```

> 同样地，这理解起来也很方便，字符串的排序方式与联合索引的目录项顺序的摆放是一样的，不同的是字符串是先根据左边的字符而不是列来依次排序，具体就不再赘述。

<font style="color:red">**这里需要注意的是，如果有时候需要匹配后缀的需求，可以考虑将字符串进行反转储存。**</font>

如这样一个业务：储存了很多url，www.baidu.com、www.sina.com、www.google.com等，需要查询以com为后缀的网站。

这是可以将数据进行逆向储存，moc.udiab.www 、 moc.elgoog.www、 moc.elgoog.www等，这样就可以这么查询：`WHERE url LIKE 'moc%'`。

##### **匹配范围值**

基于索引树的排序特性，索引也能加快我们范围查询的效率。

```java
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

> 对于上述语句，需要查询("Asa", "Barlow")范围的数据，对于name有序的情况，我们只需要知道符合范围的最小值和最大值即可，找到最大值和最小值，只需要沿着链表依次从最小值遍历到最大值即可。

```sql
SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01';
```

> 对于上述语句，查询会分为两部分：
>
> 1. 通过条件`name > 'Asa' AND name < 'Barlow' `来对`name`进行范围，查找的结果可能有多条`name`值不同的记录
> 2. 对这些`name`值不同的记录继续通过`birthday > '1980-01-01'`条件继续过滤

##### **精确匹配某一列并范围匹配另外一行**

对于联合索引，对其中多个列查询时，左边的精确查询，其右边的列可以利用上范围查询。

```sql
SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';
```

> 上面的语句页比较容易理解，我认为可以归为左前缀一类。由于是先按照左边的列排序，相同的再根据右边的列排序，因此在查询左边条件限定，其得到的结果也是有序的，其查询起来和「匹配范围值」是一样的效果。

##### **用于排序**

在使用ORDER BY子句进行排序时，如果排序的字段是索引字段，也可以利用上索引字段。

```sql
SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
```

由于这个索引本质上就是按照这个顺序来排序，因此索引树中的顺序就是查询需要的数据，直接按照索引中id顺序返回数据结果即可。

> 索引对于优化排序的好处：一般情况下，如果没有索引，需要将所有记录加载到内存中，再使用一些高阶排序算法进行排序；有时需要排序的结果集太大，不能直接在内存中排序，还需要通过磁盘缓存中间结果，这样一来效率就变得非常低了。

##### **联合索引的使用注意**

无论是单属性索引，还是联合索引，在使用时候都需要遵循左前缀法则（上述所有情况可以看做不同的左前缀体现），这左前缀法则下，如果顺序与定义的不一样，可能只能用上甚至用不上索引的优化。

**无法使用索引排序的情况**

上面提到，索引对于排序的增益效果是巨大的，但下面几种情况将无法顺利使用/全部利用上索引的对排序增益效果。

**1、ASC和DESC的混用**：在使用联合索引排序的场景，要求各个类排序的顺序一致，要么全是ASC，要么全是DESC。

这主要是考虑到了LIMIT的情况，如：

+ ORDER BY name, birthday LIMIT 10
+ ORDER BY name DESC, birthday DESC LIMIT 10

上述两种情况都是顺序一致的，直接从索引最左/右边开始读10条记录即可。但是对于

+ SELECT * FROM person_info ORDER BY name, birthday DESC LIMIT 10

对于上述语句，对name先升序，在对birthday在降序，使用索引的排序过程为：

1. 从索引最左边确定name列最小值，找到name列等于该值的所有记录，然后从name列等于该值的最最右边那条记录开始往左找10条记录；
2. 如果name等于最小值的不足10条，在继续往右找name值第二小的记录，重复上述过程，知道找到10条记录为止；

由于第二步的过程算法比较复杂，甚至比不上文件排序块，于是规定联合索引的各个排序列的顺序必须是一致的。

**2、排序列包含非同一个索引列**

用于排序的多个列不再同一个索引中，不能使用索引进行排序。

```sql
SELECT * FROM person_info ORDER BY name, country LIMIT 10;
```

**3、排序列使用了复杂的表达式**

使用索引排序时，必须要保证列不被修饰过，如添加使用函数进行修饰。

```sql
SELECT * FROM person_info ORDER BY name, country LIMIT 10;
```

##### 用于分组

如果索引列与需要分组的列的顺序一致，可以利用索引来加速分组。

```sql
SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number
```

> 上述分组的过程是，先从结果中找出name值相同的会分为一组；组内按birthday划分为一组；进一步birthday组内按照phone_number划分为一组。你会发现这和前面创建索引的组织方式基本一致，因此可以直接按照索引的进行取值即可，省去了再去分组的开销。

#### 回表的代价

前面提到，在InnoDB中使用二级索引查询数据时，需要先到二级索引出寻找到符合条件的节点信息，如果节点信息已经满足查询的需求，可以直接返回。但如果查询的结果不满足（如缺失某些字段）就需要再通过节点信息中的主键，回到聚簇索引中再去查找。

<font style="color:red">**因此我们说使用二级索引的时候，是可能存在会回表成本的。**</font>

回表成本在单条数据中，效率的问题并不是存在很大问题，性能瓶颈主要体现在范围查询之类。

```sql
ELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';
```

在上面的语句中使用到了前面提到的联合索引，执行过程大致分为两个步骤：

1. 根据查询条件，到二级索引中查询出符合的多个id；【顺序IO】
2. 根据查询出的多个id，依次回到主表中进行获取；【随机I/O】

可以发现在访问聚簇索引的时候，如果id的数量特别多，将会存在大量的随机I/O。如果这些id的数量占了全部记录数量的90%，那么这些频繁的随机I/O将会大大降低系统性能，很有可能比全表扫描（依次遍历，顺序I/O）带来的性能损坏更高。

<font style="color:red">**因此在范围查询时，如果存在大量的回表操作，其性能可能比不上直接全表扫描。**</font>【当然这些过程查询优化器会进行相应的判断，总体是当回表次数少的时候，会倾向于使用二级索引+回表的选择】

##### 索引覆盖

为了彻底解决回表代理的性能损坏，建议在查询的是只查询需要的列的数据，这就可能存在我们查询的列以及在二级索引树上，不再需要回表操作了。这也被称为「索引覆盖」。

#### 索引的选择

索引的选择是由技巧的，创建时应该遵循以下准则。

##### 只为用于搜索、排序或分组的列创建索引

只为出现在`WHERE`子句中的列、连接子句中的连接列，或者出现在`ORDER BY`或`GROUP BY`子句中的列创建索引。

##### 考虑列的基数

`列的基数`指的是某一列中不重复数据的个数，只为基数大的列创建索引（如QQ、身份证号码等，区分度很高，效果显著），不为基数小的创建索引（如性别只有男和女，区分度不高，效果不好）。

##### 索引列的类型尽可能小

类型越小，在查询时进行的操作比价快。（在CPU层面，如缓存、运行指令等）

类型越小，所以占用的空间小，一页能放下更多的东西，一个数据页上可以放下更多的记录，可以减少磁盘I/O带来的性能损耗。

##### 索引字符串值的前缀

如果将一个字符列的值全部放到索引中，可能存在两个问题：

+ B+树索引需要把列完整的字符串储存起来，占用空间大；
+ B+树所索引储存的字符串很长时，需要比较的时间也很长；

为此索引允许只对部分字符串（字符串前面几个）创建二级索引，这样虽然不能进行很精确的定位，但是也能够一定程度提高查询速度。这种方式叫「索引列前缀」

> 下面展示了为指定列的某几个字符创建索引

```sql
CREATE TABLE person_info(
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
);    
```

##### 索引列前缀对排序的影响

在索引列前缀时，如果使用类似于LIMIT进行限制，将无法使用时上该索引。

##### 让索引在比较表达式中单独出现

顾名思义，编写SQL时，让索引列在比较表达式的一边单独出现，如下：

+ `WHERE my_col * 2 < 4`，不能使用上索引
+ `WHERE my_col < 4/2`，可以使用上索引

除此之外，给列加上表达式、函数的形式作为where条件，是无法使用上索引的。

##### 主键插入顺序

最好以顺序的方式来往聚餐索引中添加数据，这样当我们每次插入一条新的数据的时候都会往后面的页中插入，插完一页在创建新的页插入。

但是如果是不按照顺序插入，即插入到一页中间，可能会页的分类，其他记录对应的页可能发生改变，最终导致无谓的性能损耗。

为此储存为创建一列id并让他拥有`AUTO_INCREMENT`属性，使其可以在插入记录时由引擎自动填入自增主键。

##### 冗余和重复索引

需要比较为一个列创建重复的索引。

## 第六章、MySQL的数据

#### 数据目录

MySQL启动时，会到指定目录加载文件，在启动之后产生的文件也会保存到指定目录。这么目录称为数据目录。

当时新建一个数据库，MySQL会执行以下两个操作：

1. 在数据目录下创建一个与之同名的子目录；
2. 在创建的子目录中创建一个db.opt文件，文件中包含了数据库的各种属性，如字符集，比较规则等。

除此之外，我们定义的表以及表中的数据都是以文件的形式储存在文件系统中。每个表的信息可以分为两种：

1. **表结构定义**。表的名称、列类型、约束、索引、字符集、比较规则等。通常文件名为「表名.frm」

2. **表中数据**。不同存储引擎保存文件的方式不同。

   + **InnoDB**

     **页**：InnoDB以页为基本单位管理存储空间，默认每页为16KB；InnoDB中每个索引对应一颗B+树，树中每个节点都是一个数据页；数据页之间不必物理连续，通过双向链表来维护页的顺序性；InnoDB聚簇索引的叶子节点储存了完整的用户数据，数据即索引。

     **表空间**：为了更好管理这些页，InnoDB提出表空间/文件空间(table sapce/file space)的抽象概念。它可以对应文件系统的一个或多个文件。每个表空间可以划分为读个页。

     **表空间类型**：表空间的类型有：独立表空间、系统表空间和其他类型（undo表空间、临时表空间、通用表空间）。

     MySQL5.5.7到MySQL5.6.6数据默认保存到系统表空间；

     MySQL5.6.6以及之后的版本，各个表的数据存储在独立版空间；

   + **MyISAM**

     MyISAM的数据和索引分开存放，索引全部是二级索引。因此其使用不同的文件来保存数据文件和索引文件。同时MyISAM没有表空间这么一说，所有的数据文件都保存在数据库子目录下。

     如果创建了一个MyISAM的表，数据库会为其创建三个文件：表名.frm、表名.MYD（数据文件）、表名.MYI（索引文件）

出来用户自定义的储存数据，数据目录下还存在以下额外的文件用于辅助程序的运行：

+ 服务器进程文件：每个MySQL服务器程序，对应一个进程，对应一个进程描述文件。
+ 服务器日志文件：服务器运行过程中产生的各种日志，如查询日志、错误日志、二进制日志、redo日志等。
+ 默认自定生成的SSL和RSA证书和密钥文件：为客户端和服务器建立安全通道而创建的文件。

#### 视图在文件系统中的表示

MySQL中视图是虚拟表，只是某个查询语句的别名，因此视图不需要真实储存数据，只需要将其结构表示出来即可。和表一样，描述视图结构的文件会被储存到所属数据库对应的子目录下，为「视图名.frm」文件。

#### MySQL的系统数据库

MySQL的系统数据库中保存了数据库运行过程中需要的状态信息。

| 数据库名称         | 简介                                                         |
| ------------------ | ------------------------------------------------------------ |
| mysql              | 核心，储存用户账号和权限信息；存储过程、事件的定义信息；运行过程日志信息；帮助信息和时区信息。 |
| information_schema | MySQL服务器维护的所有其他数据库的信息，如有哪些表、视图、触发器、列、索引等。这些数据不是真实用户数据，而是描述性数据（元数据） |
| performance_schema | MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。 |
| sys                | 通过视图的形式把`information_schema`和`performance_schema`结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。 |

#### 独立表空间结构

InnoDB支持多种表空间。

##### 区（Extent）

表空间的页太多，不便于管理，于是引入了区。对于16KB的页，连续64页组成一个区，即一个区默认占用1MB空间。不论系统表空间还是独立表空间都可以看做由若干的区组成，每个256个区划分为一组。

![mysql_extent_tablesapce](https://gitee.com/tobing/imagebed/raw/master/mysql_extent_tablesapce.png)

为表中添加一行数据，需要维护数据库中聚簇索引和所有二级索引。索引树的每层会形成双向链表，如果仅仅以页为分配空间，那么链表相邻两个节点物理地址可能相差很远，这时如果需要范围查询时需要定位左右边界，然后开始扫描即可。但是如果不同页之间物理地址相差很远，会产生很多随机IO。

为了降低随机IO的概率，引入区。即数据量大时不是一次申请一页，而是按区分配（一个区为物理位置上连续的64个页）。这样可以大大降低随机IO概率。

##### 段（segment）

InnoDB对B+树的叶子节点和非叶子节点进行区别对待，叶子节点对应有独立的区，非叶子节点有对应独立的区。而存放叶子节点的区的结合划分为一个段，存放非叶子接单的区划分为一个段。即一个索引会生成2个段，叶子段和非叶子段。

> 表空间、段、区的关系
>
> 一个表空间对应多个段（叶子段和非叶子段），一个堆对应多个区，一个区是连续64页，页时数据存储管理的基本单位。

![msyql_total_struct_table_tent_seg](https://gitee.com/tobing/imagebed/raw/master/msyql_total_struct_table_tent_seg.png)

## 第七章、单表访问方法

#### 访问方法概念

MySQL查询的执行方式被称为「访问方法」或「访问类型」主要有两大类：

+ 全表扫描：遍历每一行数据，把符合的记录加入结果集。
+ 索引查询：利用上各种索引查询到主键，根据需求确定是否回表。

具体的访问方法又可以细分为一下几种：

##### CONST

<font style="color:red">通过主键或者唯一二级索引列与常数的等值比较来定位**一条记录**，如果主键或者唯一二级索引是由多个列构成的话，索引中的每一个列都需要与常数进行等值比较。</font>

> 对于唯一二级索引来说，查询该列为`NULL`值的情况比较特殊，因为唯一二级索引列并不限制 NULL 值的数量，所以上述语句可能访问到多条记录，也就是说 上边这个语句不可以使用`const`访问方法来执行

##### ref

<font style="color:red">普通的二级索引列与常数进行等值比较或唯一二级索引的NULL值比较。</font>

>使用二级索引来执行查询的代价取决于等值匹配到的二级索引记录条数。如果匹配的记录较少，则回表的代价还是比较低的，所以`MySQL`可能选择使用索引而不是全表扫描的方式来执行查询。

##### ref_or_null

<font style="color:red">不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为`NULL`的记录也找出来。</font>

```sql
SELECT * FROM single_table WHERE key1 = 'abc' OR key1 IS NULL;
```

##### range

<font style="color:red">利用索引（聚簇索引或二级索引）进行范围匹配的访问方法。</font>

##### index

<font style="color:red">遍历二级索引记录的执行方式。</font>

>详细而言就是我们查询的字段（包含查询条件）在某个二级索引中包含，这样可以直接去二级索引中检索数据，而不用到聚餐索引检索数据。
>
>由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直接遍历聚簇索引的成本要小很多。

##### all

<font style="color:red">直接扫描聚簇索引（全表扫描）。</font>

#### 注意事项

##### range使用的访问区间

对于`B+`树索引来说，只要索引列和常数使用`=`、`<=>`、`IN`、`NOT IN`、`IS NULL`、`IS NOT NULL`、`>`、`<`、`>=`、`<=`、`BETWEEN`、`!=`（不等于也可以写成`<>`）或者`LIKE`操作符连接起来，就可以产生一个所谓的`区间`。

> 小贴士： LIKE操作符比较特殊，只有在匹配完整字符串或者匹配字符串前缀时才可以利用索引。
>
> IN操作符的效果和若干个等值匹配操作符`=`之间用`OR`连接起来是一样的，也就是说会产生多个单点区间。

#### 索引合并

MySQL在一般情况下执行一个查询最大只会用到单个二级索引，但也有特殊情况，MySQL把这种情况称为索引合并（index merge）。具体索引合并有三种算法。

##### Intersection 合并

**某个查询可以使用多个二级索引，从多个二级索引中查询的结果取交集。**

```sql
SELECT * FROM single_table WHERE key1 = 'a' AND key3 = 'b';
```

>从`idx_key1`二级索引对应的`B+`树中取出`key1 = 'a'`的相关记录。
>
>从`idx_key3`二级索引对应的`B+`树中取出`key3 = 'b'`的相关记录。
>
>二级索引的记录都是由`索引列 + 主键`构成的，所以我们可以计算出这两个结果集中`id`值的交集。
>
>按照上一步生成的`id`值列表进行回表操作，也就是从聚簇索引中把指定`id`值的完整用户记录取出来，返回给用户。

MySQL在某些特定情况下使用Intersection 合并（主要从IO层面考虑，随机IO与顺序IO）：

+ 二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。
+ 主键列可以是范围匹配。

需要注意的是，从key1和key3索引中取出值的数据都是有序的，有序集合的交集只需要O(N+M)的时间复杂度。

##### **Union合并**

**`Union`是并集的意思，适用于使用不同索引的搜索条件之间使用`OR`连接起来的情况。**

```sql
SELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b'
```

>从`idx_key1`二级索引对应的`B+`树中取出`key1 = 'a'`的相关记录。
>
>从`idx_key3`二级索引对应的`B+`树中取出`key3 = 'b'`的相关记录。
>
>二级索引的记录都是由`索引列 + 主键`构成的，所以我们可以计算出这两个结果集中`id`值的并集。
>
>按照上一步生成的`id`值列表进行回表操作，也就是从聚簇索引中把指定`id`值的完整用户记录取出来，返回给用户。

MySQL在某些特定的情况下才可能会使用到Union索引合并：

+ 二级索引列是等值查询的情况，对于联合索引，联合所以的每个列都必须是等值匹配。
+ 主键列是可以范围匹配。
+ 使用Intersection索引合并的搜索条件。

##### **Sort-Union合并**

**先按照二级索引记录的主键值进行排序，之后按照Union索引合并方式执行的方式称之为Sort-Union索引合并。**

```sql
SELECT * FROM single_table WHERE key1 < 'a' OR key3 > 'z'
```

> 从`idx_key1`二级索引对应的`B+`树中取出`key1 = 'a'`的相关记录，根据主键排序。
>
> 从`idx_key3`二级索引对应的`B+`树中取出`key3 = 'b'`的相关记录，根据主键排序。
>
> 二级索引的记录都是由`索引列 + 主键`构成的，所以我们可以计算出这两个结果集中`id`值的并集。
>
> 按照上一步生成的`id`值列表进行回表操作，也就是从聚簇索引中把指定`id`值的完整用户记录取出来，返回给用户。

Sort-Union索引合并比单纯的Union索引合并多了一步对二级索引记录的主键值排序的过程。

##### 索引合并注意事项

一般情况下，所以索引合并查询，可以通过建立联合索引来进行优化，没必要单独创建两个索引，当然这也是要根据业务环节来判断。

## 第八章、连接的原理

#### 连接简介

连接的本质就是把各个连接表的记录都取出来，依次匹配的组合加入结果集并返回给用户。

连接查询的结果集中包含一个表中的每一条记录与另一个表中的每一条记录相互匹配的组合，像这样的结果集就可以称之为笛卡尔积。

如果愿意，可以连接任意张表，但是如果没有限制条件，这些表连接起来产生的笛卡尔积非常巨大。因此在连接时过滤掉特定的记录组合很有必要，连接查询是过滤条件分为两种：

+ 涉及单表的条件，如`t1.m1>1`
+ 涉及两表的条件，如`t1.m1 > t2.m2`

```sql
SELECT * FROM t1, t2 WHERE t1.m1 > 1 AND t1.m1 = t2.m2 AND t2.n2 < 'd';
```

上面连接查询大概执行过程如下：

1. 确定第一个需要查询的表，称为**驱动表**。

   确定驱动表的时候采用的是[单表访问方式](# 第七章、单表访问方法)，这时根据where的过滤条件（如t1.m1>1）以最小代价（all、index、ref等）取出数据;

2. 针对驱动表产生的结果集中的每条记录，分别到**被驱动表**中查找匹配的记录。

   所谓的匹配的记录就是符合过滤条件的记录。这时候会使用上**涉及两表的过滤条件**。

   - 当`t1.m1 = 2`时，过滤条件`t1.m1 = t2.m2`就相当于`t2.m2 = 2`，所以此时`t2`表相当于有了`t2.m2 = 2`、`t2.n2 < 'd'`这两个过滤条件，然后到`t2`表中执行单表查询。
   - 当`t1.m1 = 3`时，过滤条件`t1.m1 = t2.m2`就相当于`t2.m2 = 3`，所以此时`t2`表相当于有了`t2.m2 = 3`、`t2.n2 < 'd'`这两个过滤条件，然后到`t2`表中执行单表查询。

![mysql_mult_table_exec](https://gitee.com/tobing/imagebed/raw/master/mysql_mult_table_exec.png)

从上面可以看到，<font style="color:red">**驱动表只会被访问一次，被驱动表会被访问多次**</font>。

#### 内连接与外连接

对于**内连接**的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集；

对于**外连接**的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，仍然需要加入结果集中；

MySQL中，根据驱动表的不同，外连接可以细分为2种：

+ 左外连接：选左边为驱动表
+ 右外连接：选右边为驱动表

对于外连接，需要区分驱动表单表的过滤条件（以确定在两表匹配失败时失败要添加到结果集）与两表的过滤条件：

+ WHERE子句过滤条件：不论是内连接还是外连接，凡是不符合`WHERE`子句中的过滤条件的记录都不会被加入最后的结果集。
+ ON子句过滤条件：对于外连接的驱动表的记录来说，如果无法在被驱动表中找到匹配`ON`子句中的过滤条件的记录，那么该记录仍然会被加入到结果集中，对应的被驱动表记录的各个字段使用`NULL`值填充。

> ON子句是专门为外连接驱动表中的记录在被驱动表找不到匹配记录时应不应该把该记录加入结果集这个场景下提出的，所以如果把ON子句放到内连接中，MySQL会把它和WHERE子句一样对待。

一般情况下，把只涉及单表的过滤条件放到WHERE子句中，把涉及两表的过滤条件都放到ON子句中，我们也一般把放到ON子句中的过滤条件也称之为连接条件。

```sql
-- 左外连接
SELECT * FROM t1 LEFT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
-- 右外连接
SELECT * FROM t1 RIGHT [OUTER] JOIN t2 ON 连接条件 [WHERE 普通过滤条件];
```

对于LEFT JOIN类型，把左边的表称之为外表或者驱动表，右边的表称之为内表或者被驱动表。

需要注意的是，对于左（外）连接和右（外）连接来说，必须使用`ON`子句来指出连接条件。

```sql
-- 内连接
SELECT * FROM t1 [INNER | CROSS] JOIN t2 [ON 连接条件] [WHERE 普通过滤条件];
```

#### 连接的原理

##### 嵌套循环连接

对于两表连接，驱动表被访问一次，被驱动表被访问多次，被驱动表访问的次数取决于驱动表中结果集的记录条数。

对于内连接，选取那张作为驱动表并无关系，而外连接的驱动表是固定的。

![mysql_two_table_join](https://gitee.com/tobing/imagebed/raw/master/mysql_two_table_join.png)

对于三个表的连接，步骤2得到的结果集就像是新的驱动表，之后让第三个表作为被驱动表，重复上述的过程即可。

上述的过程就像一个嵌套循环，这种被驱动表只访问一次，但被驱动表可能访问多次，次数取决于驱动表执行单表查询之后的结果集的记录条数的查询方式称为嵌套循环连接查询，是最简单、最笨拙的一种连接查询算法。

##### 使用索引加速连接速度

嵌套查询的第二步骤可能需要访问多次被驱动表，如果被驱动表的访问方式都是全表扫描，将会大大降低查询的效率。

因此对于被驱动表的访问方式，尽量使其优化为使用上索引。

##### 基于块的嵌套循环连接

现实中表的数据往往是海量的，内存中可能放不下表的所有记录，因此在扫描表前面的记录时，后面的记录可能还在磁盘上，等到扫描到后面记录时，可能内存不足，需要把前边的记录从内存中释放掉。

而前面提到的「基于嵌套循环连接」算法的执行过程中，被驱动表开年需要被连续被访问多次，如果这个驱动表数据很多，而且不能使用索引访问，就需要多次读写磁盘，I/O代价非常高。

为了减少大数据量的驱动表被多次加载磁盘，考虑将内存中被驱动表的数据与多条驱动表的数据匹配，可以大大减少重复从磁盘上加载被驱动表的代价。

MySQL通过join buffer来实现上述功能。join buffer 会在连接查询前申请一块固定的内存，先把若干条驱动表结果集中的记录装到join buffer，然后开始扫描被驱动表，每一层被驱动表的记录一次性和join buffer中多条驱动表记录匹配，由于匹配在内存中完成，可以显著减少被驱动表I/O代价。

![mysql_join_buffer](https://gitee.com/tobing/imagebed/raw/master/mysql_join_buffer.png)

最好的情况是join buffer足够大，能容纳驱动结果集的所有数据，这样只需要访问一次被驱动表即可完成连接操作。MySQL把这种加入了join buffer的循环嵌套连接算法称为「基于块的嵌套连接」算法。

> join buffer可以同系统启动参数配置，默认为256KB。另外需要注意的是不是查询列表的所有列和过滤条件的列会被放到join buffer中。这也提醒我们需要避免把*作为查询列表。

#### 执行成本

MySQL的一个查询可以不同的执行方案，为了选择最优的方案，会综合考量最低成本的执行方案。其中这些成本包含了以下的几部分：

+ I/O成本：MySQL主流的存储引擎，如MyISAM、InnoDB都是将数据保存到磁盘中，需要时可能要从磁盘中加载到内存，从磁盘到内存的过程损耗的时间为I/O成本。
+ CPU成本：读取以及检测记录是否满足条件、以及对结果集排序等损耗的时间为CPU成本。

对于InnoDB页是磁盘和内存之间交互的基本单位，MySQL规定读取一页花费成本为1.0；

读取以及检测一条记录是否符合搜索条件的成本默认是0.2；

基于内存创建临时表的成本为2.0；

基于磁盘创建临时表的成本为40.0；

> 注意：这些成本常数可以通过配置文件进行修改。
>
> MySQL在执行DISTINCT查询、分组查询、Union查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，使用这个临时表来辅助完成查询。
>
> 如对DISTINCT查询可以创建一个带UNIQUE索引的临时表，直接把需要去重的记录插进去，其结果就是结果集。
>
> 在数据量较大时，可能会基于磁盘创建临时表，这样的成本就很高了。

#### 基于成本的优化步骤（单表）

一个单表查询真正执行前，MySQL查询优化器会找到该语句可能使用到的方案，并从中选出成本最低的方案，这个成本最低的方案称为执行计划，之后再调用存储引擎提供的接口真正执行查询。主要流程如下：

1. 根据搜索条件，找出所有可能使用索引（possible keys）；
2. 计算全表扫描代价（I/O成本+CPU成本）；
3. 计算使用不同索引执行查询的代价；
4. 对比各种执行方案，找出成本最低的。

> 统计I/O成本和CPU成本时需要用到两个信息：聚簇索引占用的页面数 和 表中的记录数。
>
> 这些信息可以查询数据库中的统计信息表获得。统计信息包含了临时统计信息和永久统计信息。

#### 连接查询的成本

MySQL连接查询使用嵌套循环连接算法，对于两个表的查询，其查询成本由以下两部分组成：

+ 单次查询驱动表成本
+ 多次查询被驱动表的成本

> 对驱动表进行查询后得到的记录条数称之为驱动表的**扇出（fanout）**。

以下两种情况的计算驱动表扇出值的时候需要靠猜：

+ 如果使用的是全表扫描的方式执行的单表查询，计算表扇出时需猜满足搜索条件的记录有多少条；
+ 如果使用的索引执行的单表扫描，计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

> 这个猜的过程（condition filtering）需要使用拿到索引/统计数据。

**两表连接总成本**

```
连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 x 单次访问被驱动表的成本
```

对于左/右外连接查询，驱动表是固定的，想要查询最优方案只需要分别为驱动表和被驱动表选择最低成本的查询方案。

对于内连接，驱动表和被驱动表的位置可以互换，因此需要考虑两方面内容：

+ 不同表作为驱动表时最终查询成本不同，需要考虑最优的表连接顺序
+ 驱动表和被驱动表选择成本最低的访问方案

> 注意：左/右外连接在一些特殊情况下会被优化为内连接。

连接查询中，`驱动表扇出树x单次访问被驱动表的成本`占了主要比例。一次优化主要从：

+ 尽量减少驱动表的扇出
+ 对被驱动表的访问成本尽量低（尽量在被驱动表的连接页上建立索引）

#### 基于规则的查询优化

为了提供查询性能，MySQL可能会将性能较弱的查询通过一定规则的转换，将其转换为性能较好的语句，这个过程称为查询重写。主要包含以下部分内容：

+ 条件化简

  + 移除不必要的括号
  + 常量传递
  + 等值传递
  + 移除没用的条件
  + 表达式计算
  + HAVING和WHERE子句合并
  + 常量表检测

+ 外连接消除：在搜索条件中指定关于被驱动表相关列的值不为`NULL`，那么外连接中在被驱动表中找不到符合`ON`子句条件的驱动表记录也就被排除出最后的结果集了，这时候外连接和内连接没有什么区别。

  外连接查询中，指定的`WHERE`子句中包含被驱动表中的列不为`NULL`值的条件称之为`空值拒绝`（英文名：`reject-NULL`）。在被驱动表的WHERE子句符合空值拒绝的条件后，外连接和内连接可以相互转换。这种转换带来的好处就是查询优化器可以通过评估表的不同连接顺序的成本，选出成本最低的那种连接顺序来执行查询。

+ 子查询优化

  由子查询结果集组成的表称之为`派生表`。

  按照子查询返回的不同结果集类型，可以将子查询分为不同类型：

  + 标量子查询：只返回一个单一值。
  + 行子查询：只返回一行记录的子查询，其中可能包含多个列。
  + 列子查询：只返回一列记录的子查询，其中可能包含多个行。
  + 表子查询：结果中可以包含多行记录，而且每行记录可能包含多列。

  按照外存查询关系，可以将子查询分为不同类型：

  + 不相关子查询：子查询可以单独运行出结果，不依赖于外层查询值
  + 相关子查询：子查询执行依赖于外层查询的值。

  ANY结合子查询：

  ```sql
  -- 子查询中的结果，如果存在一个小于m1则成立
  SELECT * FROM t1 WHERE m1 > ANY(SELECT m2 FROM t2);
  -- 上面语句与下面等价
  SELECT * FROM t1 WHERE m1 > (SELECT MIN(m2) FROM t2);
  ```

  ALL结合子查询：

  ```sql
  -- 子查询的结果，必须全部小于m1才成立
  SELECT * FROM t1 WHERE m1 > ALL(SELECT m2 FROM t2);
  -- 上面语句等价于下面
  SELECT * FROM t1 WHERE m1 > (SELECT MAX(m2) FROM t2);
  ```

  EXISTS子查询：

  仅仅需要判断子查询的结果集中是否有记录，而不在乎它的记录具体，可以使用EXISTS。

+ 子查询使用注意
  + 子查询必须使用小括号包括
  + SELECT子句的子查询必须是标量子查询
  + 可以用LIMIT 1语句来限制记录的数量
  + 对于[NOT] IN/ANY/SOME/ALL 子查询，子查询中不允许有LIMIT语句
  + 子查询中使用ORDER BY子句没意义，因为子查询相当于一个集合作用
  + 子查询中使用DISTINCT子句没意义，本身就是集合无需去重
  + 子查询中没有HAVING子句，因此GROUP BY无意义
  + 不允许增删改一个表同时还对该表进行子查询

#### 子查询在MySQL中的执行方式

##### 标量子查询、行子查询的执行方式

对于不相关标量子查询或行子查询的查询语句，MySQL会单独分别独立执行外层查询和子查询，可以看做是两次单表操作。（只有一行数据的情况）

```sql
SELECT * FROM s1 WHERE 
    key1 = (SELECT common_field FROM s2 WHERE s1.key3 = s2.key3 LIMIT 1);
```

1. 先从外查询中获取一条记录；
2. 从获取记录中取出子查询设计的值，执行子查询；
3. 根据子查询结果检测外层查询where子句的条件是否成立，成立则把外层记录加入结果集，反之丢弃；
4. 重复上述步骤。

##### IN子查询优化

IN子查询的性能瓶颈主要出现在子查询结果中数据量较大的情况，这样会导致两个问题：

+ 结果集太多，内存放不下
+ 结果集太多，对于外循环，一行记录是否符合IN中参数花费的时间很长

为了优化上述性能，MySQL会先把不相关子查询的结果集放到临时表中，写入临时表时保证临时表的列就是子查询结果集中的列，写入临时表的记录会被去重。（只保存有效的、相关的数据）

一般情况下，如果子查询结果集不超级大，会为它建立基于内存的Memory存储引擎的临时表，而且会为该表建立哈希索引。（在建立了哈希索引之后，查询速度飞快）

如果子查询结果集超级大，这时MySQL会为其创建基于磁盘存储引擎的临时表，索引类型转换为B+树索引。

MySQL把将子查询结果集保存到临时表的过程称为物化。由于物化表会创建相应的索引（基于内存的哈希索引，基于磁盘的B+树索引），因此通过IN语句判断某个 操作数是否在子查询结果集中会变得很快，这样就可以提供子查询的效率。

##### 物化表连接

对于子查询中物化表的比较，又可以转换为外表与物化表的内连接查询，这是查询优化器可以从中选择执行成本最低的一个查询。

##### 将子查询转换为semi-join

物化操作会存在建立临时表的成本，为了节约成本，MySQL引入了半连接的概念（semi-join）。

将表A和表B进行半连接指的是，对于表A的某个条记录，只关心表B是否存在与之匹配的记录，而不关心有多少条记录与之匹配，最终的结果集只保留表A的数据。

> emio-join是MySQL内部用于执行子查询的一种方式，没有面向用户的使用语法。

MySQL提供了若干中方法来实现半连接

+ Table pullout（子查询表上拉）：当子查询的查询列表处只有主键或者唯一索引列时，可以直接把子查询中的表`上拉`到外层查询的`FROM`子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中。

  ```sql
  -- 由于keys2是s2表的唯一二级索引，因此可以把s2表上拉到外层查询
  SELECT * FROM s1 WHERE key2 IN (SELECT key2 FROM s2 WHERE key3 = 'a');
  SELECT s1.* FROM s1 INNER JOIN s2 ON s1.key2 = s2.key2 WHERE s2.key3 = 'a';
  ```

+ DuplicateWeekout  execution strategy（重复键消除）：当子查询中列表除不是主键或唯一索引，转换为半连接之后可能会存在多条匹配记录，为了消除重复，可以建立一个临时表。执行连接过程是，将表中的每个数据放到临时表中去重。

+ LooseScan execution strategy（松散扫描）：对于子查询中使用了索引，而且查询的列为对应索引，则在将该查询转换为半连接之后，每次子查询中只需要获取第一个匹配到的记录即可，这种方式虽然扫描索引，但是每次只取第一条，因此将其称为松散扫描。

+ Semi-join Materialization execution strategy：IN子句的不相关子查询可能会涉及到物化，外层查询表和物化表的连接本质上也是一种semi-join。

+ FirstMatch execution strategy（首次匹配）：最原始的半连接执行方式，先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上边这个过程。

##### semi-join的适用条件

不是所有包含IN子查询的查询语句都会转换为semi-join，转换为semi-join需要符合以下条件：

+ 子查询必须是和IN语句组成的布尔表达式，并且在外层查询的WHERE或者ON子句中出现；
+ 外层查询也可以有其他的搜索条件，只不过和`IN`子查询的搜索条件必须使用`AND`连接起来；
+ 该子查询必须是一个单一的查询，不能是由若干查询由`UNION`连接起来的形式；
+ 该子查询不能包含`GROUP BY`或者`HAVING`语句或者聚集函数。

##### semi-join不适用情况

下面条件中，子查询不能装换为semi-join：

+ 外层查询的WHERE条件中有其他搜索条件与IN子查询组成的布尔表达式使用`OR`连接起来
+ 使用`NOT IN`而不是`IN`的情况
+ 在`SELECT`子句中的IN子查询的情况
+ 子查询中包含`GROUP BY`、`HAVING`或者聚集函数的情况
+ 子查询中包含`UNION`的情况

如果IN子查询不符合转换为semi-join的条件，那么查询优化器会从下边两种策略中找出一种成本更低的方式执行子查询：

+ 先将子查询物化之后再执行查询
+ 执行IN to EXISTS转换。

如果IN子查询不满足转换为semi-join的条件，又不能转换为物化表或者转换为物化表的成本太大，那么它就会被转换为EXISTS查询。

##### ANY/ALL子查询优化

如果ANY/ALL子查询是不相关子查询的话，它们在很多场合都能转换成我们熟悉的方式去执行。如：

```sql
< ANY (SELECT inner_expr ...)  ===》 < (SELECT MAX(inner_expr) ...)
> ANY (SELECT inner_expr ...)  ===》	> (SELECT MIN(inner_expr) ...)
< ALL (SELECT inner_expr ...)  ===》	< (SELECT MIN(inner_expr) ...)
> ALL (SELECT inner_expr ...)  ===》 > (SELECT MAX(inner_expr) ...)
```

##### [NOT] EXISTS子查询执行

如果[NOT] EXISTS子查询是不相关子查询，可以先执行子查询，得出该[NOT] EXISTS子查询的结果是TRUE还是FALSE，并重写原先的查询语句。

```sql
SELECT * FROM s1 WHERE EXISTS (SELECT 1 FROM s2 WHERE key1 = 'a') OR key2 > 100;
-- 由于子查询在不会随外层的变化而变化，因此可以执行一次查询，重写SQL
SELECT * FROM s1 WHERE TRUE OR key2 > 100;
```

对于相关[NOT] EXISTS 子查询，会根据外层参数执行内层子查询。

##### 派生表优化

子查询放在外层查询的FROM子句后，那么这个子查询的结果相当于一个派生表。

```sql
SELECT * FROM  (
        SELECT id AS d_id,  key3 AS d_key3 FROM s2 WHERE key1 = 'a'
    ) AS derived_s1 WHERE d_key3 = 'a';
```

>子查询( SELECT id AS d_id, key3 AS d_key3 FROM s2 WHERE key1 = 'a')的结果就相当于一个派生表，这个表的名称是derived_s1，该表有两个列，分别是d_id和d_key3。

对于派生表查询，MySQL提供两种执行策略：

1. 把派生表物化
2. 将派生表和外层合并，即将查询重写为没有派生表的形式

## 第九章、Explain详解

#### 概述

一条查询语句在可能具有多种执行方式，Explain可以帮助我们查看MySQL对每个查询具体使用了那些执行计划。Explain输出的主要信息为：

| 列名           | 描述                                                   |
| -------------- | ------------------------------------------------------ |
| id             | 在一个大的查询语句中每个SELECT关键字都对应一个唯一的id |
| select_type    | SELECT关键字对应的那个查询的类型                       |
| table          | 表名                                                   |
| partitions     | 匹配的分区信息                                         |
| type           | 针对单表的访问方法                                     |
| possiable_keys | 可能用到的索引                                         |
| key            | 实际上使用的索引                                       |
| key_len        | 实际使用到的索引长度                                   |
| ref            | 当使用索引列等值查询时，与索引列进行等值匹配的对象信息 |
| rows           | 预估的需要读取的记录条数                               |
| filtered       | 某个表经过搜索条件过滤后剩余记录条数的百分比           |
| Extra          | 额外信息                                               |

##### id

查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询。可以通过查看执行计划来判断是否被为优化。

在使用UNION时，需要创建临时表进行去重，这是产生的临时表其id属性为NULL。

##### select_type

一条大查询中可以包含若干SELECT关键字，每个SELECT关键字代表一个小查询，每个SELECT关键字的FORM子句都包含若干张表，每张表对应执行计划的一条记录，对于同一SELECT关键字的表，其id的值相同。

SELECT关键字的小查询都定义了select_type属性，知道了某个小查询的select_type属性就可以知道其在大查询中的角色。

| 名称                   | 描述                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `SIMPLE`               | Simple SELECT (not using UNION or subqueries)                |
| `PRIMARY`              | Outermost SELECT                                             |
| `UNION`                | Second or later SELECT statement in a UNION                  |
| `UNION RESULT`         | Result of a UNION                                            |
| `SUBQUERY`             | First SELECT in subquery                                     |
| `DEPENDENT SUBQUERY`   | First SELECT in subquery, dependent on outer query           |
| `DEPENDENT UNION`      | Second or later SELECT statement in a UNION, dependent on outer query |
| `DERIVED`              | Derived table                                                |
| `MATERIALIZED`         | Materialized subquery                                        |
| `UNCACHEABLE SUBQUERY` | A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query |
| `UNCACHEABLE UNION`    | The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY) |

+ PRIMARY：对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的select_type值就是PRIMARY
+ UNION：对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的select_type值就是UNION
+ UNION RESULT：MySQL选择使用临时表来完成UNION查询的去重工作，针对该临时表的查询的select_type就是UNION RESULT
+ SUBSQUERY：如果包含子查询的查询语句不能够转为对应的semi-join的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个SELECT关键字代表的那个查询的select_type就是SUBQUERY
+ DEPENDENT SUBQUERY：如果包含子查询的查询语句不能够转为对应的semi-join的形式，并且该子查询是相关子查询，则该子查询的第一个SELECT关键字代表的那个查询的select_type就是DEPENDENT SUBQUERY
+ DEPENDENT UNION：在包含UNION或者UNION ALL的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的select_type的值就是DEPENDENT UNION
+ DERIVED：采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的select_type就是DERIVED
+ MATERIALIZED：查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的select_type属性就是MATERIALIZED

##### partitions

略

##### type

执行计划的一条记录就代表着MySQL对某个表的执行查询时的访问方法，其中的type列就表明了这个访问方法。访问方法可取值为：

+ system：当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，如MyISAM、Memory
+ const：根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是const
+ eq_ref：被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的
+ ref：通过普通的二级索引列与常量进行等值匹配时来查询某个表
+ fulltext：全文检索
+ ref_or_null：对普通二级索引进行等值匹配查询，该索引列的值也可以是NULL值时
+ index_merge：使用`Intersection`、`Union`、`Sort-Union`这三种索引合并的方式时
+ unique_subquery：针对在一些包含`IN`子查询的查询语句中，如果查询优化器决定将`IN`子查询转换为`EXISTS`子查询，而且子查询可以使用到主键进行等值匹配情况
+ index_subquery：与unique_subquery类似，只不过访问子查询中的表时使用的是普通的索引
+ range：使用索引获取某些范围区间的记录，那么就可能使用到range访问方法
+ index：可以使用索引覆盖，但需要扫描全部的索引记录
+ ALL：全表扫描

##### possible_keys和key

可能用到的索引与实际用到的索引。possible_keys并不是越多越好。

##### key_len

当优化器决定使用某个索引执行查询时，该索引记录的最大长度。

##### ref

当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery其中之一时，ref列展示的就是与索引列作等值匹配的东西，可能是尝试或某个列。

##### rows

该执行计划预计需要扫描行数。

##### Extra

一些额外信息。主要有：

+ No tables used：没有FROM子句时的提示信息。
+ Impossiable WHRE：Where用于为FALSE。
+ No matching min/max row：查询列表出有MIN/MAX函数，但没有符合WHERE子句搜索条件的记录
+ Using index：使用索引覆盖
+ Using index condition：搜索条件出现了索引列，但不能使用到索引列
+ Using where：使用全表扫描来执行对某个表的查询，且语句的WHERE子句中有针对该表的搜索条件
+ Using join buffer：连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，MySQL一般会为其分配一块名叫join buffer的内存块来加快查询速度
+ Not exists：使用左（外）连接时，如果WHERE子句中包含要求被驱动表的某个列等于NULL值的搜索条件，而且那个列又是不允许存储NULL值的，那么在该表的执行计划的Extra列就会提示Not exists额外信息
+ Using intersect(...)、Using union(...)和Using sort_union(...)：使用索引合并
+ Zero limit：LIMIT子句的参数为0时，表示无需从表中读出任何记录，将会提示该额外信息
+ Using filesort：在内存中或者磁盘上进行排序的方式
+ Using temporary：使用到了内部的临时表
+ Start temporary，End temporary：略
+ LooseScan：略
+ FirstMatch(tbl_name)：略

## 第十章、Buffer Pool

#### InnoDB的Buffer Pool

InnoDB是非内存存储引擎，InnoDB会把数据保存到磁盘中。因此如果想要操作InnoDB中的数据，必须要将数据加载到内存中，InnoDB中磁盘与内存进行数据交互的基本单位是页，一页最小为16KB。由于磁盘的速度很慢，如果每次数据的时候再去将数据从内存中加载到磁盘，每次操作完数据就将数据写入磁盘，其速度是无法忍受的。

为了解决这一痛点，InnoDB提出使用buffer pool来缓存磁盘的页。当访问一个页时，会将页的完整数据加载到磁盘中，访问完毕并不直接将其写回磁盘，而是将其缓存到内存中。这一段用于缓存的内存空间由MySQL启动时进行分配，默认大小为128MB。

为了方便管理缓存页，buffer pool中会有特定的结构：

![mysql_buffer_pool_full_struct](https://gitee.com/tobing/imagebed/raw/master/mysql_buffer_pool_full_struct.png)

每个缓存页都有对应的控制信息，其占用的内存大小相同，称为控制块，控制块与缓存页一一对应；其中控制块位于buffer pool前面，缓存页位于buffer pool后面。

#### free链表管理

MySQL启动时，需要完成对Buffer Pool的初始化，先是向OS申请内存空间，之后将其划分为若干的控制块与控制页。

随着程序运行，数据页不断被加载到内存中，为了管理Buffer Pool的使用情况，使用一个free链表将空闲的缓存页对应的控制块连接起来统一管理。

这样一来，当需要从磁盘加载一页到Buffer Pool中，只需要从free链表中取出一个空闲的缓存页，完善对应控制块信息，之后可以将其从free链表中移除。

#### 缓存页哈希处理

为了能高效判断数据页是否在Buffer Pool中，可以建立页地址与缓存页的Map实现高效查找。（key为表空间号+页号，value缓存页地址）这样只需要通过表空间号+页号到Map中查找数据，如果找到则表示已经在Buffer Pool有对应缓存页，直接拿去操作，反之则没有，需要去加载。

#### flush链表的管理

对Buffer Pool中的数据页进行了修改，其与磁盘中的其他页不一致，这样的缓存页称为脏页。为了保证数据库的高效执行，往往将脏页统一管理起来，在一定时间内统一刷回磁盘，这样可以有效降低频繁刷盘导致的性能下降问题。为了方便脏页的统一管理，往往通过flush列表来讲脏页连接起来，其结果和free结构类似。

#### LRU链表管理

Buffer Pool大小有限，不可能缓存全部的数据页，当需要缓存的页超出Buffer Pool大小，即free链表没有足够的空间时，需要将一些缓存页从Buffer Pool中移除，以放入新的页。

为了提高缓存命中率，通常会使用LRU等算法来选择需要换出到磁盘的页。

为此，通常会创建LRU一个链表来记录脏页的使用情况：

+ 访问一个页时，如果页不在Buffer Pool中，则将其从磁盘中加载进来，将其控制块放到LRU链表表头；
+ 如果页已经被缓存在Buffer Pool中，直接把页对应的控制块移动到LRU链表表头；

这样一来，LRU链表中的页控制块就按照使用的先后时间进行排序，当空闲缓存页缓存不足时，只需要将LRU链表表尾元素换出到磁盘中即可。

**分区LRU管理**

简单的LRU在使用过程中会存在很多问题：

+ 问题一：预读问题。InnoDB提供预读服务，可以预先读入接下来可能要访问的数据页到Buffer Pool中。其中分为随机预读和顺序预读（区内达到一定数量页被读入，则将该区全部读入）。无论那种方式预读，都只是InnoDB猜测的结果，并不代表真实情况，如果猜测成功，会导致接下来访问数据速度大大提升，但是猜测错误，将导致新读入多余的页占用了LRU链表，换出了更有可能别访问的页。
+ 除此之外在进行一些访问查询，涉及到全表扫描时，需要依次访问全表的页，这是将会对所有的页进行一次换血，这讲言严重影响其他查询对Buffer Pool的使用。

上述问题存在的的原因就是加载到Buffer Pool的数据不一定会别使用到，再者是热数据太容易被冷数据替换，为了解决这问题，可以讲LRU链表分为两部分：

+ 一部分存储使用频率高的热数据，称为young区
+ 一部分存储使用频率较低的冷数据，称为old区

old区的数据如果在只当时间区间内被连续访问，那么讲可以从old区跃迁到young区。

#### 其他一些链表

除了LRU链表，InnoDB还有其他的链表，如unzip LRU链表，zip clean链表，zip free链表。

#### 脏页刷新磁盘

后台有个专门的进程会定期把脏页刷新到磁盘中，这样一来可以不影响用户线程处理正常的请求。主要有以下几种刷新途径：

+ BUF_FLUSH_LRU：从LRU链表尾部开始扫描一些页面，发现脏页将其刷新到磁盘中
+ BUF_FLUSH_LIST：从flush链表中刷新一部分页面到磁盘，速率取决于系统的繁忙情况

+ BUF_FLUSH_SINGLE_PAGE：有时候后台刷新脏页的速率比较慢，导致用户线程加载一页时没有足够的可见存放，这是会不得不讲LRU链表尾部的一个页面刷新到磁盘中。

## 第十一章、事务

#### 事务特性

事务是具有原子性的一系列操作，具有ACID特性。

+ Atomicity：原子性，事务执行的操作具有原子性，要么全成功，要么全部成功。

+ Isolation：隔离性，并发执行的事务不会被相互影响而导致数据最终不正确。

+ Consistency：一致性，事务执行前后，数据库从一个已知的正确状态，变换到另一个已知的正确状态。原子性和隔离性会对一致性发生影响。

+ Durability：持久性，事务执行完毕，本次事务对数据库造成的影响将会持久化到磁盘，即使发生宕机，数据库也能够恢复到事务执行完毕的状态。

事务是一个抽象概念，可以对应一个或多个数据库操作，事务中可以分为以下几种状态。

+ 活动的：事务对应的数据库操作正在执行
+ 部分提交的：事务的最后一个操作完成，但操作处于内存中，造成的影响没有刷回到磁盘
+ 失败的：事务执行过程中，遇到了某些错误而无法进行执行，或者被人为停止当前事务。
+ 中止的：撤销失败事务对当前数据库造成的影响的过程（回滚过程）
+ 提交的：一个处于部分提交的状态的事务将修改过的数据同步到磁盘，则处于提交状态。

![mysql_transc_status](https://gitee.com/tobing/imagebed/raw/master/mysql_transc_status.png)

#### MySQL事务控制

```sql
-- 开始事务
BEGIN [WORK];
START TRANSACTION; -- 可以添加修饰符，指定事务隔离级别

-- 提交事务
COMMIT [WORK];

-- 手动中止事务
ROLLBACK [WORK];
```

默认情况下，MySQL是开启自动事务提交，即每条语句算是一个独立的事务，称为自动提交。在下面情况下会自动关闭自动提交功能：

+ 显式使用`START TRANSACTION` 或 `BEGIN` 语句开启一个事务；
+ 把系统的 `autocommit` 设置为 `OFF`；

**隐式提交**

当自动提交被关闭时，事务就不会自动提交，但当执行一些语句之后，可以实现类似于COMMIT功能，会将事务自动提交，这种情况称为隐式提交。导致事务隐式提交的语句包括：

+ DDL，Data Defintion Language，定义数据库和修改数据库对象的数据定义语言；
+ 隐式使用或使用mysql数据库中的表，如ALTER USER、CREATE USER、DROP USER、RENAME USER、REVOKE、SET PASSWORD等；
+ 事务控制或关于锁定的语句，在上一个事务尚未提交的时候，使用BEGIN等开启一个新的事务，这时会导致上一个事务隐式提交。除此之外使用LOCK TABLES、UNLOCK TABLES等也会导致语句所属的事务被隐式提交；
+ 加载数据的语句，使用LOAD DATA语句来批量往数据库导入数据时，会隐式提交前面提交语句所属的事务；
+ 关于MySQL复制的语句，如START SLAVE、STOP SLAVE、RESET SLAVE、CHANGE MASTER TO等语句时也会隐式的提交前边语句所属的事务；
+ 其它的一些语句，使用ANALYZE TABLE、CACHE INDEX、CHECK TABLE、FLUSH、 LOAD INDEX INTO CACHE、OPTIMIZE TABLE、REPAIR TABLE、RESET等语句也会隐式的提交前边语句所属的事务。

## 第十二章、redo日志

#### 为什么有redo日志

InnoDB是以页为磁盘交互的基本单位，对数据的访问必须要内存中进行，在数据库中，这片内存称为Buffer Pool。但InnoDB是事务型数据库，需要满足持久性的特性，而内存中的数据库又是断电丢失的。

为了满足持久性的要求，最简单的就是在每次事务提交之前，把修改的数据页刷新到磁盘 ，但这样会存在性能问题：

+ 刷新一个完整的数据页太浪费。如果事务只修改了数据页的一行数据，就需要刷新一页数据，这样效率很低（每页默认大小16KB）；
+ 随机IO刷新数据很慢。如果事务中修改了多个数据页，而且这些数据页并不连续，这在刷新数据的时候，就会产生很多随机IO，效率更低。

为了解决上面的问题，人们引入了redo日志，即当我们对Buffer Pool中数据之后，不必将数据立即刷会磁盘，我们执行将这次操作通过写日志的方式记录下来，这样即使发生了宕机，也可以通过这些日志得知数据发生了什么修改，进而可以恢复数据。

同样是写数据，写日志的方式与写数据页的方式相比，主要有一下优点：

+ redo日志的占用空间小。redo日志执行仅仅需要保存「存储表空间+页号+偏移量+更新值」，其占用空间很小。
+ redo日志的写入是顺序IO。执行事务过程中产生的redo日志会统一保存到redo日志数据页，redo日志是按照顺序写入到磁盘，是顺序IO。

#### redo日志格式

redo日志本质记录了事务对数据库做的修改，InnoDB为不同的修改场景，定义了不同类型的redo日志，但这些类型的redo日志具有通用的结构。

![mysql_log_redo_struct_common](https://gitee.com/tobing/imagebed/raw/master/mysql_log_redo_struct_common.png)

+ type：redo日志类型。
+ space ID：表空间 id。
+ page number：页号。
+ data：redo日志具体内容。

##### 简单日志格式

对一些页面的修改只涉及简单的部分，redo日志仅仅需要记录页面信息、偏移量信息、修改内容信息等即可，InnoDB将这种格式的日志称为物理日志，它可以可以根据日志写入数据的大小划分为以下几种不同日志类型：

+ MLOG_1BYTE
+ MLOG_2BYTE
+ MLOG_4BYTE
+ MLOG_8BYTE
+ MLOG_WRITE_STRING

##### 复杂redo日志类型

有时候执行一条语句会修改很多页面，包括系统数据页面和用户数据页面。如一条简单的INSERT语句，即要修改B+树，又修改系统数据。对于B+树的修改，包含：

+ 表中索引的数量
+ 对于一个棵树，可以仅仅修改叶子页面，又可能同时修改内节点页面和叶子节点页面，甚至创建新的页面。
+ 除此数据信息之外，还可能包含每页的辅助信息，如File Header、Page Header、Page Directory。

因此，即时仅仅是一行简单的INSERT语句，它涉及到修改的内容也是很多的。为了记录这些修改，如果使用上面的简单日志格式，可有两种解决方案：

+ 在每个修改的地方记录一条redo日志。这种方式缺点就是修改的地方可能太多，导致生成的redo日志可能比整个页面还有大。
+ 将这个页面的第一个被修改的字节到最后一个被修改的字节之间的所有数据看做一条物理redo日志中的具体数据。这种方式中，页面中修改数据比较零散，导致没有修改的数据很多被记录到日志中，导致太多浪费。

综上，直接如果直接采用简单日志格式来记录比较复杂的修改，将会产生很多浪费。为此，InnoDB会采用新的日志类型来记录这些修改。这些新的日志类型既包含物理层面，又包含逻辑层面内容：

+ 物理层面：这些日志日志指明修改所在表空间、页
+ 逻辑层面：系统崩溃重启，不能直接根据这些日志记载来讲页面内的某个偏移量出恢复成某个数据，而是需要调用一些函数，通过执行这些函数进行恢复。

总之，redo日志会把事务执行过程中涉及到的数据库修改都会进行记录，这样就可以做到在系统奔溃之后把事务中做的需改进行恢复。为了高效、节省的保持这些修改信息，InnoDB设计了多种日志格式来进行保存。

#### Mini-Transaction

##### 成组写入redo日志

语句执行过程中可能涉及多处修改，为保证修改的正确性，redo日志被划分为若干不可分割的组：

+ 更新Max Row ID属性时产生的redo日志不可分割
+ 向聚餐索引对应B+树的页面插入一条记录时产生的redo日志不可分割
+ 向某二级索引对应B+树的页面插入一条记录时产生的redo日志不可分割
+ 向其他一些页面的访问操作产生的redo日志不可分割

##### Mini-Transaction概念

MySQL把对底层的一次原子性访问过程称为Mini-Transaction，检查mtr。一个mtr中可以包含一组不可分割的redo日志。

一个事务中可以包含若干语句，每一条语句由若干mtr组成，每个mtr又可以包含若干redo日志。

#### redo日志的写入

为了更好进行系统崩溃恢复，通常把通过mtr生成的redo日志放到大小为512字节的页中，把这些页称为 redo log block。

为了高效写入redo log，InnoDB提出了redo log buffer作为缓存，这片内存空间被划分为若干连续的 redo log block。

向 log buffer 中写入 redo 日志过程是顺序的，log buffer中采用对撞指针方式（buf_free）来区分使用空间和未使用的空间。

![mysql_innodb_log_buffer](https://gitee.com/tobing/imagebed/raw/master/mysql_innodb_log_buffer.png)

#### redo日志刷盘时机

Mini-Transaction运行过程中产生一组redo日志在Mini-Transaction结束时会被复制到log buffer中，这些日志会在一些情况下会被刷新的磁盘中。

+ log buffer空间不足，log buffer 大小有限，达到容量1/2需要将其刷新到磁盘保证新的log有足够的空间存放
+ 事务提交时，为了保证持久性，必须要将日志刷盘
+ 后台线程定时执行，每个一秒回刷新一次redo日志到磁盘中
+ 正常关闭服务器时  

#### redo日志文件组

MySQL数据目录的两个文件ib_logfile0和ib_logfile1是用来持久化log buffer 中的数据的。redo日志文件不止一个，而是以一个日志文件组的方式出现。这些文件以ib_logfile[数字]（数字可以是0、1、2、3...）的形式命名。将redo日志写入日志文件组时，从第0个开始，写完就接着写下一个，以此类推。

ib_logfile的日志文件可以通过配置文件进行配置，范围是2-100个，当最后一个文件写入完毕，会重新转到第0个文件接着写。即采用循环方式来使用redo日志文件。

日志文件组每个文件大小相同，格式一致，都是由两部分组成：

+ 前2048字节，前4个block用来储存管理信息；
+ 从2048字节开始到最后用来储存log buffer中的block镜像。

自从系统开始运行，就不断修改页面，也就不断生成redo日志，InnoDB通过Log Sequence Number全局变量来记录redo日志写入量。

向log buffer中写入redo日志不是一条一条写入，而是以一个mtr生成的一组redo日志为单位写入。

#### checkpoint

redo日志总容量有限，写完后面的就会回到前面接着写，这就意味着前面的内容可能会被新的内容覆盖掉。而redo日志的目的就是为了能够在系统崩溃后能够恢复Buffer Pool中尚未写入的脏页数据，如果redo记录的脏页数据已经写入磁盘，那么相应的redo日志也就无需存在了，这就是为什么redo日志文件采用循环记录的方式来保存。这样能够保证redo日志始终占用固定大小的空间。

为了保证被覆盖掉的redo日志对应的脏页数据的确已经持久化到磁盘中，InnoDB使用checkpoint_lsn来记录当期系统可以被覆盖的redo日志总量是多少，当需要将数据覆盖redo日志时，需要判断redo日志上的checkpoint_与系统变量checkpoint_lsn，确保被覆盖的redo日志对应的脏页已经被写入磁盘。

当系统中的写日志操作太频繁，如果后台刷脏页的操作赶不上不上写日志操作，为了系统能够及时checkpoint，让出新的redo位置，这是就需要用户线程同步从flush链表中把最早修改的脏页刷新到磁盘。

#### innodb_flush_log_at_trx_commit

为了实现事务持久性，用户提交事务时，需要将事务执行过程中的操作产生的redo日志都刷新到磁盘中。这种方式虽然保证了数据安全性，但是会明显降低系统性能。如果我们对数据安全性要求并没有那么高，可以通过配置innodb_flush_log_at_trx_commit属性来进行相应调整，主要有三种选项：

| 级别 | 刷盘时机                                                     | 隐患                            |
| ---- | ------------------------------------------------------------ | ------------------------------- |
| 0    | 事务提交时不立即向磁盘同步redo日志，这个任务交给后台线程执行 | 可能会丢失数据                  |
| 1    | 事务提交时将redo日志同步磁盘，保证持久性                     | 保证持久性                      |
| 2    | 事务提交时将redo日志写到操作系统缓冲区，让操作系统控制刷盘时机 | MySQL挂，OS没挂保证时保证持久性 |

## 第十三章、undo日志

#### 为什么有undo日志

事务需要保证原子性。即保证事务中的操作要么全部完成，要么全部不做。在事务执行的过程中，在中途可能会出现这样一些问题：

+ 事务执行过程出现各种错误，如服务器错误、操作系统错误、宕机等
+ 程序员可以在事务执行过程中手动输入ROLLBACK结束当前事务执行

上面都情况都会导致事务执行到一半就结束，此时如果要保证原子性，就需要回滚事务已经已经执行的操作。

回滚是事务保证原子性的关键，为了实现回滚，需要将事务执行的过程中执行的操作记录下来。如：

+ 插入记录时，需要把该记录的主键记录下来，以便于回滚时进行删除；
+ 删除记录时，需要把该记录的全部内容记录下来，便于回滚时数据恢复；
+ 修改记录时，需要把该记录修改前的旧值保存下来，便于回滚时数据恢复；

数据库将上述为了回滚而记录的东西称为撤销日志，即 undo 日志。

> 需要注意的是，由于查询操作不会对数据进行修改，因此查询操作不会记录 undo 日志。

#### 事务id

事务可以分为只读事务和读写事务：

+ 只读事务，START TRANSACTION READ ONLY，不可以对普通表进行增删改操作，但可以对临时表进行增删改操作。
+ 读写事务，STRAT TRANSACTION READ WRITE，可以对普通表进行增删改操作，默认读写事务。

为便于管理事务，InnoDB会在事务执行增删改操作时为其分配一个独一无二的事务id，分配策略为：

+ 对于只读事务，在第一次对临时表执行增删改操作时分配一个事务id，否则不分配；
+ 对于读写事务，在第一次对某个表执行增删改操作时分配一个事务id，否则不分配；

> 注意：如果一个事务中全是查询语句，没有执行增删改操作，就不需要为事务分配id

为了保证事务id唯一性，其分配的过程大抵如下：

1. 服务器在内存中维护一个全局变量，每次把该值作为分配的事务id，并将其自增；
2. 每当变量的值为256的倍数时，就会将该变量的值刷新到系统表空间中保存
3. 当系统下次启动，会从系统表空间将其加载到内存，将其加上256赋值给全局变量，这样就可以保证不会使用前面已经使用的id了

在InnoDB存储引擎的聚簇索引的记录中，有两个特殊的隐藏列 trx_id 和 roll_pointer，其中：

+ trx_id 记录了对该记录进行改动的所在事务的事务id
+ roll_pointer则记录了该记录对应的undo日志指针

需要注意的是，在将一条记录删除前， 会经历两个阶段：

+ 标记删除阶段：在事务中对一行记录执行了DELETE但未将此事务提交，该记录的delete mark会标记本记录已经被删除，但其占用能动空间以及数据仍然未被释放；（仍然留在正常记录链表）
+ 真实删除阶段：事务提交后，事务内执行了DELETE操作的语句会被真正删除，其占用的物理空间也会被真正释放。（从正常记录链表中移除，放到垃圾链表）

从上面分析可以知道，只有在标记删除阶段的记录会被回滚，而真实删除阶段的数据的事务已经被提交，无需回滚。

在对一条记录进行 delete mark 操作前，需要把该记录的旧的 trx_id 和 roll_pointer 隐藏列的值都给记到对应undo日志。这样一来只要是对一条记录进行了修改，其修改历史就会形成一条历史版本链。

![mysql_innodb_undo_chain](https://gitee.com/tobing/imagebed/raw/master/mysql_innodb_undo_chain.png)

对于undo日志，主要可以划分为两大类：

+ TRX_UNDO_INSERT_REC类：这类日志用于记录插入数据的undo日志，不会涉及MVCC，可以在事务提交之后直接将其删除；
+ 非TRX_UNDO_INSERT_REC：这类日志用于记录更新、删除数据的undo日志，涉及MVCC，即使在事务提交也不能直接删除；

#### undo页面链表

一个事务中可能包含多个语句，一个语句中可能包含对若干条记录的改动，对于每条记录的改动可以设计1或2条的undo日志，因此一个事务执行过程中可能会产生很多undo日志，有可能这些日志在一个页面放不下，因此需要使用链表将其连接形成undo页面链表。

一个事务执行过程中，可以混着 INSERT、DELETE、UPDATE 语句，这就意味着在一个事务中可能会产生不同类型的 undo 页，考虑到不同 undo 日志的功能以及特性，因此会将 undo 日志根据类型进行存放（一个undo页面要么储存INSERT操作的undo日志，要么储存UPDATE类型的undo日志）。除此之外，对于普通表和临时表的日志也采用不同的页面进行储存。

![mysql_innodb_undo_page_list](https://gitee.com/tobing/imagebed/raw/master/mysql_innodb_undo_page_list.png)

为了尽可能提高undo日志的写入效率，不同事务执行过程中产生的undo日志需要被写入到不同的undo页面中。如上图展示了两个不同事务，在执行不同语句（UPDATE/INSERT）操作不同表（普通表/临时表）时其undo日志对应保存的页面链表。

#### 回滚段

在事务执行过程中最多可以分配4个undo页面链表（临时表insert undo链表、临时表update undo链表、普通表insert undo链表、临时表 update undo链表）。为了更进一步挂了这些undo页面链表，InnoDB采用回滚段来管理这些undo页面的页号。

事务在执行过程中对普通表的记录首次改动之前，首先会到系统表分配一个回滚段。一旦某个回滚段被分配个这个事务，之后该事务对普通表的记录改动时，不会重新分配。

> 注意： 只读事务并不需要分配Undo页面链表，MySQL 5.7中所有刚开启的事务默认都是只读事务，只有在事务执行过程中对记录做了某些改动时才会被升级为读写事务。

## 第十四章、事务隔离级别与MVCC

#### 事务隔离级别

MySQL是基于客户端/服务器架构软件，一个服务器可以有多个客户端进行连接。一个客户端与服务器之间的连接称为一个会话，在会话中的一个请求语句可以是事务的一部分。这样在一个服务器内需要同时处理来自多个客户端的事务。这些并发的事务如果不加以隔离，可能会出现以下一些问题。

+ 脏写：一个事务修改另一个未提交事务修改过的数据。这回导致明明把数据更新，事务也提交，但最终数据并没有改变。
+ 脏读：一个事务读取另一个为提交事务修改过的数据。如果另一个事务对进行回滚，这个事务就相当于读取到了不存在的数据。
+ 不可重复读：一个事务能够读取另一个事务提交的修改数据，并且其他事务每次对该数据指向性修改并提交，该事务都能查到最新值。
+ 幻读：一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入符合这些条件的记录，原先的事务再次按照这些条件查询，查询出新插入的记录。

上述的这些并发事务引发的问题，按照严重性排序如下：

```java
脏写 > 脏读 > 不可重复读 > 幻读
```

针对上述这些问题，有人提出使用事务隔离级别，对并发执行事务进行一定的隔离。通常而言，隔离性越高，其性能越差，为了便于用户灵活调整 **事务的隔离性与事务执行性能** ，人们指定了一些SQL标准，其中设立了四级的隔离级别：

| 隔离级别           | 脏读         | 不可重复读   | 幻读         |
| ------------------ | ------------ | ------------ | ------------ |
| `READ UNCOMMITTED` | Possible     | Possible     | Possible     |
| `READ COMMITTED`   | Not Possible | Possible     | Possible     |
| `REPEATABLE READ`  | Not Possible | Not Possible | Possible     |
| `SERIALIZABLE`     | Not Possible | Not Possible | Not Possible |

> 注意：四级事务隔离级别读不可能发生脏写，以为它太严重，不允许存在。

不同的数据库系统对SQL标准中规定的四种隔离级别支持度不一样，如Oracle只支持READ COMMITEED 和 SERIALIZABLE 隔离级别；MySQL 虽然支持四种隔离级别，但是与SQL标准中定义的有所不同，即MySQL在REPLEATE READ下可以禁止幻读发生。

事务隔离级别可以通过以下进行设置：

```sql
-- 设置全局或当前会话的事务隔离级别
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;
```

#### MVCC原理

MVCC，Mulit-Version Concurrency Control，多版本并发控制，指的是在READ COMMITEED 和 REPEALTABLE READ 这两种隔离级别的事务执行普通 SELECT 操作访问记录的版本链的过程，通过MVCC可以是不同事务的读写、写读操作并发执行，从而提高系统性能。

对于 READ COMMITEED 和 REPEATEABLE READ 两种隔离级别，是通过生成一个 ReadView 实现。对于RERAD COMMITEED，生成 ReadView 时机是每次执行SELECT的时候；对于REPLEATABLE READ，生成 Read View 时机是第一次执行SELECT操作。

##### 记录版本链实现

InnoDB存储引擎的聚餐索引的记录包含两个必要的隐藏列，用于实现版本链：

+ trx_id：记录了最近对该行记录进行修改的的事务id
+ roll_pointer：每次记录被改动，会把旧版本写入到undo日志并通过roll_pointer连接

![mysql_innodb_undo_version_chain](https://gitee.com/tobing/imagebed/raw/master/mysql_innodb_undo_version_chain.png)

##### ReadView

ReadView用于生成一个一致性视图而引入的概念，可以用来判断版本链中哪个版本对当前事务可见。根据其生成的时机，分别可以实现 READ COMMITEED 和 REPLEATEABLE READ。ReadView实现包含以下内容：

+ m_ids：生成ReadView时当前系统中活跃（尚未提交的事务）的读写事务的事务id列表；
+ min_trx_id：生成ReadView是当前系统中活跃的读写事务中最小的事务id，即m_ids的最小值；
+ max_trx_id：生成ReadView是系统中应该分配给下一个事务的id值，需要注意：它不是m_ids的最大值；
+ creator_trx_id：表示生成该ReadView的事务的事务id，需要注意，只有对表中记录修改，才会为事务分配id；

通过生成这个 ReadView 与访问的记录进行对比，即可判断是否可以访问当前记录：

+ 如果访问的版本的trx_id属性和ReadView的creator_trx_id相同，表示当前事务正在访问自己修改过的记录，该版本可以被当前事务访问；
+ 如果访问的版本的trx_id属性小于ReadView的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView已经提交，因此该版本可以被当前事务访问；
+ 如果访问的版本的trx_id属性大于等于ReadView的max_trx_id值，表明生成该版本的事务当前事务生成ReadView之后才开启，因此该版本不可以被当前事务访问；
+ **如果访问的版本的trx_id属性在ReadView的min_trx_id和max_trx_id之间，如果trx_id不在m_ids列表中，表示创建ReadView时，该版本的事务不是活跃的，可以被访问；如果trx_id在m_ids列表，表示创建ReaView时，该版本的事务是活跃的，不可以被访问。**

经过上面的判断，如果某个版本的数据对当前事务不可，就会顺着版本链查找下一个版本的数据，依次类推，直到最后一个版本。

+ 对于READ COMMITEED，生成 ReadView 时机是每次执行SELECT
+ 对于REPLEATEABLE COMMITEED，生成 ReadView 时机是第一次执行SELECT时

> 在第四点中，如果要访问的版本的trx_id在ReadView的[min_trx_id，max_trx_id)之间，主要判断trx_id是否在活跃列表m_ids中，在m_ids中表示该事务是活跃的，没有提交，因此无法读取到。关键是ReadView生成时机的不同，m_ids也会随之变化：
>
> 对于READ COMMITEED是每次执行SELECT时区创建，如果前面两次SELECT期间的有事务新提交了，就会从 m_ids中消除，这时候就上面该事务不再活跃，已经提交，理所当然地可以查询到。
>
> 对于REPLEATEABLE READ，只在第一次SELECT创建ReadView，事务期间理所当然以看到对象都是一样的。

同时应该需要注意，MVCC机制为了实现并发事务能够同时读写数据，即读写不互斥，对于写写情况是没办法实现同时进行的。



## 第十五章、锁

锁问题也可以去查看MySQL官方提供的文档。

+ [InnoDB Locking](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)

#### 并发事务问题

并发事务可以会发生各种问题，并发事务访问相同记录的情况可以分为三种情况：

+ 读读情况：并发事务可以同时读取相同内容，不会造成任何影响；
+ 读写情况：并发事务同时分别对同一记录进行读或写，可能会导致脏读、不可重复读、幻读，采用MVCC或加锁可以解决；
+ 写写情况：并发事务相继执行，通过锁来控制，对一个记录的改动必须要先获得记录对应的锁结构，如果获取失败需要等待；

事务利用MVCC进行读操作时称为一致性无锁读/快照读。一致性读一般不会对任何记录进行加锁。

#### 锁的本质

锁本质是内存中一个结构。当一个事务想对这条记录做改动时，首先会看看内存中有没有与这条记录关联的锁结构。如果没有会在内存中创建一个，其中锁结构的主要信息如下：

+ trx信息：生成该锁结构的事务id
+ is_waiting：当前事务是否在等待

此时另外一个事务想要访问该记录，先看该记录有没有与之对应的锁机构，如果有会创建宇哥新的锁结构与该记录关联，此时其is_waiting=true，表示在等待。

当前面的事务提交之后，会把事务生成的锁结构释放掉，然后查看有没有其他事务在等待锁，发现则会将其对应的锁结构的is_waiting设置为false，并将其唤醒，让她继续执行。

#### 锁定读

使用加锁方式解决问题时，既要允许读读情况不受到影响，又要使读写、写读、写写情况中的操作相互阻塞，因此MySQL涉及了下面的锁：

+ 共享锁：Shared Locks，S锁。事务在读取一条记录时，需要先获取记录的S锁。
+ 独占锁：Exclusive Locks，X锁。事务在改动一条记录时，需要先获取记录的X锁。

其中X锁与S锁的兼容下如下：

| 兼容性 | X      | S      |
| ------ | ------ | ------ |
| X      | 不兼容 | 不兼容 |
| S      | 不兼容 | 兼容   |

MySQL 提供来两种特殊SELECT语句格式，可以在执行SELECT操作时分别获取X锁和S锁：

```sql
-- 对读取记录加S锁，允许别的事务获取这些记录的S锁，但不允许X锁
SELECT ... LOCK IN SHARE MODE;

-- 对读取记录加X锁，不允许别的事务获取这些记录的X锁或S锁
SELECT ... FOR UPDATE;
```

#### 写操作

平常的写操作主要是DELETE、UPDATE和INSERT三种：

+ DELETE：对于一条记录DELETE操作需要先定位其在B+树的位置，然后获取其X锁，然后执行delete mark操作
+ UPDATE：对一条记录更新分三种情况
  + 更新前后列占用的空间并未发生变化，先定位在B+树上位置，获取X锁，然后修改
  + 更新前后列占用的空间已经发生变化，先定位在B+树上位置，获取X锁将原记录彻底上次，再插入一条新记录
  + 更新了列对应的主键，相当于将原记录DELETE，再执行INSERT操作
+ INSERT：一般情况下，新插入一条记录不需要加锁，InnoDB使用隐式锁来保护新插入的记录在本事务提交前不会被别的事务访问到

> 定位记录在B+树上的位置的过程可以看作是获取X锁的锁定读。

 #### 多粒度锁

前面提到的锁都是针对记录的，通常也被称为行级锁或行锁，行锁的粒度比价细，对一条记录加锁仅仅能影响这条记录。一个事务也可以在表级别上加锁，通常被称为表级锁，表级锁的粒度比较粗，加表锁能够影响整个表中的记录。表锁也可以分为共享锁和排它锁。

+ 给表加S锁，会导致
  + 别的事务可以继续行获取表的S锁
  + 别的事务可以继续获取表中某些记录的S锁
  + 别的事务不可以继续获取表的X锁
  + 别的事务不可以继续获取表中所有记录的X锁
+ 给表加X锁，会导致
  + 别的事务不可以继续获取表的S锁
  + 别的事务不可以继续获取表中所有记录的S锁
  + 别的事务不可以继续获取表的X锁
  + 别的事务不可以继续获取表中所有记录的X锁

如果要对表加S锁，必须要保证表中的所有行都没有加X锁；如果要对表加X锁，必须要保证表中的所有行都没有加X锁或S锁。

为了避免在加表锁时需要遍历其中的行来判断是否能够对表上锁，InnoDB采用一种意向锁的方式来提高判断表中行的加锁情况：

+ 意向共享锁，Intention Shared Lock，IS锁。事务准备在某条记录上加S锁，需要先在表级加一个IS锁；
+ 意向独占锁，Intention Exclusive Lock，IX锁。事务准备在某条记录上X锁，需要先在表级加一个IX锁；

有了意向锁，如果要获取S锁，先去查看IS锁，如果有则需要把等IX撤销；如果要获取X锁，需要先去看IX锁，如果有则需要等IX锁和IS锁撤销。

#### MySQL中行锁和表锁

对于MySQL的其他存储引擎，如MyISAM、MEMORY、MERGE等仅支持表级锁，而且这些存储引擎并不支持事务。由于MyISAM、MEMORY、MERGE等存储引擎的表同一时刻只支持一个会话进行写操作，因此这些存储引擎最后使用在只读场景中。

#### InnoDB存储引擎中的锁

InnoDB既支持表级锁，也支持行级锁。表锁实现简单，占用资源少，但粒度很粗；行锁粒度细，可以实现更加精细的并发控制。

##### InnoDB中的表锁

执行SELECT、INSERT、DELETE、UPDATE等操作时，InnoDB不会为其添加表锁。

在对表进行ALTER TABLE、DROP TABLE等时，其他事务对这个表SELECT、INSERT、DELETE、UPDATE的语句会发生阻塞；反之亦然。这个过程是通过Server层使用的元数据锁来实现。

InnoDB提供的表锁使用场景并不多，下面是手动获取表锁：

+ LOCK TABLES t READ：对表t加表级S锁
+ LOCK TABLES t WRITE：对表t加表级X锁

InnoDB的表在对记录加S锁时，会先在表上加IS锁；对记录加X锁时，需要先在表上加IX锁；同样地，使用IS锁和IX锁是为了加表锁时需要去判断。

**AUTO-INC锁**

使用MySQL过程中，可以为表的某个列加AUTO_INCREMENT属性，使得插入数据时可以不指定该列，系统会自动为其赋上一个递增的值。自动递增列的赋值原理如下：

+ 在执行插入语句时，在表级上添加一个AUTO_INC锁，为条待插入数据的AUTO_INCREMENT修饰的列分配递增的值，在语句执行结束后，把AUTO_INC锁释放；
+ 采用一个轻量级锁，在为插入语句生成AUTO_INCREMENT修饰的列获取这个轻量级锁，如果生成本次插入语句用到的AUTO_INCREMENT列的值后，把该轻量级锁释放掉，不需要等到整个插入语句执行完再释放；

##### InnoDB中的行级锁

InnoDB中有多种行锁以适应不同的使用场景。

**Record Locks**

普通行锁，有S锁和X锁之分，规则和数据库的行锁大同小异。

**Gap Locks**

InnoDB下可以使用两种方式来解决幻读问题，一种是MVCC，另外一种是加锁。加锁时由于是新插入的记录对现有记录影响，因此访问提前对该记录进行加锁。于是InnoDB提出使用Gap Locks来防止幻影插入。**给一条记录加了Gap锁，则不允许其他事务往这条记录的前边间隙插入新的记录。**对于最后一条记录，可以利用当前页面最大记录来防止该区间被插入新的记录。

![mysql_innodb_gap_lock](https://gitee.com/tobing/imagebed/raw/master/mysql_innodb_gap_lock.png)

上图中Supremum表示页面最大记录。

> 需要注意，MVCC并不能完全解决幻影读的问题，这是因为MVCC是基于快照读，基于最新数据写的；如果在事务中出现了对新插入数据的写，会导致改行记录的事务id倒退为可见。

**Next-Key Locks**

通过Next-Key Locks可以实现即锁住某条记录，有阻止其他事务在该记录前边的间隙插入新记录。

[Next-Key Locks的本质有一个普通锁+Gap 锁组合而成](https://dev.mysql.com/doc/refman/8.0/en/innodb-next-key-locking.html)，既可以保护该条记录，有可能阻止其他事务将新的记录插入到被保护记录前面的间隙中。

**Insert Intention Locks**

一个事务在插入一条记录时需要判断位置是不是被别的事务加了Gap Lock，如果有则该插入操作需要等待直到拥有Gap Lock的事务提交。

InnoDB规定，在插入等待时需要创建一个锁结构，表明事务想在某个间隙中插入记录，但是在等待。

**隐式锁**

一个事务在执行INSERT时，如果将要插入的位置加了间隙锁，本次INSERT不会阻塞，而且当前事务会在该间隙加上一个插入意向锁，否则一般情况下INSERT不会加锁。

如果在一个事务中插入一行记录，这时另一个事务：

+ 立即使用`SELECT ... LOCK IN SHARE MODE`语句读取这记录，即获取数据的S锁。如果成立发生脏读。
+ 立即使用`SELECT ... FOR UPDATE`语句读取这条记录，即获取数据的X锁。如果成立发生脏读。
+ 立即修改这条记录，即获取数据的X锁。如果成立发生脏写。





















// TODO 为什么不用 * 作为查询条件





