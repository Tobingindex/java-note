# Java基础

## 概述

Java语言主要有以下特性：

+ **易学**：Java语法与C和C++接近，可以让大多数程序员容易学习和使用；
+ **强制面向对**象：Java提供类、接口和集成等原语，为简单起见，支持类之间的单继承，支持接口之间的多继承，支持类与接口之间的实现机制；
+ **分布式**：Java支持Internet有与开发，基本的Java应用编程接口中有一个网络应用编程接口，提供了用于网络应用编程的类库。Java的RMI机制也是分布式应用的重要手段；
+ **健壮**：Java的强类型机制、异常处理、垃圾自动回收是Java程序健壮性的重要保证；
+ **安全**：Java常用于网络环境，因此提供了安全机制防止恶意代码攻击。如ClassLoader，如分配不同名字空间方提到本地的同名类、字节码检查；
+ **体系结构中立**：Java程序在Java平台编译为体系结构中立的字节码格式，可以实现在任意按照了Java平台的任意系统中运行；
+ **解释型**：Java程序在Java平台被编译为字节码给，可以实现在任意系统的解释器上运行；
+ **性能较高**：与解释型的脚本语言相比，Java性能较高；
+ **原生支持多线程**：Java中，线程是一种特殊的对象，必须是Thread类或子类创建。

Java主要有以下特点：

+ **面向对象**：类、对象、封装、进程、多态；
+ **健壮性**：吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制；
+ **跨平台**：通过Java语言编写的应用程序在不同的系统平台上都可以运行；

Java具有两个核心机制：

+ Java虚拟机：JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。对于不同的平台，有不同的虚拟机。Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。
+ 垃圾收集机制：Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。

## 基本语法

### 变量

#### 变量分类-按数据类型

![image-20210831223231175](https://gitee.com/tobing/imagebed/raw/master/image-20210831223231175.png)

#### 变量分类-按声明位置

![image-20210831223411963](https://gitee.com/tobing/imagebed/raw/master/image-20210831223411963.png)

+ 成员变量：方法外，类体内声明的变量；
+ 局部变量：方法内声明的变量，除形参外需要显式初始化。

#### 数据类型

**整型**

| 类型  | 占用空间(字节/Byte) | 表示范围               |
| ----- | ------------------- | ---------------------- |
| byte  | 1                   | -128~127               |
| short | 2                   | -2^15~2^15-1           |
| int   | 4                   | -2^31~2^31-1(21亿左右) |
| long  | 8                   | -2^63~2^63-1           |

+ 整型常量默认为int，long类型常量需要加「l」或「L」；

**浮点类型**

| 类型   | 占用空间(字节/Byte) | 表示范围               |
| ------ | ------------------- | ---------------------- |
| float  | 4                   | -3.403E38 ~ 3.403E38   |
| double | 8                   | -1.798E308 ~ 1.798E308 |

+ float：单精度，尾数可以精确到7位有效数字；
+ double：双精度，节点是float两倍；
+ Java中浮点型默认为double，声明float型变量需要加「f」或「F」

**字符型**

+ Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。

+ char类型可以进行运算，运算是使用的是对应Unicode编码；

+ 字符型变量有三种表现形式：

  ```java
  // 使用单引号括起来的单个字符
  char c1 = 'a';
  char c2 = '中';
  char c3 = '9';
  // 使用转义字符「\」将后面的字符转变为特殊字符型常量
  char c4 = '\n';
  // 直接使用Unicode值表示字符型常量
  char c5 = '\u1234';
  ```

**布尔类型**

boolean类型用于判断逻辑条件，一般用于程序流程控制：if、while、do-while、for；

boolean一般只允许去true或false，无null；

Java虚拟机没有提供任何供Boolean值专用字节码指令，Java表达操作的boolean在编译之后都是用Java虚拟机中的int数据类型来代替，true用1表示，flase用0表示。

#### 基本数据类型转换

自动类型转换：容量小的类型自动转换为容量大的数据类型。

![image-20210831234525289](https://gitee.com/tobing/imagebed/raw/master/image-20210831234525289.png)

+ 多种数据类型的数据混合运算时，系统先自动将所有数据类型转换为容量大的类型，再进行计算；
+ byte、short、char之间不会先相互转换，计算时实现转换为int；
+ boolean类型不能与其他数据类型运算；
+ 把任何基本数据类型的值和字符串进行连接运算(+)时，基本数据类型将自动转换为字符串类型。

#### String

String不是基本数据类型，是引用数据类型，但是使用方式和基本数据类型一致，如`String str = "tobing";`。一个字符串可用串接另个字符串，也可以直接串接其他数据类型。

#### 强制类型转换

将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。

#### 二进制

二进制整数有以下三种表示方式：

+ 原码：直接将一个数值转换为二进制数，最高位是符号位；
+ 负数的反码：对原码按位取反，最高位确定为1；
+ 负数的补码：反码加1。

计算机以二进制**补码**的形式保存所有的整数。

### 运算符

运算符是一种特殊的发挥好，可以用于表示数据的运算、复制和比较。

> 算术运算符

+ 对负数取模，可以把模数符号忽略不计。如果模数为负数则不可忽略。取模运行的结果不一定总是整数。
+ 对于除号「/」，整数除和小数除有所区别，整数之间做除法，值保留整数
+ 「+」出字符串相加功能，还能把非字符串转换为字符串

> 位运算

位运算直接对整数的二进制进行运算

| 运算符 | 含义       | 细节                                       |
| ------ | ---------- | ------------------------------------------ |
| <<     | 左移       | 空位补0，被移除的高位丢弃，空缺位补0。     |
| >>     | 右移       | 最高位为0，右移补0；最高位是1，空缺位补1。 |
| >>>    | 无符号右移 | 最高位无论是0还是1，空位都用0补。          |
| &      | 与运算     | 二进制位与，同1为1，其余为0.               |
| \|     | 或运算     | 二进制位或，有1为1，其余为0.               |
| ^      | 异或运算   | 二进制位，同假，异真                       |
| ~      | 取反运算   | 各位取反                                   |

### 程序流程控制

> switch与if

+ 判断的具体数值不多，而且符合byte、short 、char、int、String、枚举等几 种类型。虽然两个语句都可以使用，建议使用swtich语句。因为效率稍高。
+ 其他情况：对区间判断，对结果为boolean类型判断，使用if，if的使用范围更广。 也就是说，使用switch-case的，都可以改写为if-else。反之不成立。

> break与continue

+ break只能用于switch语句和循环语句中。
+ continue 只能用于循环语句中。
+ 二者功能类似，但continue是终止本次循环，break是终止本层循环。
+ break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。
+ 标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。
+ 很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条 语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同 于goto的。

## 面向对象

### 访问修饰符

| 修饰符    | 类内部 | 同一个包 | 不同包子类 | 同一工程 |
| --------- | ------ | -------- | ---------- | -------- |
| private   | YES    |          |            |          |
| 缺省      | YES    | YES      |            |          |
| protected | YES    | YES      | YES        |          |
| public    | YES    | YES      | YES        | YES      |

对于class的权限修饰只可以用public和default(缺省)。

### ==与equals

对于基本数据类型，==用于比较两个变量值是否相等；

对于引用数据类型，==用于比较两个对象的引用是否相等；

equals是Object的方法，所有的对象都继承自Object，所有对象都具有equals方法；

equals方法是默认实现是调用==操作符比较当前对象引用是否与给定对象引用相同；

一般情况下往往会对equals进行重写，用于比较两个对象内容是否相同。

### 自动装箱与自动拆箱

装箱：包装类使得一个基本数据类型的数据变成了类。

拆箱：将数字包装类中内容变为基本数据类型。

```java
// 装箱
int i = 500;
Integer t = new Integer(i);

// 拆箱
int j = t.intValue()
```

### 接口

接口(interface)是抽象方法和常量值定义的集合。

接口中的所有成员变量都默认是由public static final修饰的。

接口中的所有抽象方法都默认是由public abstract修饰的。

接口中没有构造器。

接口采用多继承机制。

Java8中，接口添加了静态方法和默认方法。

+ 静态方法：使用static修饰。可以通过接口直接调用静态方法，并执行方法体。
+  默认方法：使用default修饰。通过类对象调用。Java8的API中Collection、List、Comparator等接口提供了丰富的默认方法。
+ 若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同 参数的方法，在实现类同时实现了这两个接 口时，会出现：接口冲突。
+ 若一个接口中定义了一个默认方法，而父类中也定义了一个同名同参数的非 抽象方法，则不会出现冲突问题。因为此时遵守：类优先原则。接口中具有 相同名称和参数的默认方法会被忽略。

> 抽象类与接口

| 区别         | 抽象类                                                       | 接口                                        |
| ------------ | ------------------------------------------------------------ | ------------------------------------------- |
| 定义         | 包含抽象方法的类                                             | 主要是抽象方法和全局常量的集合              |
| 组成         | 构造方法、抽象方法、普通方法、 常量、变量                    | 常量、抽象方法、(jdk8.0:默认方法、静态方法) |
| 使用         | 子类继承抽象类(extends)                                      | 子类实现接口(implements)                    |
| 关系         | 抽象类可以实现多个接口                                       | 接口不能继承抽象类，但允许继承多个接口      |
| 常见设计模式 | 模板方法                                                     | 简单工厂、工厂方法、代理模式                |
| 对象         | 都通过对象的多态性产生实例化对象                             | 都通过对象的多态性产生实例化对象            |
| 局限         | 抽象类有单继承的局限                                         | 接口没有此局限                              |
| 实际         | 作为一个模板                                                 | 是作为一个标准或是表示一种能力              |
| 选择         | 如果抽象类和接口都可以使用的话，优先使用接口，因为避免单继承的局限 |                                             |

### 内部类

在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。

Inner class一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。

内部类又分为成员内部类和局部内部类：

+ 成员内部类：static成员内部类和非static成员内部类
+ 局部内部类：匿名内部类

和外部类不同：

+ Inner class还可以声明为private或protected；

+ 可以调用外部类的结构
+ Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；

需要注意：

1. 非static的成员内部类中的成员不能声明为static的；
2. 只有在外部类或static的成员内部类中才可声明static成员；
3. 外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式
4. 成员内部类可以直接使用外部类的所有成员，包括私有的数据
5. 当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的

**局部内部类**特点：

+ 内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。
+ 只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。
+ 局部内部类可以使用外部类的成员，包括私有的。
+ <font style="color:red">**局部内部类可以使用外部方法的局部变量，但是必须是final的**。</font> 由局部内部类和局部变量的声明周期不同所致。
+ 局部内部类和局部变量地位类似，不能使用public，protected，缺省，private
+ 局部内部类不能使用static修饰，因此也不能包含静态成员

#### 代码块

+ 静态代码块
  + 可以有输出语句
  + 可以对类的属性、类的声明进行初始化操作
  + 不可以对非静态的属性初始化
  + 有多个静态代码块，按照从上带下的顺序一次执行
  + 静态代码块的执行要先于非静态代码块
  + 静态代码块随着类的加载而加载，且只执行一次
+ 非静态代码块
  + 可以有输出语句
  + 可以对类的属性、类的声明进行初始化操作
  + 除了调用非静态的结构外，还可以调用静态的变量或方法
  + 若有多个非静态的代码块，按照从上到下的顺序依次执行
  + 每次创建对象时，都会执行一次。且先于构造器执行

## 异常

Java语言中，将程序执行中发送的不正常情况称为「异常」。

### 异常分类

Java在执行过程中发生的异常事件可以分为两类：

+ Error：Java虚拟机解决的严重问题。如JVM系统内部错误、资源耗尽等严重情况。一般编写针对性的代码就行处理。
+ Exception：其他因编程称为或偶然的外在因素导致的一般性问题。可以使用针对性的代码就行处理。

对于Exception，可以可以分为受检异常和非受检异常：

+ 非受检异常：编译器不要求强制处理的异常。一般是由编程时的逻辑错误导致，是程序员应该积极避免出现的异常。java.lang.RuntimeException类及其子类都是非受检异常。
  + ClassCastException
  + ArrayIndexOutOfBoundsException
  + NullPointerException
  + ArithmeticException
  + NumberFormatException
  + InputMismatchException
+ 受检异常：编译器强制要求处理的异常。程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有受检异常。
  + java.io.IOException
    + FileNotFoundException
    + EOFException
  + java.lang.ClassNotFoundException
  + java.lang.InterruptedException
  + java.io.FileNotFoundException
  + java.sql.SQLException

### 异常处理

Java采用的异常处理机制，是将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁、优雅，并易于维护。

程序运行过程中，虚拟机检测到程序发生了问题，如果当前代码没有找到相应的处理程序，就会在后台自动创建一个对应的异常类的实例对象并抛出，这个过程称为「异常的自动抛出」。

除此之外，程序员也可以在程序执行时使用throw手动抛出一个运行时异常。

如果在一个方法内抛出异常，异常的对象会被抛给调用者方法中处理。如果异常没有在调用者方法中处理，会继续抛给这个方法的调用者，指定异常被处理。

如果一个异常回到main方法，且main方法也不处理，这给异常将会交个虚拟机来处理，虚拟机通常采用的处理方式就是把程序终止。

因此为了保证程序正常执行，代码必须对可能出现的异常机型处理。异常的处理通常有两种处理方式：使用try-catch-finally 或 使用throws

> try-catch-finally

```java
try{
...... //可能产生异常的代码
}
catch( ExceptionName1 e ){
...... //当产生ExceptionName1型异常时的处置措施
}
catch( ExceptionName2 e ){
...... //当产生ExceptionName2型异常时的处置措施
}
finally{ // 可选
...... //无论是否发生异常，都无条件执行的语句
} 

```

catch：如果明确知道产生的何种异常，可以将该异常类作为catch的参数；也可以将其父类作为catch的参数。

finally：捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够对程序的状态作统一的管理。

不论是try代码是否发送异常事件，catch语句是否执行，catch语句是否有异常，catch语句是否有return，finally中的语句都会被执行。

> 使用throws声明抛出异常

如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。

在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类型，也可以是它的父类。

### 自定义异常类

一般地，用户自定义异常类都是RuntimeException的子类。

自定义异常类通常需要编写几个重载的构造器。

自定义异常需要提供serialVersionUID

自定义的异常通过throw抛出。

自定义异常最重要的是异常类的名字，当异常出现时，可以根据名字判断异常类型

## 线程















