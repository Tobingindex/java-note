# 设计模式

## 一、概述

编写高质量代码

![image-20210802153353917](https://gitee.com/tobing/imagebed/raw/master/image-20210802153353917.png)

### 面向对象

目前主流的编程范式有三种，分别是面向过程、面向对象和函数式编程。面向对象是三种之中最为主流的一种，大部分的编程语言都是面向对象编程语言。面向对象编程具有丰富的特新（封装、抽象、继承、多态），可以实现复杂的设计思路，是很多设计原则和设计模式变化实现的基础。

### 设计模式

设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套**解决方案**或者**设计思路。**大部分设计模式要解决的都是代码的可扩展性问题。

经典的设计模式有 23 种 ，它们可以分为三大类：创建型、结构型、行为型。  

+ **创建型**
  + 常用：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。
  + 不常用：原型模式。
+ **结构型**
  + 常用：代理模式、桥接模式、装饰者模式、适配器模式。
  + 不常用：门面模式、组合模式、享元模式。  
+ **行为型**
  + 常用：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。
  + 不常用：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。

通过设计模式可以让我们写出可扩展、可读、可维护的高质量代码。

+ **可维护性(maintainability)**：代码易维护，指的是在不破坏原有代码设计、不引入新的 bug 的情况下，能够快速地修改或者添加代码。 如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。 
+ **可读性(readability)**：代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等  。（可以体现在code review）
+ **可扩展性(extensibility)**：在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。（对修改关闭，对扩展开放）
+ **灵活性(flexibility)**：易扩展、易复用或者易用。
+ **简洁性(simplicity)**：代码简单、逻辑清晰。
+ **可复用性(reusability)**：尽量减少重复代码的编写，复用已有的代码。(继承、多态、单一职责、解耦合、高内聚、模块化)
+ **可测试性(testability)**：单元测试。

### 编程规范

编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具
体、更加偏重代码细节。（可以参考《重构》《代码大 全》《代码整洁之道》等）

### 代码重构

重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，
能有效避免代码腐化到无可救药的地步。重构的工具就是面向对象设计思想、设计原则、设计模式、编码规范。

### 设计原则


SOLID 原则 -SRP，Single Responsibility Principle 单一职责原则

SOLID 原则 -OCP，Open Closed Principle  开闭原则

SOLID 原则 -LSP，Liskov Substitution Principle 里式替换原则

SOLID 原则 -ISP，Interface Segregation Principle 接口隔离原则

SOLID 原则 -DIP，Dependency Inversion Principle 依赖倒置原则

DRY 原则，Don’t Repeat Yourself  ，不要写重复的代码

KISS 原则，Keep It Simple and Stupid，尽量保持简单

YAGNI 原则，You Ain’t Gonna Need It  ，不要过度设计

LOD 法则，Law of Demeter ，迪米特法则，最小知识原则

## 二、设计原则

#### 单一职责原则

<font style="color:red">**一个类或者模块只负责完成一个职责（或者功能）。  **</font>

一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。  如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2

> 单一职责原则注意事项和细节

+ 降低类的复杂度，一个类只负责一项职责。
+ 提高类的可读性，可维护性
+ 降低变更引起的风险
+ 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。所以，我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。

#### 接口隔离原则

<font style="color:red">**客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖应该建立在最小的接口上。**</font>

类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口 Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。

按隔离原则应当这样处理： 将接口Interface1拆分为独立的几个接口， 类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。（接口拆分）

> 接口隔离原则与单一职责原则

接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。**单一职责原则针对的是模块、类、接口的设计**。而**接口隔离原则**相对于单一职责原则，一方面它**更侧重于接口的设计**，另一方面它的思考的角度不同 。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。  

#### 依赖倒转原则

<font style="color:red">**高层模块不应该依赖低层模块。高层模块和低层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。**</font>

依赖倒转(倒置)的中心思想是**面向接口编程**。

依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类。（抽象比具体稳定）

> 依赖倒转原则的注意事项和细节

+ 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好
+ 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在 一个缓冲层，利于程序扩展和优化
+ 继承时遵循**里氏替换原则**

##### 控制反转

控制反转，Inversion Of Control，IOC是一种实现，并不是一种具体的实现方法，一般用于指导**框架层面设计**。此处的**控制**指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。**流程的控制权从程序员“反转”给了框架**。  

##### 依赖注入

依赖注入，Dependency Injection  ，DI和控制反转相反  ，是一种编程技巧。使用依赖注入，我们不通过new的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递(注入)给类使用。

我们可以通过依赖注入框架提供的扩展点，简单配置一下需要的类，以及类与类之间的依赖关系，这样就可以有框架来自动创建对象、管理对象的生命周期、依赖注入等操作。

#### 里式代换原则

<font style="color:red">**子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。 **</font>

子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。  

> 违反里氏代换的例子

1. 子类违背父类声明要实现的功能  

   父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。  

2. 子类违背父类对输入、输出、异常的约定  

   某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。  

3. 子类违背父类注释中所罗列的任何特殊说明  

   父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额……”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。  

#### 开闭原则

<font style="color:red">**一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用 方)。用抽象构建框架，用实现扩展细节。**</font>

添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。  

开闭原则编程中最基础、最重要的设计原则。当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。

#### 迪米特法则

<font style="color:red">**迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。**</font>也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public 方法，不对外泄露任何信息。

迪米特法则更加简单的定义是：只与直接的朋友通信

直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系， 我们就说这两个对象之间是朋友关系。耦合的方式很多，**依赖，关联，组合，聚合** 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。

也就是说，陌生的类最好不要以局部变量 的形式出现在类的内部。

>迪米特法则注意事项和细节

迪米特法则的核心是**降低类之间的耦合**，并不是要求完全没有依赖关系。

#### 合成复用原则

原则是尽量使用合成/聚合的方式，而不是使用继承。

#### 积分系统设计

在Google中，大部分工程师都具有产品是为，不是完全的技术控。

在设计一个系统时，需要学会借鉴，如设计一个积分系统，可以借鉴淘宝的积分系统。

借鉴的方式可以有两种，一种是直接使用，第二种就是直接百度。通过这两部可以对积分系统的设计有大概的的了解，除此之外还需要结合到产品实际，并适当微创新。

有了这些“粗糙”的设计，还需要进一步明确业务细节。这时候可以通过线框图、用户用例来细化业务流程，挖掘不容易想到的的细节、功能点。

用户用例是用来模拟用户如何使用产品，描述用户在一个特定的场景下的一个完整的业务操作流程。它包含更多细节，容易被人理解。

在明确了具体的业务新设计就需要进行系统设计，主要分为以下步骤：

1. 合理地将功能划分到不同模块
2. 设计模块与模块之间的交互关系，常见的有同步(简单，适用于上下层系统)和异步(解耦，适用于同层系统)
3. 设计模块的接口、数据库、业务模型

进行积分系统的需求分析和系统设计，接下来则是代码实现。在代码实现过程中，主要要进行以下内容：

+ 接口设计：要符合单一职责原则，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。  

+ 数据库设计：要求稳定，一般不改动

+ 业务模型设计：系统还比较简单，使用贫血的MVC三层

> MVC分层的好处
>
> + 分层能起到代码复用的作用 
> + 分层能起到隔离变化的作用  
> + 分层能起到隔离关注点的作用  
> + 分层能提高代码的可测试性  
> + 分层能应对系统的复杂性  

#### 设计原则总结

<font style="color:red">**以上七大设计原则的核心思想是，找出应用中可能需要变化的地方，把它们独立出来，不要和那些不需要变化的代码混起来。针对接口编程，而不是针对实现编程。为了交互对象之间的松耦合设计而努力了。**</font>

![image-20210804203318851](https://gitee.com/tobing/imagebed/raw/master/image-20210804203318851.png)





## 三、设计模式

### 简介

设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验，模式不是代码，而是某类问题的**通用解决方案**，设计模式（Design pattern）代表了最佳的实践。这些解决方案是众多软件开发人员经过相当长的一段时 间的试验和错误总结出来的。

设计模式的本质提高 软件的维护性，通用性和扩展性，并降低软件的复杂度。

设计模式分为三种类型，共23种。

+ 创建型：**单例**、抽象工厂、原型、建造者、**工厂**
+ 结构型：适配器、桥接、**装饰**、组合、外观、享元、**代理**
+ 行为型：模板方法、命令、访问者、迭代器、**观察者**、中介者、备忘录、解析器、状态、策略、责任链

### 创建型

#### 单列设计模式

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法(静态方法)。

> 比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个SessionFactory就够，这是就会使用到单例模式。
>
> 储存之外JDK中的System类也使用了单例设计模式。

单例设计模式在编写时，需要关注的点主要为以下几个点：

+ 构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；
+ 考虑对象创建时的线程安全问题；
+ 考虑是否支持延迟加载；
+ 考虑 getInstance() 性能是否高（是否加锁）。

单列设计模式一共有七种实现方式：

| 单例模式                                                     | 并发安全   | 是否懒加载 | 备注                                              | 是否推荐 |
| ------------------------------------------------------------ | ---------- | ---------- | ------------------------------------------------- | -------- |
| [饿汉式静态常量](https://github.com/Tobingindex/java-code/blob/master/java-design-pattern/src/main/java/design_pattern/singleton/SingletonDemo01.java) | :+1:       | :no_entry: | JVM保证并发安全，类加载的时候初始化               | 可用     |
| [饿汉式静态代码块](https://github.com/Tobingindex/java-code/blob/master/java-design-pattern/src/main/java/design_pattern/singleton/SingletonDemo02.java) | :+1:       | :no_entry: | JVM保证并发安全，类加载的时候初始化               | 可用     |
| [懒汉式线程不安全](https://github.com/Tobingindex/java-code/blob/master/java-design-pattern/src/main/java/design_pattern/singleton/SingletonDemo03.java) | :no_entry: | :+1:       | 单线程可用，多线程不推荐使用                      | 不推荐   |
| [懒汉式线程安全同步方法](https://github.com/Tobingindex/java-code/blob/master/java-design-pattern/src/main/java/design_pattern/singleton/SingletonDemo04.java) | :no_entry: | :+1:       | 使用synchronized修饰方法，高并发时性能差          | 不可以   |
| [双重检查锁](https://github.com/Tobingindex/java-code/blob/master/java-design-pattern/src/main/java/design_pattern/singleton/SingletonDemo05.java) | :+1:       | :+1:       | 使用synchronized块和双重判断，高并发性能较好      | 推荐     |
| [静态内部类](https://github.com/Tobingindex/java-code/blob/master/java-design-pattern/src/main/java/design_pattern/singleton/SingletonDemo06.java) | :+1:       | :+1:       | 利用JVM内部机制，既实现线程安全，又保证了并发性能 | 推荐     |
| [枚举](https://github.com/Tobingindex/java-code/blob/master/java-design-pattern/src/main/java/design_pattern/singleton/SingletonDemo07.java) | :+1:       | :+1:       | 利用JVM内部机制，既实现线程安全，又保证了并发性能 | 推荐     |

提前初始化的利弊是要根据使用场景而定的，并不是说提前占用了资源就是不好的。

如果初始化耗时长，最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能。采用饿汉式实现方式，将耗时的初始化操作，提前到程序启动的时候完成，这样就能避免在程序运行的时候，再去初始化导致的性能问题。  

如果实例占用资源多，按照 fail-fast 的设计原则（有问题及早暴露），那我们也希望在程序启动时就将这个实例初始化好。如果资源不够，就会在程序启动的时候触发报错（比如Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。

除此之外，单例模式还会存在以下问题：

+ 单例对 OOP 特性的支持不友好
+ 单例会隐藏类之间的依赖关系
+ 单例对代码的扩展性不友好
+ 单例对代码的可测试性不友好
+ 单例不支持有参数的构造函数

#### 简单工厂模式

<font style="color:red">**定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)。**</font>

简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。

在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。

#### 工厂方法模式

<font style="color:red">**定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。**</font>

#### 抽象工厂模式

<font style="color:red">**定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。**</font>

抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。将工厂抽象成两层，AbsFactory(抽象工厂) 和 具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

**工厂模式在JDK中的应用**

在JDK的Calendar中，使用了简单工厂模式。

**工厂模式总结**

工厂模式将实例化对象的代码提取出来，放到一个类中统一管理和维护，从而达到和主项目依赖关系解耦，提高了项目的扩展和维护性。

三种工厂模式遵循了设计模式的依赖抽象原则：

+ 创建对象实例时，不直接new类，而是把new的操作放到工厂的方法中。
+ 不要让类继承具体的类，而是继承抽象类或是实现interface。
+ 不覆盖基类中已经实现的方法。

## 四、面向对象

### OOA、OOD与OOP

面向对象分析，OOA， Object Oriented Analysis。  

面向对象设计，OOP，Object Oriented Design。  

面向对象编程，OOP， Object Oriented Programming。  

面向对象编程语言，OOPL，Object Oriented Programming Language。  

在OOA和OOD阶段，需要围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。

简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。  

为了能够规范地进行OOA和OOD，可以使用UML来进行建模，但是由于其成本高，不是很推荐使用。

### UML

UML，Unified modeling language，统一建模语言。是一种用于软件系统分析和设计的语言工具，用于帮助软件开发人员进行思考和记录思路的结果。

UML本身是一套符号的规定，这些符号可以用于描述软件模型中的各元素之间的关系，如类、接口、实现、泛华、依赖、组合、聚合等。

UML图主要以下分类：

+ 用例图
+ 静态结果图：类图、对象图、包图、组件图、部署图
+ 动态行为图：交互图、状态图、活动图

其中，类图是描述类与类之间的关系，是UML中的核心。

UML中，类图用于描述系统中的类(对象)本身的组成和类(对象)之间的各种静态关系。类之间的关系包含了：依赖、泛化（继承）、实现、关联、聚合与组合等。

**依赖关系 Dependence**

只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编 绎都通过不了。如

+ 类中用到了对方
+ 如果是类的成员属性
+ 如果是方法的返回类型
+ 是方法接收的参数类型
+ 方法中使用到

**泛化关系 Generalization**

泛化关系实际上就是继承关系，是依赖关系的特例。

**实现关系 Implementation**

实现关系实际上就是A类实现B接口，是依赖关系的特例。

**关联关系 Association**

关联关系实际上就是类与类之间的联系，他是依赖关系的特例。

关联具有导航性：即双向关系或单向关系。

关系具有多重性：如“1”（表示有且仅有一个），“0...”（表示0个或者多个）， “0，1”（表示0个或者一个），“n...m”(表示n到 m个都可以),“m...*”（表示至少m 个）。

**聚合关系 Aggregation**

聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开。聚 合关系是关联关系的特例，所以他具有关联的导航性与多重性。

**组合关系 Composition**

组合关系也是整体与部分的关系，但是整体与部分不可以分开。

### 面向对象特性

面向对象具有是四大特性：封装、抽象、继承、多态。

#### 封装 Encapsulation

封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。

封装的实现需要编程语言本身提供一定的语法机制来支持，这个机制就是访问权限控制。如Java中的private等权限修饰符。

通过封装，类通过有限的方法暴露必要的操作，一方面可以隐藏内部数据，保证数据的安全，另一方面可以隐藏类内部的复杂实现，提高类的易用性。

#### 抽象 Abstraction

抽象主要可以隐藏方法的具体实现，让调用者只需要关心提供哪些功能，并不需要知道这些功能的具体实现。

在面向对象中，通常借助编程语言提供的接口类（比如 Java 中的 interface 关键字
语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象。

抽象作为一种只关注功能点不关注实现的设计思路，可以帮我们的大脑过滤掉许多非必要的信息。  

很多设计原则都体现了抽象的设计思想，比如基于接口而非实现编程、开闭原则（对扩展
开放、对修改关闭）、代码解耦（降低代码的耦合性）。

#### 继承 Inheritance

继承是用来表示类之间的is-a关系。从继承关系上来讲，继承可以分为两种模式，单继承
和多继承。

为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，如Java使用了extend关注来实现继承，C++使用冒号等。

继承最大的好处就是代码复用。但是除了通过**继承**来实现**代码复用**，也可以通过**组合**关系来实现代码复用。需要注意的是，过度使用继承，继承层次太深态复杂，会导致代码可读性、可维护性变差。

> 思考：为什么有些语言支持多继承，有些语言不支持多继承？
>
> 多继承会带来菱形继承的问题。例如一个类的两个父类，都继承了同一个祖父类，两个父类都 override 了祖父类的方法，这时候孙子类就不知道如何调用了。  

#### 多态 Polymorphism

多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现。

多态这种特性也需要编程语言提供特殊的语法机制来实现：

+ 编程语言支持父类引用指向之类对象
+ 编程语言支持继承
+ 编程语言支持子类可以重写父类的方法

除了通过继承+重写的方式来实现，还可以通过实现的方式来实现。

利用多态可以提高代码的可扩展性和复用性。

### 面向过程与面向对象

与面向对象一样，面向过程编程也是一种编程范式或编程风格。它以过程（可以为理解方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法
来操作数据完成一项功能。  

以看出，面向过程和面向对象最基本的区别就是，代码的组织方式不同。**面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。**  

在项目中，尽管我们使用Java作为了开发语言，但是我们会经常写出面向过程的代码。

如直接用 IDE 或者 Lombok 插件自动生成所有属性的 getter、setter 方法，这种方式虽然使用简单，但是实际上它违反了面向对象编程的封装特性，是一种面向过程的编程风格。

另外在Java项目滥用全局变量和全局方法也会导致退化为面向过程编程，但是这些全局变量和全局方法也有一定的存在意义，因此在实际中需要去避免将全部常量定义到一个类中，而应该根据业务、功能将常量拆分到多个类中。

最后，传统的MVC模式中，一般情况下都需要要定义VO、BO、Entity，而这些类中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这也是典型的面向过程的编程风格。  

### 接口与抽象类

#### 抽象类

抽象类不允许被实例化，只能被继承。

抽象类可以包含属性和方法，方法包含了抽象方法和非抽象方法。

子类继承抽象类，必须实现抽象类中的所有抽象方法。 

#### 接口

接口不能包含属性（也就是成员变量）。

接口只能声明方法，方法不能包含代码实现。

类实现接口的时候，必须实现接口中声明的所有方法。  

#### 总结

继承关系是一种 is-a 的关系，抽象类属于类，表示的也是一种 is-a 的关系。

接口表示一种 has-a 的关系，表示具有某种功能。

抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。

#### 模拟接口

接口中没有成员变量，只有方法声明，没有方法实现，实现接口的类必须实现接口中的所有方法。只要满足上述定义，从设计角度可以认为是一个接口。

因此通过定义一个没有任何属性，并且方法都定义为abstract，这样一来就可以模拟一个接口；

除此之外还可以通过普通类类模拟一个接口，即让类中的所有方法都抛出异常，进而来限制用户在继承类的同时必须重写这些方法。除此之外通过为这个类的构造函数添加protected访问权限来避免该类实例化。

#### 基于接口而非实现的

基于接口而非实现编程，英文原文是“Program to an interface, not an implementation”。从本质来讲，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”  ，而不能简单理解为Java的接口。

通过这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。  

“基于接口而非实现编程”可以表示为“基于抽象而非实现编程”。

越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。  

条原则的设计初衷是，将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高代码的扩展性。  

如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。  

#### 组合优于继承

继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但继承层次过深、过复杂，也会影响到代码的可维护性。