# Redis设计与实现-其他独立功能

## 一、发布与订阅

#### 概述

Redis的发布于订阅功能有PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成。

通过执行SUBSCRIBE命令，客户端可以订阅一个或多个频道，从而成为这些频道的订阅者，每当有其他客户端往频道发送消息，频道的所有订阅者都会受到这条消息。

除了订阅频道，客户端还可以通过执行PSUBSCRIBE命令订阅一个或多个模式，从而成为这些模式的订阅者，每当有其他客户端向频道发送消息，消息不仅会发送给这些频道，还会发送给所有与这个频道相匹配的模式的订阅者。

![image-20210605201554544](https://gitee.com/tobing/imagebed/raw/master/image-20210605201554544.png)

如上图所示：

+ 客户端A正在订阅频道“new.it”
+ 客户端B正在订阅频道“new.et“
+ 客户端C和客户端D正在订阅与”new.it“、”new.et“频道相匹配的模式”news.[ie]t“

#### 频道的订阅与退订

当一个客户端执行SUBSCRIBE命令订阅某个或某些频道的时候，这个客户端与被订阅频道之间就建立了一种订阅关系。

Redis将所有频道的订阅关系都保存在服务器状态的pubsub_channels字典里面，这个字典的键是某个被已订阅的频道，键的值是一致链表，链表里面记录了所有订阅这个频道的客户端：

```c
struct redisServer {
    // ...
    // 保存所有频道的订阅关系
    dict *pubsub_channels;
    // ...
}
```

![image-20210605202302200](https://gitee.com/tobing/imagebed/raw/master/image-20210605202302200.png)

上图展示了一个pubsub_channels里面包含了三个频道，client1、client2、client3订阅了“news.it”，client4订阅了“new.sport”，client5、client6订阅了“news.business”。

**订阅频道**

每当客户端执行SUSBSCRIBE命令订阅某个或某些频道时，服务器都会将客户端与被订阅的频道在publish_channels字典中进行关联。

根据频道是否已经有其他订阅者，关联操作可以分为两种情况：

+ 如果频道有其他订阅者，那么频道在pubsub_channels字典必然有相应的订阅者链表，这是仅需要把客户端添加到订阅者链表末尾。
+ 如果频道还没任何的订阅者，那么频道比如不存在于pubsub_channels字典，程序首先要在字典中创建一个键，并将这个键设置为空链表，再将这个客户端添加到链表上。

SUBSCRIBE命令实现伪代码：

```python
def subscribe(*all_input_channels) : 
    # 遍历输入的所有频道
    	# 如果channel不存在于pubsub_channels字典
        # 那么在字典中添加channel键，并设置它的值为空链表
        
        # 将订阅者添加到频道对应的链表末尾
```

**退订频道**

UNSUBSCRIBE命令的行为与SUBSCRIBE的行为正好相反，当一个客户端退订某个或某些频道时，服务器将从pubsub_channels中解除客户端与被退订频道之间的关联：

+ 程序根据被退订频道的名字，在pubsub_channels字典中找到频道对应的订阅者链表，然后从订阅者链表中删除退订客户端的信息
+ 如果删除退订客户端之后，频道的订阅者链表为空，则说明该频道无其他订阅者，程序将从pubsub_channels字典中将其删除

UNSUBSCRIBE命令实现伪代码：

```python
def unsubscribe(*all_input_channels) : 
    # 遍历要退订的所有频道
    	# 在订阅者链表中删除推动的客户端
        
        # 如果频道的订阅者链表为空，将频道从channels中删除
```

#### 模式的订阅与退订

与频道类似，服务器将所有模式的订阅关系都保存在服务器状态的pubsub_patterns属性中：

```c
struct redisServer {
    // ...
    // 保存所有频道的订阅关系
    list *pubsub_patterns;
    // ...
}
```

pubsub_patterns是一个链表，链表中的每个绩点都包含了一个pubsubPattern结构，这个结果的pattern属性记录了被订阅的模式，而client属性则记录了订阅模式的客户端：

```c
typedef struct pubsubPattern {
    // 订阅这者模式的客户端
    redisClient * client;
    // 被订阅的模式
    robj *pattern;
} pubsubPattern;
```

![image-20210605204247255](https://gitee.com/tobing/imagebed/raw/master/image-20210605204247255.png)

上图展示了三种订阅模式，分别被三个客户端订阅。

**订阅模式**

每当客户端执行PSUBSCRIBE命令订阅某个或某些模式时，服务器会对订阅的模式执行以下操作：

+ 新建一个pubsubPattern，将pattern设置为被订阅的模式，client属性设置为订阅模式的客户端；
+ 将pubsubPattern结构添加到pubsub_patterns链表的表尾。

PSUBSCRIBE命令的实现伪代码：

```python
def psubscribe(*all_input_patterns) :
    # 遍历输入的所有模式
    	# 创建新的pubsubPattern结构，记录被订阅的模式以及客户端
        # 将创建好的pubsubPattern追加到pubsub_patterns链表末尾
```

**退订模式**

PUNSUBSCRIBE命令是PSUBSCRIBE命令的反操作：每当一个客户端退订某个或某些模式的时候，服务器将在pubsub_patterns链表中查找并删除这些pattern属性为被退订模式，并且client属性为执行退订命令的客户端的

```python
def pubsubscribe(*all_input_patterns) :
    # 遍历所有要退订的模式
    	# 遍历pubsub_patterns链表中的所有pubsubPattern结构
        	# 如果当前客户端和pubsubPattern记录的客户端相同，并且退订模式也相同
            	# 将这个pubsubPattern记录删除
```

#### 发送消息

当一个Redis客户端执行`PUBLISH <channel> <message>`命令将消息发送给频道时，服务器需要执行以下两种动作：

1. 将message发送给channel频道的所有订阅者
2. 如果有一个或多个模式pattern与channel相匹配，将message发送给pattern模式的订阅者

**将消息发送给频道订阅者**

因为服务器状态中的pubsub_channels字典记录了所有频道的订阅关系，要将消息发送给channel频道的所有订阅者只需要在pubsub_channels字典中找到频道的订阅者链表，然后将消息发送给链表中的所有客户端即可。

**将消息发送给模式订阅者**

因为服务器状态中的pubsub_patterns链表记录了所有模式的订阅关系，执行要遍历pubsub_patterns链表将其中与channel频道匹配的模式找出，并将消息发送给订阅了这个模式的客户端即可。

#### 查看订阅信息

Redis2.8 新增加了 PUBSUB 命令，客户端可以通过这个命令查看频道或模式的相关信息，如某个频道有多少订阅者，某个模式目前有多少订阅者等等。

**PUBSUB CHANNELS**

`PUBSUB CHANNELS [pattern]`子命令用于返回服务器当前被订阅的频道，其中pattern可选：

+ 不指定pattern，命令返回服务器当前被订阅的所有频道
+ 指定pattern，命令返回服务器当前被订阅的频道中有按下与pattern品牌的频道

这个子命令通过遍历pubsub_channels字典的所有键，将符合条件所有频道返回。

**PUBSUB NUMSUB**

`PUBSUB SNUMSUB [channel-1 channel-2 ... channel-n]`子命令接受任意多个频道作为输入参数，并返回这些频道的订阅者数量

这个只需要根据输入的参数，去pubsub_channels中统计每个匹配键的对应链表长度即可

**PUBSUB NUMPAT**

`PUBSUB NUMPAT`子命令用于返回服务器当前被订阅模式的数量。

这命令通过返回pubsub_pattern链表长度来实现。

## 二、事务

#### 概述

Redis通过MULTI、EXEC、WATCH等命令来实现事务功能。事务提供一种将多个命令打包，然后一次性执行、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。

事务具有原子性、持久性、隔离性、一致性。

#### 事务的实现

一个事务从开始到结束会经历三个阶段：

1. 事务开始
2. 命令入队
3. 事务执行

**事务开始**

MULTI命令标记着事务的开始。MULIT命令可以将执行该命令的客户端从非事务状态切换值事务状态，这一切换是通过客户端状态的flags属性中打开REDIS_MULIT标识来完成。伪代码如下：

```python
def MULIT() :
    # 打开事务标识
    client.flag |= REDIS_MULTI
    # 返回OK回复
    replyOK()
```

**命令入队**

当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行。

当一个客户端切换到事务状态之后，服务器会根据客户端发来的不同命令执行不同操作。

+ 客户端发送的命令为EXEC、DISCARD、WATCH、MULTI四个命令的其中一个，那么服务器会立即执行这个命令
+ 反之，服务器不会执行这个命令，而是将这个命令放到一个事务队列中，然后向客户端返回QUEUE回复

**事务队列**

每个Redis客户端都会有自己的事务队列，这个事务状态保存了在客户端状态的mstate属性。

```c
typedef struct redisClient {
    // ...
    // 事务状态
    mulitState mstate;
    // ...
} redisClient;

typedef struct mulitState {
    // 事务队列
    mulitCmd *commands;
    // 已入队命令计数
    int count;
} mulitState;

typedef struct mulitCmd {
    // 参数
    robj **argv;
    // 参数数量
    int argc;
    // 命令指针
    struct redisCommand *cmd
}
```

+ 事务状态mulitState包含了一个事务队列，以及一个已入队命令的计数器。

+ 事务队列是一个mulitCmd类型数组，每个mulitCmd结构保存命令的参数，参数个数以及实现命令的函数

当开启一个事务，事务期间的命令会被添加到事务队列中去。

![image-20210606215148894](https://gitee.com/tobing/imagebed/raw/master/image-20210606215148894.png)

**执行事务**

当一个处于事务状态的客户端向服务器发送EXEC命令时，这个命令将立即被服务器执行。服务器会遍历整个客户端的事务队列，依次执行队列中的命令，最后将执行命令得到的结果全部返回给客户端。伪代码如下：

```python
def EXEC() : 
    # 创建空白回复队列
    
    # 遍历事务列表中的每个项，读取命令参数，参数个数，以及要执行的命令
    
    	# 执行命令，并取得命令返回值，将值追加到回复列表末尾
    
    # 移除 REDIS_MULIT标识，让客户端回到非事务状态
    # 清除客户端的事务状态，包含：1）清零入队命令计数器 2）释放事务队列
    
    # 将事务执行结果返回
```

#### WATCH命令实现

WATCH命令是一个乐观锁，可以在EXEC命令会执行前，监视任意数量的数据库键，并在执行EXEC命令时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。

**使用WATCH命令监视数据库键**

每个Redis数据库都保存一个watched_keys字典，这个字典的键是某个被WATCH命令监视的数据库键，而字典的值是一个链表，链表中记录了所有监视响应数据库键的客户端：

```c
typedef struct redisDb {
    // ...
    // 正在被WATCH命令监视的键
    dict *watched_keys;
    // ...
}
```

显然，通过watched_keys可以清晰的知道那些将都被那些客户端监视。

**监视机制的触发**

所有对数据库进行修改的命令，如SET、LPUSH、SADD、ZREM、DEL、FLUSHDB等等，在**执行后**都会调用touchWatchKey函数对watched_keys字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有那么touchWatchKey函数会将监视被修改键的客户端的REDIS_DIRTY_CAS标识打开，标识该客户端的事务安全性已经被破坏。伪代码如下：

```python
def touchWatchKey(db, key):
    # 如果键key存在于数据库的watched_keys字典中，那么什么指示有一个客户端监视这个key
    	# 遍历监视key的客户端
        	# 打开标识
```

**判断事务是否安全**

当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端是否打开的REDIS_DIRTY_CAS来决定是否执行事务：

+ 如果客户端的REDIS_DIRTY_CAS打开，说明客户端监视的键当中，至少有一个被修改过，这时事务不在安全，拒绝执行提交的事务。
+ 如果客户端的REDIS_DIRTY_CAS没打开 ，说明客户端监视的键当中，没有一个被修改过，这时事务安全，执行提交的事务。

**一个事务完整执行过程**

| 时间 |       客户端A       |       客户端B       |
| :--: | :-----------------: | :-----------------: |
|  1   |    WATCH "name"     |                     |
|  2   |        MULTI        |                     |
|  3   | SET "name" "tobing" |                     |
|  4   |                     | SET "name" "zenyet" |
|  5   |        EXEC         |                     |

1. 客户端A执行WATCH命令，将name添加到watched_keys字典中，并将客户端添加到对应链表之后
2. 客户端A开启事务，打开对应客户端的REDIS_MULTI标识
3. 客户端A将name设置为tobing
4. 客户端B将name设置为zenyet，设置去查看watched_keys字典，将name之后的所有客户端的REDIS_DIRTY_CAS打开，其中包含了客户端A
5. 客户端A执行EXEC命令，发现其中当前客户端的REDIS_DIRTY_CAS被打开，说明事务期间有值被修改，拒绝事务

#### 事务的ACID性质

在Redis中，事务总是具有ACI特性，如果Redis运行在某种特定持久化模式，事务也具有持久性。

**原子性**

事务原子性指的是，将事务中的多个操作看做一个整体，要么全部成功，要么全部失败。

Reids而言，就是要么全部执行MULIT和EXEC之间的命令，要么全都不执行MULIT和EXEC之间的命令。

Redis的事务与传统的关系数据库的事务有所区别，Redis不支持事务回滚机制，即使事务队列中的某个命令在执行期间出新了错误，整个事务也会执行下去，直到将事务队列中的所有命令都执行完毕。

Redis作者任认为不支持回滚是因为这种复杂功能与Redis追求的简单高效设计不符，而且他任务执行时错误通常是开发环境，很少在实际的生产环境中出现，因此没必要添加回滚。

**一致性**

事务具有一致性是指，数据库在执行事务前是一致的，那么事务执行之后，无论是否成功，数据库也应该是一致的。

 “一致”指的是数据符合数据库本身的定义和要求，没有包含非法或无效的错误数据。Redis通过错误检测和简单的设计来保证事务一致性。

Redis通过谨慎的错误检测和简单的设计来保证事务一致性，主要通过以下三个方面。

1. 入队错误：如果一个事务在入队命令的过程中，出现了命令不存在，或者命令的格式不正确等情况，Redis将会拒绝执行这个事务。

2. 执行错误：除了入队时发生错误，事务可能在执行过程种发生错误。

   1. 执行过程中发生的错误都是一些不能在入队时被服务器发现的错误，这些错误之后在命令执行时被触发
   2. 即使在事务的执行过程中发现了错误，服务器也不会中断事务的执行，它会继续执行事务中余下的其他命令，并且已执行的命令不会被出错的命令影响。

   对数据库键执行了错误类型的操作是事务执行期间最常见的错误之一。

3. 服务器停机：Redis服务器在执行事务的过程中停机，那么根据服务器使用的持久化模式，可以有一下情况：

   1. 如果服务器运行在持久化的内存模式下，那么重启之后的数据库将是空白，因此数据总是一致性的
   2. 如果服务器运行在RDB模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的RDB文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可用的RDB文件，那么重启之后的数据库将是空白的，而空白数据库总是一致的
   3. 如果服务器运行在AOF模式下，那么在事务中途停机不会导致不一致性，因为服务器可以根据现有的AOF文件来恢复数据，从而将数据库还原到一个一致的状态。如果找不到可供使用的AOF文件，那么重启之后的数据库将是空白的，而空白的数据库总是一致的

**隔离性**

事务隔离性指，即使数据库中有多个事务并发执行，各个事务之间页不会互相影响，并且在并发状态下执行的事务和串行执行事务产生的结果完全相同。

Redis使用单线程方式来执行事务，并且服务器包含智能，在执行事务期间不会对事务中断，因此Redis的事务总是以串行执行，因此具有隔离性。

**持久性**

事务持久性指，当一个事务执行完毕，执行这个事务所得到的结果已经被保存到永久性储存介质中，即使服务器在事务执行完毕之后停机，执行事务得到的结果也不会丢失。

Redis的事务不过是简单的用队列包裹起了一组Redis命令，Redis并没有为事务提供任何额外的持久化功能，所以Redis事务的持久性有Reids使用的持久化模式决定：

+ 当服务器在无持久化的的内存模式下运行，事务不具持久性，一旦服务器停机，包括事务数据在内的所有服务器数据都会丢失；
+ 当服务器在RDB持久化模式下运行时，服务器只会在特定的保存条件被满足时，才会执行BGSAVE命令，对数据库进行保存操作，并且异步执行BGSAVE不能保证事务数据被第一时间保存在硬盘里面，一次RDB持久化模式下的事务也不具有持久性。
+ 当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，程序总会在执行命令之后调用同步函数，将命令数据真正的保存在硬盘中，因此这种配置项的事务就有持久性。
+ 当服务器运行在AOF持久化模式下，并且appendfsync选项的值为no或everysec时，并不能100%保证事务提交就能够把数据提交，因此不能保证事务就要持久性。

在开启了持久化模式下，在事务最后加上SAVE命令总可以保证事务的持久性。但这种方式效率太低，一般不具有实用性。

#### 总结

+ 事务提供一种将多个命令打包，然后一次性、有序的执行的机制。
+ 多个命令会被入队到事务队列中，然后按先进先出的顺序执行。
+ 事务执行过程中不会被中断，当事务队列中的所有命令都被执行完毕，事务才会结束。
+ 带有WATCH命令的事务会将客户端和监视的键在数据库的watched_keys字典进行关联，当键被修改时，程序会将所有监视被过秀修改键的客户端的REDIS_DIRTY_CAS标志打开。
+  只有在客户端的REDIS_DIRTY_CAS标志未被打开，服务器才会执行客户端提交的事务，否则，服务器将拒绝客户端提交的事务。
+ Redis的事务总是就有ACID中的原子性、隔离性、一致性，当服务器运行在AOF下的always，事务具有持久性。



## 三、二进制位数组

#### 概述

Redis提供了SETBIT、GETBIT、BITCOUNT、BITOP四个命令用于处理二进制位数组。

+ SETBIT，用于为位数组指定偏移上的二进制位设置值，位数组的偏移量从0开始计算，值可以是0或1；
+ GETBIT，用于获取为数组指定偏移量上的二进制位的值；
+ BITCOUNT，用于统计为数组中，值为1的二进制位的数量；
+ BITOP既可以对多个位数组进行按位与、按位或、按位异或运行，也可以对给定的位数组进行取反运算。

```bash
SETBIT bit 0 1    	# 0000 0001
SETBIT bit 3 1		# 0000 1001
SETBIT bit 0 0 		# 0000 1000

GETBIT bit 0 ==> 0
GETBIT bit 3 ==> 1

BITCOUNT bit ==> 1

SETBIT x 0 1
SETBIT x 1 1
SETBIT x 3 1		# 0000 1011

SETBIT y 1 1
SETBIT y 2 1		# 0000 0110

SETBIT z 0 1		
SETBIT z 2 1		# 0000 0101

BITOP AND andRes x y z	# 0000 0000
BITOP OR orREs x y z	# 0000 1111
BITOP XOR xorRes x yz	# 0000 1000
```

#### 位数组表示

Redis使用字符串表示位数组，因为字符串对象使用SDS数据结构是二进制安全的，因此保存程序可以使用SDS结构来保存数组，并使用SDS结构的操作函数来处理位数组。

![image-20210607134711307](https://gitee.com/tobing/imagebed/raw/master/image-20210607134711307.png)

+ redisObject.type=REDIS_STRING，表明类型为字符串对象
+ redisObject.ptr.sdshdr.len=1，表示SDS保存了一个一字节的位数组
+ buf数组中的buf[0]字节保存了一字节长的位数组
+ buf数组中的buf[1]字节保存了SDS程序自动追加到值末尾的空字符"\0"

需要注意的是，buf数组保存的位数组的顺序与平时书写的顺序是相反的，下面展示了保存1010 0101 1100 0011 0000 1111的位数组

![image-20210607141315288](https://gitee.com/tobing/imagebed/raw/master/image-20210607141315288.png)

#### GETBIT命令实现

GETBIT命令用于返回位数组中的bitarry在offset偏移量上的二进制位的值：`GETBIT <bitarry> <offset>`，命令的执行过程如下：

1. 计算byte=[offset/8]，byte记录了offset偏移量指定的二进制数组保存咋位数组的哪一个字节；
2. 计算bit=(offset mod 8) +1，bit记录了offset偏移量指定的二进制位是byte字节的第几个二进制位；
3. 根据byte和bit值，在位数组中定位offset偏移来那个指定的二进制位，并返回这个位的值。

GETBIT命令可以在常数时间内执行完毕，命令时间复杂度为O(1)。

#### SETBIT命令实现

SETBIT命令用于将位数组bitarray在offset偏移量上的二进制位设置为value，并向客户的返回二进制位被设置之前的旧值：`SETBIT <bitarray> <offset> <value>`，命令执行过程如下：

1. 计算len=[offset/8] + 1，len记录了保存offset偏移量指定的二进制位至少需要多少字节。
2. 检查bitarray键保存到位数组的长度是否小于len，是则将SDS的长度控制为len字节，并将所有新扩展的空间的二进制位设置为0。
3. 计算byte=[offset/8]，byte值记录了offset偏移量指定的二进制位保存在位数组的哪个字节。
4. 计算bit=(offset mod 8) + 1，bit值记录了offset偏移量指定的二进制位是byte字节的第几个二进制位。
5. 根据byte指定和bit值，在bitarry键保存的位数组中定位offset偏移量指向的二进制位，首先指定二进制位现在值保存在oldvalue变量，然后给将新值vlaue设置为这个二进制位。
6. 先客户端返回oldvalue变量的值

SETBIT命令可以在常数时间内执行完毕，命令时间复杂度为O(1)。

需要注意的是，由于buf数组采用逆序保存位数组，在动态扩展的时候，前面部分不需要要修改。如下图保存了1011 0010 0000 1000 在扩展的时候，在后面直接条件若干位0即可，不会对原有的影响。这样就不会产生移位操作。

![image-20210607140920083](https://gitee.com/tobing/imagebed/raw/master/image-20210607140920083.png)

#### BITCOUNT命令实现

BITCOUNT命令用于统计给定为数组中，值为1的二进制位的数量。BITCOUNT命令实现并不困难的，但是要高效实现需要技巧。

REDIS中采用了查表和variable-precisionSWAR两种算法：

+ 查表算法使用键长为8位的表，表中记录了从0000 0000 到 1111 1111 在内的所有二进制位的汉明重量。
+ 至于variable-precisionSWAR算法方面，BITCOUNT命令在每次循环中载入128个二进制位，然后调用四次32位variable-precisionSWAR算来计算128二进制位的汉明重量。

执行BITCOUNT命令是时，程序根据未处理的二进制位数量来决定使用哪种算法：

+ 未处理的二进制位数量大于等于128位，采用variable-precisionSWAR算法计算二进制位的汉明重量
+ 未处理的二进制位数量小于128位，使用查表算法计算二进制位的汉明重量

**二进制位统计法-查表算法**

对于一个有限集合，集合元素的排序方式有限。对于一个长度有限的位数组来说，它能表示的二进制排序也是有限的。

根据上述原理，可以创建一个表，表的键为某种排序的位数组，而表的值是相应位数组中，值为1的二进制位的数量。如下表：

| 键（位数组） | 值（值为1的位数量） |
| :----------: | :-----------------: |
|  0000 0000   |          0          |
|  0000 0001   |          1          |
|  0000 0010   |          1          |
|     ...      |         ...         |
|  1111 1110   |          7          |
|  1111 1111   |          8          |

通过一个键为8位的表，可以比遍历快8倍；如果键为16位，可以比遍历快16倍。看起来似乎表足够大，统计工作就可以完成。但事实并不这么简单，查表法实际效果会受到内存和缓存两方面因素限制：

+ 因为查表法是典型的用空间换时间策略，解决的时间越多，花费的空间越大；
+ 处理内存大小的问题，查表发的效果还会受到CPU缓存的限制：对于固定大小的CPU缓存而言，创建的表格越大，CPU能缓存的内容栈整个表格的比例越小，查表时出现缓存不命中的情况就会越高，缓存的换入和换出操作越频繁，最终影响查询效率。

基于上面两点限制，往往只能考虑创建8位会16位的表。但这两种表代理的效率提升远远不够，还需要引入variable-precisionSWAR算法。

**variable-precisionSWAR算法**

BITCOUNT命令解决的问题，统计一个为数组中的非0二进制位的数量，在数学上称为“计算汉明重量”。

因为计算汉明重量经常被用于信息论，编码理论和密码学，因此研究人员针对计算汉明重量开发了很多种不同的算法，一些处理器甚至自带计算汉明重量的指令，而对于不具备特殊指令的普通处理器，效率最高的通用算法是“variable-precisionSWAR算法”，该算法通过一些了位移和位运算，可以在常数时间内计算多个字节的汉明重量，并且不需要额外的内存。

```c
uint32_t swar(uint32_t i){
    i = (i & 0x55555555) + ((i>>1) & 0x55555555);  // 步骤1
    i = (i & 0x33333333) + ((i>>2) & 0x33333333);  // 步骤2
    i = (i & 0x0F0F0F0F) + ((i>>4) & 0x0F0F0F0F);  // 步骤3
    i = (i * 0x01010101) >> 24;                    // 步骤4
    return i;
}
```

下面是调用swar函数的执行步骤：

+ 步骤1计算出值i的二进制表示可以按每两个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。
+ 步骤2计算出值i的二进制表示可以按没四个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。
+ 步骤3计算出值i的二进制表示可以按没八个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。
+ 步骤4的i*0x01010101语句计算出bitarray的汉明重量并记录在二进制位的最高八位，而>>24语句通过右移运算，将bitarray的汉明重量一定到最低八位，得到结构就是bitarray的汉明重量。

下面以0x12345678为例

![img](https://gitee.com/tobing/imagebed/raw/master/2020-08-01-15962704953270.jpg)

![img](https://gitee.com/tobing/imagebed/raw/master/2020-08-01-15962705553725.jpg)

> 图片来源：http://ponder.work/2020/08/01/variable-precision-SWAR-algorithm/，侵权必删

通过32为的二进制汉明重量计算函数，要比8位的查表法快4倍，同时不需额外的内存。

#### BITOP命令实现

 C语言直接支持对字节执行逻辑与（&）、逻辑或（|）、逻辑疑惑（^）和逻辑非（~）操作，所以BITOP命令的AND、OR、XOR和NOT四个操作都是直接基于这些逻辑操作实现的：

+ 在执行BITOP AND命令时，程序用&操作符计算出所有输入二进制位的逻辑与结果，然后保存在指定的键上面；
+ 在执行BITOP OR命令时，程序用|操作符计算出所有输入二进制位的逻辑与结果，然后保存在指定的键上面；
+ 在执行BITOP XOR命令时，程序用^操作符计算出所有输入二进制位的逻辑与结果，然后保存在指定的键上面；
+ 在执行BITOP NOT命令时，程序用~操作符计算出所有输入二进制位的逻辑与结果，然后保存在指定的键上面；

