# Redis设计与实现-数据结构与对象

## 一、简单动态字符串（SDS）

#### 概述

Redis中的字符串与C语言的字符串并不相同，而是自己构建了名为简单动态字符串（Simple Dynamic String，SDS）的抽象类型。

```bash
SET msg "hello wolrd"
```

执行上面命令时，会创建新的键值对，其中：

+ 键值对的键是一个字符串对象，底层是保存了“msg”的SDS；
+ 键值对的值也是一个字符串对象，底层是保存了“hello world“的SDS。

除此之外，SDS还被用作缓冲区（buffer）：AOF模块中的AOF缓冲区，客户端状态中的输入缓冲区。

#### SDS定义

```c
struct sdshdr {
    // 记录buf数组中已使用的字节数量，等于SDS保存字符串的长度
    int len;
    // 记录buf数组中未使用的字节数量
    int free;
    // 字节数组，用于保存字符串
    int buf[]
}
```

![image-20210524223843654](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210524223843654.png)

在上图的SDS中：

+ free=0，表明SDS没有分配未使用空间；
+ len=5，表明这个SDS保存一个5字节长的字符串；
+ buf是有个char类型数组，分别保存了“Redis”和一个“\0”空字符。

SDS遵循C语言规范，保存空字符串的一个字节不会计算到SDS的len属性中。

#### SDS与C字符串的区别

1. **O(1)复杂度获取字符串长度**：C没有保存字符串长度，需要遍历统计，SDS使用len保存字符串长度。
2. **杜绝缓冲区溢出**：C不记录长度，使用strcat函数假设空间足够，容易导致缓冲区溢出。SDS从API上杜绝。
3. **减少修改字符串带来的内存重分配次数**：C不记录长度，底层字符数组与字符串占用相等，而SDS采用两种策略应对。
   1. **空间预分配**：SDS的API修改SDS时，且需要进行扩展时，不仅会为SDS分配修改必须的空间，还会为SDS分配额外的未使用空间。（<1M时，分配和len属性同样大小的未使用空间，此时free和len长度一致；>=1M时，分配1MB未使用空间）
   2. **惰性空间释放**：SDS的API需要缩短SDS保存字符串时，程序不会立即回收，而是使用free属性将这些字节将将其保存，等待将来使用。
4. **二进制安全**：C中的字符不允许存储特殊字符，如空字符，否则会被认为时字符串结尾。SDS的API会以处理二进制的方式来处理这些数据。
5. **兼容部分C字符串函数**：SDS遵循C语言字符串一空字符结尾的惯例，这就可以使得SDS可以重用一部分C语言定义的库函数。

| C字符串                              | SDS                                      |
| ------------------------------------ | ---------------------------------------- |
| 获取字符串长度复杂度为O(n)           | 获取字符串长度复杂度为O(1)               |
| API是不安全的，可能造成缓冲区溢出    | API是安全的，不会造成缓冲区溢出          |
| 修改字符串长度N次必须重新分配N次内存 | 修改字符串长度N次最多需要重新分配N次内存 |
| 只能保存文本数据                     | 可以保存文本或者二进制数据               |
| 可以使用所有<string.h>库中的函数     | 可以使用部分<string.h>库中的函数         |

#### SDS的常用API

省略

## 二、链表（list）

#### 概述

链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点灵活调整链表长度。

链表在Redis运用广泛，如列表键底层实现就是链表。当一个列表键包含了数量比较多的元素，有或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。

除此之外，发布于订阅、慢查询、监视器等功能也用到了链表，Redis服务器本身还使用链表来保存多个客户端的状态信息，以及使用链表来构建客户端输出缓冲区。

#### 链表定义

链表每个节点使用listNode来表示

```c
typedef struct listNode {
    // 前置节点
    struct listNode *prev;
    // 后置节点
    struct listNode *next;
    // 节点的值
    void *value;
}
```

![image-20210525211513661](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210525211513661.png)

多个listNode形成链表，通过list来管理

```c
typedef struct list {
    // 表头节点
    listNode *head;
    // 表尾节点
    listNode *tail;
    // 链表包含的节点数
    unsigned long len;
    // 节点值复制函数
    void *(*dup)(void *ptr);
    // 节点值释放函数
    void *(*free)(void *ptr);
    // 节点值对比函数
    int (*match)(void *ptr,void *key);
}
```

![image-20210525211851539](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210525211851539.png)

#### 链表特点

Redis的链表实现特征总结如下：

+ **双端**：链表节点带prev和next指针，可以获取节点的前置和后置节点。
+ **无环**：表头的prev指针和表为的next都为null，对链表的访问以null为结尾。
+ **带表头和表尾元素**：通过list结构的head和list指针获取表头节点和表尾元素，时间复杂度为O(1)。
+ **带链表长度计数器**：通过维护len来记录链表持有的节点。
+ **多态**：链表使用void*指针来保存节点值，并且可以通过list结果的dup、free、match三个属性为节点设置特定类型函数，因此链表可以保存不同类型元素。

## 三、字典（dict）

#### 概述

字典，又称为符号表、关联数组或映射，是一种用来保存键值对的抽象数据结构。

字典中一个键可以和一个值进行关联，这些关联的键和值就称为键值对。字典中的每个键都是唯一的，程序可以在字典中根据键查找与之关联的值，或者通过键来操作值。

Redis使用的C语言没有内置这种数据结构，因此Redis构建了自己的字典实现。

字典在Redis中应用广泛，如Redis的数据库就是使用字典作为底层实现，对数据库的增删改查操作也是构建在对字典的操作之上。

除此之外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，或者键值对中的元素是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。

#### 字典实现

**1、哈希表**

Redis字典中使用的哈希表dictht定义如下：

```c
typedef struct dictht {
    // 哈希表数组
    dictEntry **table;
    // 哈希表大小
    unsigned long size;
    // 哈小表大小掩码，用于计算索引值
    unsigned long sizemask;
    // 该哈希表已有的节点数量
    unsigned long used;
} dictht;
```

+ table是一个数组，数组每个元素执行一个dictEntry结构的指针，每个dictEntry结构保存着一个键值对；
+ size属性记录了哈希表的大小，即table数组的大小；
+ used属性记录了哈希表目前已有的节点数量；
+ sizemask属性的值总是等于size-1，这个属性结合哈希值一起决定一个键应该被放到table数组的哪个索引上。

![image-20210527205747829](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210527205747829.png)

**2、哈希节点**

哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对

```c
typedef struct dictEntry {
    // 键
    void *key;
   	// 值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;
    // 执行下一个哈表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```

+ key属性保存键值对中的键；
+ v属性保存键值对中的值，值可以一个指针，或一个uint64整数，有或者是一个int64_t整数;
+ next属性是执行另一个哈希表节点的指针，Redis通过链地址法来解决哈希冲突。

![image-20210527210335351](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210527210335351.png)

上图中可以看出，Redis中字典通过哈希表实现，一个哈希表中（dictht）可以有多个哈希节点，而每个哈希节点（dictEntry）保存了字典的一个键值对。

**3、字典**

Redis中的字典通过dict结构表示：

```c
typedef struct dict {
    // 类型特定函数
    dictType *type;
    // 私有数据
    void *privdata;
    // 哈希表
    dictht ht[2];
    // rehash索引
    // 当rehash不再进行时，值为-1
    int rehashidx;
} dict;
```

+ type和privdata属性是针对不同类型的键值对，为创建多态字典而设置；
+ type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数；
+ privdata属性保存了需要特定传给那些类型特定函数的可选参数；
+ ht属性是一个包含两个项的数组，数组的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会对ht[0]哈希表进行rehash是使用；
+ rehashindx属性记录了rehash的精度，如果当前没有进行rehash，值为-1。

下面展示了dictType结构表示：

```c
typedef struct dictType {
    // 计算哈希值的函数
    unsigned int (*hashFunciton)(const void *key);
    // 复制键的函数
    void *(*keyDup)(void *privdata,const void *key);
    // 复制值的函数
    void *(*valDup)(void *privdata,const void *obj);
    // 对比键的函数
    int (*keyCompare)(void *privdata,const void *key1,const void *key2);
    // 销毁键的函数
    void (*keyDestructor)(void *privdata,const void *key);
    // 销毁值的函数
    void (*keyDestructor)(void *privdata,const void *obj);
} dictType;
```

下面展示了普通状态下的字典

![image-20210527211852025](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210527211852025.png)

#### 哈希算法

当需要将一个新的键值对插入到字典中时，需要先根据键值对的键计算出**哈希值和索引值**，然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

Redis计算哈希值和索引值的方法如下：

```c
// 使用字典设置的哈希函数，计算键key的哈希值
hash = dict->type->hashFunction(key);
// 使用哈希表的sizemask属性和哈希值，计算出索引值
// 根据情况不同，ht[x]可以是ht[0]或者ht[1]
index = hash & dict->ht[x].sizemask;
```

![image-20210527212951349](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210527212951349.png)

当需要将k0，v0插入到上面的哈希表中时，会执行下面语句：

```c
// 使用字典设置的哈希函数，计算键key的哈希值
hash = dict->type->hashFunction(k0);	// 假设运算得到为8
// 使用哈希表的sizemask属性和哈希值，计算出索引值
// 根据情况不同，ht[x]可以是ht[0]或者ht[1]
index = hash & dict->ht[0].sizemask; 	// = 8 & 3 = 0
```

从上面可以发现，运算得到的索引值为0，因此k0，v0会被放置到哈希表数组的索引0位置：

![image-20210527214751407](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210527214751407.png)

当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用[MurmurHash2](https://en.wikipedia.org/wiki/MurmurHash)算法来计算键的哈希值。

**MurmurHash**是一个中非加密哈希函数，使用于普通场景下的哈希查找。在2008年被 Austin Appleby 发明，当前由Github托管。MurmurHash优点在于，即使输入的键有规律，算法仍能给出一个很好的随机分布性，而且算法的计算速度也非常快。

#### 解决哈希冲突

当两个或两个以上数量的键被分配到哈希表数组的同一个索引上时，称这些键发生了冲突（collision）。

Redis通过链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点通过next指针构成一个单向链表，被分配到同一个索引上的多个节点通过单向链表连接，进而解决键哈希冲突的问题。

考虑到速度问题，程序总是将新节点添加到链表的表头位置，排在其他节点前面。

![image-20210527220033152](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210527220033152.png)

如给上面的哈希表中添加一个新键值对k2，v2，且经过计算k2的索引位于下标3的位置，因此插入时会插入到k1，v1前面。

![image-20210527220239030](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210527220239030.png)

#### rehash

随着操作不断执行，哈希表保存的键值对会逐渐增加或减少，为了让哈希表的负载因子（load factor）维持在一个合理的范围，哈希表保存的键值数量太多或太少时，需要对哈希表的大小进行相应的扩展或收缩。

哈希表的扩展或收缩需要通过rehash（重新散列）来完成，主要步骤如下：

1. 为字典ht[1]哈希表分配空间，这个**哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量**。
   + 当执行的是扩展操作，ht[1]大小为第一个大于等于ht[0].used*2的**2的n次方幂**
   + 当执行的是收缩操作，ht[1]大小为第一个大于等于ht[0].used的**2的n次方幂**（始终保证哈希表大小为2的n次幂）
2. 将保持在ht[0]中的所有键值对rehash到ht[1]上面：rehash是指重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表指定的位置上。
3. 当ht[0]包含的所有键值对都迁移到ht[1]之后，释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建空白哈希表，为下次rehash准备。

![image-20210527221333060](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210527221333060.png)

如上图，需要对ht[0]进行扩展操作，将会执行以下步骤：

1. ht[0].used=4，需要扩展，4*2=8，8刚好为2的3次幂，因此ht[1]的大小将会被设置为8；
2. 随后将ht[0]中所有的键值对都rehash到ht[1]中；
3. 最后ht[0]，将ht[1]设置为ht[0]，并为ht[1]分配空白哈希表。

下图展示了将ht[0]中所有数据迁移到ht[1]中

![image-20210527221622548](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210527221622548.png)

#### 哈希表的扩展与收缩

当满足以下条件时，系统将会自动开始对哈希表进行扩展操作：

1. 服务器目前没有在执行的**bgsave命令**或者**bgrewriteaof命令**，并且哈希表的负载因子大于等于1
2. 服务器目前正在执行的**bgsave命令**或者**bgrewriteaof命令**，并且哈希表的负载因子大于等于5

负载因子可以通过以下公式计算：

```c
load_factaor = ht[0].used / ht[0].size
```

从上面可以看到，根据服务器目前是否正在执行的**bgsave命令**或者**bgrewriteaof命令**，负载因子并不相同。

在执行**bgsave命令**或者**bgrewriteaof命令**过程中，Redis需要创建当前服务器的子进程，而大多数服务器系统采用写时复制计算优化子进程的使用效率，因此在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能避免在子进程存在期间举行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度节约内存。

另外当负载因子小于0.1，程序自定开始对哈希表执行收缩操作。

#### 渐进式rehash

考虑到服务器性能的影响，在收缩或扩展哈希表时，将ht[0]的数据复制到ht[1]这个动作并不是一次性完成的，是分多次，渐进式完成的，详细步骤如下：

1. 为ht[1]分配空间，字典同时持有ht[0]和ht[1]两个哈希表；
2. 在字典中维持一个索引计数器变量rehashidx，将它设置为0，表示rehash工作正式开始
3. 在rehash进行期间，每次对字典执行添加、删除、查找或更新操作时，程序除了完成指定操作，还会顺带将会ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当一次rehash工作完成，rehashidx属性值增一
4. 随着字典操作不断执行，最终某个时间点上，ht[0]的所有键值都会被rehash到ht[1]，这是程序将rehashidx设置为-1，表示rehash操作已经完成。

上面过程体现了分而治之、均摊的思想，可以用于避免集中式rehash带来的庞大计算量。

#### 渐进式rehash执行期间的哈希表操作

在进行渐进式rehash过程中，字典会同时使用ht[0]和ht[1]两个哈希表，因此在rehash期间，字典的删除、查找、更新等操作会在两个哈希表上进行。如果要在字典中查找一个键时，会先到ht[0]中查找，没有则会到ht[1]中查找。

另外，渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]中，ht[0]不再进行任何添加按操作，这一措施保证ht[0]包含的键值对数量只减不增，而随着rehash操作的进行而最终变为空表。

#### 总结

从上面的篇幅可以指定字典在哈希表中的地位。

字典被Redis用于实现各种功能，包括数据化和哈希键。

Redis字典底层通过哈希键实现，每个字典有两个哈希表，一个用于平时使用，一个用于执行rehash时使用。

哈希表使用链地址法来解决哈希冲突问题，被分配到同一个哈希桶的节点会以单链表形式连接起来。

哈希表进行rehash是渐进式的，而不是一次性的。

## 四、跳跃表（skiplist）

#### 概述

跳跃表（skiplist）是一种**有序的数据结构**，通过维持多个指向其他节点的指针，从而达到快速访问节点的目的。

跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。大部分情况下，跳跃表的效率和平衡树媲美，而且跳表实现比平衡树简单。

Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量较多，又或者有序集合中元素的成员是比较长的字符串时，Redis会使用跳跃表作为有序集合键的底层实现。除此之外，跳表还被使用在集群节点中用作内部数据结构。

#### 跳跃表的实现

Redis中跳跃表主要有zskiplistNode和zskiplist两个结构定义，其中zskiplistNode用于表示跳跃表节点，而zskiplist用于保存跳跃表节点的相关信息。

![image-20210528092838914](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210528092838914.png)

上图展示了跳跃表的结构，最左边是zskiplist结构，包含如下属性：

+ header：指向跳跃表的表头节点
+ tail：指向跳跃表的表尾节点
+ level：记录当前跳跃表层数最大的节点层数（表头层数不计算在内）
+ length：记录跳跃表的长度，跳跃表目前包含节点的数量（表头节点不计）

位于zskiplist结构右方的是四个zskiplistNode，该结构包含以下属性：

+ level：层，节点中用L1、L2、L3等字样标记节点的各个层，L1表示第一层，L2表示第二层，以此类推。每个层都带有两个属性：前进指针和跨度。
  + 前进指针用于访问位于表尾方向的其他节点
  + 跨度记录了前进指针所指向节点和当前节点的距离
  + 当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行
+ backward：后退指针，节点中用BW字样标记节点后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾先表头遍历时使用。
+ score：分值，各个节点中的1.0、2.0是节点所保存的分值。跳跃表中节点按各自保存的分值从小到大排列。
+ obj：成员对象，各个节点的o1、o2是节点所保存的成员对象。

需要注意的是，表头节点和其他节点构造不一样，表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性不会被用到，因此在图中省略了这些部分。

#### 跳跃表节点

跳跃表节点的实现由zskiplistNode结构定义：

```c
typedef struct zskiplistNode {
    // 层
    struct zskiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    } level[];
    // 后退指针
    struct zklistNode *backward;
    // 分值
    double score;
    //成员对象
    robj *obj;
} zskiplistNode;
```

+ **层**

  + 跳表中的level数组可以包含多个元素，每个元素包含一个指向其他节点的指针，程序可以通过这些层来加速访问其他节点的速度，一般来说，层数越多，访问其他节点的速度越快。
  + 每次创建一个跳跃表节点的时候，程序根据幂次定律（越大的数出现的概率越小）随机产生一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”

+ **前进指针：**

  + 每层都有指向表尾方向的前进指针，用于从表头向表尾方向访问节点。
+ **跨度：**
+ 层的跨度用来记录两个节点之间的距离
    + 两个节点之间跨度很大，它们相距越远
    + 指向null的所有前进指针的跨度为0
  + 跨度是用来计算排位（rank）：在查找某个节点的过程中，将沿途访问过的所有层的跨度累计，得到的结果就是目标节点在跳跃表的排位。
+ **后退指针：**

  + 用于表尾向表头方向访问节点，跟可以一次跳过多个节点的前进指针不同，每个节点只有一个后退指针，每次只能后退到前一个。
+ **分值和成员：**
  + 节点的分值（score属性），一个double类型浮点数，跳跃表中的所有节点都按照分支从小到大排序
  + 节点的成员对象（obj属性），一个指针，指向一个字符串对象，而每个字符串对象则保存一个SDS值。
  + 同一个跳跃表中，各个节点保存的成员对象必须是唯一，但多个节点保存的分值可以相同。
  + 分值相同的节点按照成员对象在字典序中的大小进行排序，成员对象小的节点会排在前面（靠近表头）。

#### 跳跃表

跳跃表有多个跳跃表节点构成，可以通过zskiplist来管理这些节点。

```c
typedef struct zskiplist {
    // 表头和表尾
    struct zskiplistNode *header, *tail;
    // 表中节点的数量
    unsigned long length;
    // 表中层数最大的节点的层数
    int level;
}
```

![image-20210528124634425](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210528124634425.png)

+ header和tail，分别执行表头和表尾，可以通过O(1)时间复杂度访问这两个元素
+ length，记录节点数量

## 五、整数集合（inset）

#### 概述

整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis会使用整数集合作为集合键的底层实现。

#### 整数集合实现

整数集合时Redis用于保存整数值的ADT，可以保存int16_t、int32_t、int64_t的整数值，并且保证集合中不会出现重复元素。

inset结构如下：

```c
typedef struct intset {
    // 编码方式
    uint32_t encoding;
    // 集合包含的元素数量
    uint32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;
```

+ contents数组是集合的底层实现，整数集合的每个元素都是contents数组的每个数组项，各个项在数组中按值的大小从小到大有序排列，且数组中不会出现重复项。
+ length记录了整数集合包含的元素数量，即contents数组的长度。
+ 虽然contents声明为int8_t，但实际上储存取决于encoding的值
  + encoding=INTSET_ENC_INT16，contents为int16_t类型的数组；（-32768，32767）
  + encoding=INTSET_ENC_INT32，contents为int32_t类型的数组；（-2147483648，2147483647）
  + encoding=INTSET_ENC_INT64，contents为int64_t类型的数组；（\- 9223372036854775808，9223372036854775807）

![image-20210528130231842](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210528130231842.png)

上图中，encoding=INTSET_ENC_INT16，contents保存的都是int16_t的内容，长度为5，并且数组内容从小到大排序，一共占用5*16=80位。

#### 升级

每当要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级，然后才能将新元素添加到整数集合中。

1. 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
2. 将底层数据现有的所有元素转换为与新元素相同的类型，并将类型转换后的元素放到正确的位置上，而且在放置元素的过程中，需要维持底层数组的有序性质不变。
3. 将新元素添加到底层数组中。

如现有一个encoding=INTSET_ENC_INT16编码的整数集合，集合中包含是三个int16_t类型的元素。假如要将uint_t的65535添加到整数集合里面，因为65535比当前整数集合中的所有元素都要唱，所以在将65535添加到整数集合前，需要对整数集合进行升级。

1. 根据新类型长度，以及集合元素个数，对底层数组进行空间重新分配；32*(3+1)=128bit。
2. 分配好空间之后，就需要将原来的三个元素转换为int32_t类型，并将装换后的元素放置到正确的位置，在放置过程中保持底层数组有序性不变。
3. 最后，程序会将整数集合的encoding属性从INTSET_ENC_INT16改为INTSET_ENC_INT32，并将length从3改为4。

从上面的分析可以发现，每次向整数集合中添加新元素都可能引起升级，而每次升级都需要对底层数据已有的所有元素进行类型转换，所以先整数集合添加新元素的时间复杂度为O(N)。

需要注意的是，升级之后新元素的摆放位置：

因为引发升级的新元素的长度总是要比整数集合现有的所有数据要大，因此这个新元素的值要么“大于”所有现有元素，要么就“小于”所有现有元素。

+ 新元素“小于”所有现有元素的情况下，新元素会被放置到底层数组的最开头位置【负数】
+ 新元素“大于”所有现有元素的情况下，新元素会被放置到底层数组的最末尾位置【正数】

通过升级策略，整数集合具有两个好处，一是提高整数集合的灵活性，另一个是尽可能地节省内存。

+ 灵活性：可以随意将int16_t、int32_t或者int64_t类型的数据添加到集合中，而不用担心出现类型错误
+ 节约内存：如果不考虑内存占用，可以直接用int64_t保存所有的数据，但是这不符合Redis的节约风格，因此采用上面方式

#### 降级

整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级的状态。

比如一开始集合元素为{5,10,12,65535，4294967295}，显然最长数为4294967295，因此数组是INTSET_ENC_INT64类型；

此时如果删除数组中的4294967295，数组中最长元素为INTSET_ENC_INT32，但底层数组仍然是INTSET_ENC_INT64类型。

## 六、压缩列表（ziplist）

#### 概述

压缩列表是列表键和哈希键的底层实现之一。

当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

当一个哈希键只包含少量键值对，并且每个键值对的键和值要么就是小整数值，要么就是长度较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。

#### 压缩列表的构成

压缩列表是Redis为了节约内存开发的，是由一系列特殊编码的连续内存块组成的**顺序型数据结构**。一个压缩列表可以包含任意多节点（entry），每个节点可以保存一个字节数组或一个整数值。

![image-20210528165256106](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210528165256106.png)

| 属性    | 类型     | 长度  | 用途                                                         |
| ------- | -------- | ----- | ------------------------------------------------------------ |
| zlbytes | uint32_t | 4字节 | 记录ziplist占用的内存字节，在对ziplist进行内存重新分配或减少zlend的位置时使用 |
| zltail  | uint32_t | 4字节 | 记录ziplist尾节点距离压缩列表的起始地址有多少字节，通过偏移量无需变量整个ziplist可以确定表尾节点地址 |
| zllen   | uint16_t | 2字节 | 记录ziplist节点数，当属性小于65535，这个属性值就是压缩列表包含节点的数量，等于65536时需要遍历计算 |
| entryN  | 列表节点 | 不定  | 压缩列表包含的各个节点，节点的长度由节点保存的内容决定       |
| zlend   | uint8_t  | 1字节 | 特使值0xFF，用来标记压缩列表末端                             |

#### 压缩列表节点的构成

每个压缩节点可以保存一个字节数组或一个整数值，其中字节数组可以是以下三种长度的其中一种：

+ 长度小于等于2^6-1字节的字节数组
+ 长度小于等于2^14-1字节的字节数组
+ 长度小于等于2^32-1字节的字节数组

而整数值可以是以下六种长度的其中一种：

+ 4bit，介于0-12的无符号整数
+ 1byte长的有符号整数
+ 3byte长的有符号整数
+ int16_t类型整数
+ int32_t类型整数
+ int64_t类型整数

压缩列表组成有三部分组成：

![image-20210528170328489](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210528170328489.png)

+ **pervious_entry_length：**字节为单位，记录压缩列表中前一个字节长度。这个属性长度可以是1字节或5字节

  + 如果长度小于254，pervious_entry_length长度为1字节，前一个节点长度就保存在这一个字节
  + 如果长度大于等于254，pervious_entry_length长度为5字节，其中第一个字节设置为0XFF，之后四个字节保存前一节点长度

  通过pervious_entry_length属性记录前一个节点长度，程序可以通过指针运算，根据当前节点的起始地址计算出前一个节点的起始地址

  压缩列表从表尾到表头的变量使用找一个原理实现，只有拥有执行某个节点的起始地址的指针，通过这个指针和pervious_entry_length属性即可往前一个节点回溯，最终到达表头节点。

  ![image-20210528171920363](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210528171920363.png)

+ **encoding：**记录了节点的content属性保存数据的类型以及长度

  + 一字节、两字节或五字节长，值的最高位为00、01或10的是字节数组编码：这种编码表示节点的content属性保存字节数组，数组长度由编码的最高两位去除之后的其他为的记录
  + 一字节长，值的最高位以11开头的整数编码：这种编码表示节点的content属性保存整数值，整数值的类型和长度由编码除去除最高两位之后的其他位记录

+ **content：**负责保存节点的值，节点的值可以是一个字节数组或者整数，值的类型和长度由节点encoding属性决定

下图展示了一个保存了“hello world”的节点

![image-20210530101324220](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530101324220.png)

下图展示了一个保存了10086的节点

![image-20210530101405339](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530101405339.png)

#### 连锁更新

前面我们知道，压缩列表的每个节点的都有一个pervious_entry_length属性，**记录压缩列表中前一个字节长度**。

+ 如果长度小于254，pervious_entry_length长度为1字节，前一个节点长度就保存在这一个字节
+ 如果长度大于等于254，pervious_entry_length长度为5字节，其中第一个字节设置为0XFF，之后四个字节保存前一节点长度

现在考虑这种情况，在一个压缩列表中，有多个连续的、长度介于250字节到253字节之间的e1到eN，如下图：

![image-20210530102524823](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530102524823.png)

此时由于长度介于250字节到253字节之间，因此这些元素的pervious_entry_length的属性只需要占用一个字节。

但是这时，在e1前面插入了一个新的元素，其大小大于等于254。这时e1的pervious_entry_length将会占用5个字节，此时e1的长度将要大于等于254，导致在扩展的过程中，e1的长度也需要额外增加。以此类推，由于e1之后的大量元素都会存在同样的情况，所以程序不断对压缩列表执行空间重分配，直到eN为止。

Redis将这种特殊情况产生的连续多次空间控制操作称之为“连锁更新”（casacde update）。

除此之外，简单分析可以知道，在删除的时候也会出现类似情况。

因为连锁更新在最坏情况下需要对压缩链表执行N次空间重分配操作，而每次空间重分配的最坏时间复杂度为O(N)，所以连锁更新的最坏复杂度为O(N*N）。

需要注意，尽管连锁更新的复杂度很高，但是真正造成性能问题的几率很低：

+ 首先，压缩列表里要恰好有多个连续的、长度介于250字节甚至253字节之间的节点；
+ 其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响。

综上所述，ziplist的push等命令的平均复杂度为O(N)。

## 七、对象

#### 概述

前面介绍了Redis的主要数据结构：SDS、list、dict、skiplist、ziplist、intset等。

但Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建一个对象系统，包含了**字符串对象、列表对象、哈希对象、集合对象和有序集合对象**这五种类型的对象，每种对象的实现至少使用了一种数据结构。

通过五种不同类型的对象，Redis可以在执行命令前，根据对象的类型来判断一个对象是否可以执行给定命令。

使用对象的另一个好处是可以针对不同场景为对象设置不同的数据结构实现，从而优化对象在不同场景下的效率，如哈希对象有两种实现。

除此之外，Redis的对象系统还实现了基于引用计数的内存回收机制，当程序不再使用某个对象时，这个对象占用的内存就自动释放；另外Redis还通过引用计数计数实现了对象共享机制，这一机制通过让多个数据库键共享同一个对象来节省内存。

最后，Redis的对象带有访问时间记录信息，该休息可用于计算数据库键的空转时长，在服务器启用了maxmemory的时候，空转时长较大的键可能会优先被服务器删除。

#### 对象的类型与编码

Redis使用对象表示数据库中的键和值，每次在Redis中创建一个键值对，至少会创建两个对象，一个对象用于键，另一个用于值。

Redis中每一个对象由一个redisObject结构表示：

```c
typedef struct redisObject {
    // 类型
    unsigned type:4;
    // 编码
    unsigned encoding:4;
    // 执行底层实现数据结构的指针
    void *ptr;
    // ...
} robj;
```

+ **type**，记录了对象的类型，可以是：

  + REDIS_STRING：字符串对象
  + REDIS_LIST：列表对象
  + REDIS_HASH：哈希对象
  + REDIS_SET：集合对象
  + REDIS_ZSET：有序集合对象

  对于Redis数据库保存到键值对来说，键总是一个字符串对象，值则可以是字符串、列表、哈希、集合、有序集合。

  通过type可以查看一个键对应的值的数据类型。

+ **encoding**，记录了对象使用的编码，即这个对象使用什么数据结构作为对象底层实现

  + REDIS_ENCODING_INT：long类型整数
  + REDIS_ENCODING_EMBSTR：embstr编码的简单动态字符串
  + REDIS_ENCODING_RAW：简单动态字符串
  + REDIS_ENCODING_HT：字典
  + REDIS_ENCODING_LINKEDLIST：双端链表
  + REDIS_ENCODING_ZIPLIST：压缩列表
  + REDIS_ENCODING_INTSET：整数集合
  + REDIS_ENCODING_SKIPLIST：跳跃表和字典

  每种类型兑现至少使用两种不同编码：可以通过OBJECT ENCODING查看指定键其值对象的编码

  ![image-20210530114714443](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530114714443.png)

  通过encoding属性来设定对象使用的编码，而不是为特定类型的对象关联一种固定的编码，极大提高了Redis的灵活性和效率，使得Redis可以根据不同场景为一个对象设置不同编码，从而优化对象的使用效率。

+ **ptr**，执行了对象底层实现树结构，这数据结构由encoding属性决定

#### 字符串对象

字符串编码可以是int、raw和embstr。

**当一个字符串对象保存的是整数值，并且这个整数值可以用long来表示，此时字符串对象会将整数值保存在字符串结构的ptr属性（将void*转换为long），并将字符串对象的编码设置为int。**

![image-20210530120044561](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530120044561.png)

**当一个字符串对象保存的是一个字符串值，并且这个字符串值长度大于32字节，那么整个字符串将使用SDS来保存字符串值，并将对象编码设置为raw。**

![image-20210530120159431](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530120159431.png)

**当一个字符串对象保存的是一个字符串值，并且字符串值长度小于等于32字节，那么字符串对象将使用embstr编码方式保存这个字符串。**

![image-20210530120253880](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530120253880.png)

embstr是专门用于保存短字符串的一种优化编码方式，和raw一样，都是用redisObject结果和sdshdr结构来表示字符串对象。但raw编码会调用两次内存分配函数分别创建redisObject和sdshdr，而embstr通过调用一次内存分配函数分配一块连续内存。

embstr编码保存短字符串有以下好处：

+ embstr内存分配raw的两次变为一次
+ 释放embstr编码的字符串对象只需要调用一次内存释放，而raw需要两次
+ embstr字符串对象保存在连续内存，比raw编码的字符串对象**更好利用缓存**

除此之外，字符串可保存long double类型浮点数。这时，程序会先将浮点数转成字符串值，再保存转换得到的字符串。

int和embstr类型的字符串可能会在某些情况下被转换为raw类型。如在int类型的字符串执行了APPEND命令之后会被转换为raw。

同时Redis没有为embstr（嵌入式字符串，嵌入到redisObject）编写任何修改程序，因此embstr实际上是只读的。因此对embstr执行修改会先转换为raw。

字符串的命令实现

| 命令        | `int` 编码的实现方法                                         | `embstr` 编码的实现方法                                      | `raw` 编码的实现方法                                         |
| :---------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| SET         | 使用 `int` 编码保存值。                                      | 使用 `embstr` 编码保存值。                                   | 使用 `raw` 编码保存值。                                      |
| GET         | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。 | 直接向客户端返回字符串值。                                   | 直接向客户端返回字符串值。                                   |
| APPEND      | 将对象转换成 `raw` 编码， 然后按 `raw` 编码的方式执行此操作。 | 将对象转换成 `raw` 编码， 然后按 `raw` 编码的方式执行此操作。 | 调用 `sdscatlen` 函数， 将给定字符串追加到现有字符串的末尾。 |
| INCRBYFLOAT | 取出整数值并将其转换成 `long double` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 | 取出字符串值并尝试将其转换成 `long double` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。 | 取出字符串值并尝试将其转换成 `long double` 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。 |
| INCRBY      | 对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。  | `embstr` 编码不能执行此命令， 向客户端返回一个错误。         | `raw` 编码不能执行此命令， 向客户端返回一个错误。            |
| DECRBY      | 对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。  | `embstr` 编码不能执行此命令， 向客户端返回一个错误。         | `raw` 编码不能执行此命令， 向客户端返回一个错误。            |
| STRLEN      | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。 | 调用 `sdslen` 函数， 返回字符串的长度。                      | 调用 `sdslen` 函数， 返回字符串的长度。                      |
| SETRANGE    | 将对象转换成 `raw` 编码， 然后按 `raw` 编码的方式执行此命令。 | 将对象转换成 `raw` 编码， 然后按 `raw` 编码的方式执行此命令。 | 将字符串特定索引上的值设置为给定的字符。                     |
| GETRANGE    | 拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。 | 直接取出并返回字符串指定索引上的字符。                       | 直接取出并返回字符串指定索引上的字符。                       |

#### 列表对象

列表的编码可以是ziplist或者linkedlist。

**ziplist编码方式使用压缩列表来作为底层实现，每个压缩列表节点保存一个列表元素。**

![image-20210530122109584](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530122109584.png)

**linkedlist编码方式使用双端链表作为底层实现，每个节点保存了一个字符串对象，每个字符串对象都保存了一个列表元素。**

![image-20210530122227676](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530122227676.png)

注意，linkedlist编码的列表对象在底层的双端链表中包含了多个字符串对象。字符串对象是Redis五种类型中唯一一种会被其他四种类型对象嵌套的对象。

当列表满足一下两个条件时，列表对象使用ziplist编码：

+ 列表对象保存的所有字符串长度小于[64](list-max-ziplist-value)；
+ 列表对象保存的元素数量小于[512](list-max-ziplist-entries)个；
+ 除此之外列表对象需要使用linkedlist编码。

列表命令实现

| 命令    | `ziplist` 编码的实现方法                                     | `linkedlist` 编码的实现方法                                  |
| :------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| LPUSH   | 调用 `ziplistPush` 函数， 将新元素推入到压缩列表的表头。     | 调用 `listAddNodeHead` 函数， 将新元素推入到双端链表的表头。 |
| RPUSH   | 调用 `ziplistPush` 函数， 将新元素推入到压缩列表的表尾。     | 调用 `listAddNodeTail` 函数， 将新元素推入到双端链表的表尾。 |
| LPOP    | 调用 `ziplistIndex` 函数定位压缩列表的表头节点， 在向用户返回节点所保存的元素之后， 调用 `ziplistDelete` 函数删除表头节点。 | 调用 `listFirst` 函数定位双端链表的表头节点， 在向用户返回节点所保存的元素之后， 调用 `listDelNode` 函数删除表头节点。 |
| RPOP    | 调用 `ziplistIndex` 函数定位压缩列表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 `ziplistDelete` 函数删除表尾节点。 | 调用 `listLast` 函数定位双端链表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 `listDelNode` 函数删除表尾节点。 |
| LINDEX  | 调用 `ziplistIndex` 函数定位压缩列表中的指定节点， 然后返回节点所保存的元素。 | 调用 `listIndex` 函数定位双端链表中的指定节点， 然后返回节点所保存的元素。 |
| LLEN    | 调用 `ziplistLen` 函数返回压缩列表的长度。                   | 调用 `listLength` 函数返回双端链表的长度。                   |
| LINSERT | 插入新节点到压缩列表的表头或者表尾时， 使用 `ziplistPush` 函数； 插入新节点到压缩列表的其他位置时， 使用 `ziplistInsert` 函数。 | 调用 `listInsertNode` 函数， 将新节点插入到双端链表的指定位置。 |
| LREM    | 遍历压缩列表节点， 并调用 `ziplistDelete` 函数删除包含了给定元素的节点。 | 遍历双端链表节点， 并调用 `listDelNode` 函数删除包含了给定元素的节点。 |
| LTRIM   | 调用 `ziplistDeleteRange` 函数， 删除压缩列表中所有不在指定索引范围内的节点。 | 遍历双端链表节点， 并调用 `listDelNode` 函数删除链表中所有不在指定索引范围内的节点。 |
| LSET    | 调用 `ziplistDelete` 函数， 先删除压缩列表指定索引上的现有节点， 然后调用 `ziplistInsert` 函数， 将一个包含给定元素的新节点插入到相同索引上面。 | 调用 `listIndex` 函数， 定位到双端链表指定索引上的节点， 然后通过赋值操作更新节点的值。 |

#### 哈希对象

哈希对象的编码可以使用ziplist或者hashtable。

**ziplist编码方式的哈希对象底层使用压缩列表作为实现。**

每当有新的键值对要加入到哈希对象时，程序会分别将键和值的压缩列表节点推入到压缩列表表尾，因此，保存同一键值对的连个节点总是紧挨着，键前值后。同时可以知道，先添加到的哈希对象键值对在前面，后添加的在后面。

![image-20210530123617211](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530123617211.png)

![image-20210530123633305](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530123633305.png)

**hashtable编码方式的哈希对象底层使用字典作为实现。**

哈希对象的每个键值对都使用一个字典键值对来保存。

![image-20210530123848268](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530123848268.png)

 当满足以下条件，哈希对象使用ziplist编码：

+ 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节
+ 哈希对象保存的键值对数量小于512个
+ 其他情况使用hashtable编码

哈希表命令实现

| 命令    | `ziplist` 编码实现方法                                       | `hashtable` 编码的实现方法                                   |
| :------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| HSET    | 首先调用 `ziplistPush` 函数， 将键推入到压缩列表的表尾， 然后再次调用 `ziplistPush` 函数， 将值推入到压缩列表的表尾。 | 调用 `dictAdd` 函数， 将新节点添加到字典里面。               |
| HGET    | 首先调用 `ziplistFind` 函数， 在压缩列表中查找指定键所对应的节点， 然后调用 `ziplistNext` 函数， 将指针移动到键节点旁边的值节点， 最后返回值节点。 | 调用 `dictFind` 函数， 在字典中查找给定键， 然后调用 `dictGetVal` 函数， 返回该键所对应的值。 |
| HEXISTS | 调用 `ziplistFind` 函数， 在压缩列表中查找指定键所对应的节点， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。 | 调用 `dictFind` 函数， 在字典中查找给定键， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。 |
| HDEL    | 调用 `ziplistFind` 函数， 在压缩列表中查找指定键所对应的节点， 然后将相应的键节点、 以及键节点旁边的值节点都删除掉。 | 调用 `dictDelete` 函数， 将指定键所对应的键值对从字典中删除掉。 |
| HLEN    | 调用 `ziplistLen` 函数， 取得压缩列表包含节点的总数量， 将这个数量除以 `2` ， 得出的结果就是压缩列表保存的键值对的数量。 | 调用 `dictSize` 函数， 返回字典包含的键值对数量， 这个数量就是哈希对象包含的键值对数量。 |
| HGETALL | 遍历整个压缩列表， 用 `ziplistGet` 函数返回所有键和值（都是节点）。 | 遍历整个字典， 用 `dictGetKey` 函数返回字典的键， 用 `dictGetVal` 函数返回字典的值。 |

#### 集合对象

集合对象的编码可以是inset或hashtable。

**intset编码的集合对象使用整数集合作为底层实现，集合对象包含私有元素都被保存在整数集合中。**

![image-20210530124454845](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530124454845.png)

hashtable编码的集合对象使用字典作为底层实现，字典中每一个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字符串的值全部被设置为NULL。

![image-20210530124523993](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530124523993.png)

集合元素满足以下条件是，对象使用intset

+ 集合对象保存的所有元素都是整数值
+ 集合对象保存的元素个数不超过512
+ 不满足以上条件使用hashtable

集合命令实现方法

| 命令        | `intset` 编码的实现方法                                      | `hashtable` 编码的实现方法                                   |
| :---------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| SADD        | 调用 `intsetAdd` 函数， 将所有新元素添加到整数集合里面。     | 调用 `dictAdd` ， 以新元素为键， `NULL` 为值， 将键值对添加到字典里面。 |
| SCARD       | 调用 `intsetLen` 函数， 返回整数集合所包含的元素数量， 这个数量就是集合对象所包含的元素数量。 | 调用 `dictSize` 函数， 返回字典所包含的键值对数量， 这个数量就是集合对象所包含的元素数量。 |
| SISMEMBER   | 调用 `intsetFind` 函数， 在整数集合中查找给定的元素， 如果找到了说明元素存在于集合， 没找到则说明元素不存在于集合。 | 调用 `dictFind` 函数， 在字典的键中查找给定的元素， 如果找到了说明元素存在于集合， 没找到则说明元素不存在于集合。 |
| SMEMBERS    | 遍历整个整数集合， 使用 `intsetGet` 函数返回集合元素。       | 遍历整个字典， 使用 `dictGetKey` 函数返回字典的键作为集合元素。 |
| SRANDMEMBER | 调用 `intsetRandom` 函数， 从整数集合中随机返回一个元素。    | 调用 `dictGetRandomKey` 函数， 从字典中随机返回一个字典键。  |
| SPOP        | 调用 `intsetRandom` 函数， 从整数集合中随机取出一个元素， 在将这个随机元素返回给客户端之后， 调用 `intsetRemove` 函数， 将随机元素从整数集合中删除掉。 | 调用 `dictGetRandomKey` 函数， 从字典中随机取出一个字典键， 在将这个随机字典键的值返回给客户端之后， 调用 `dictDelete` 函数， 从字典中删除随机字典键所对应的键值对。 |
| SREM        | 调用 `intsetRemove` 函数， 从整数集合中删除所有给定的元素。  | 调用 `dictDelete` 函数， 从字典中删除所有键为给定元素的键值对。 |

#### 有序集合对象

有序集合对象可以是ziplist或skiplist。

**ziplist编码的有序集合对象使用压缩列表作为底层实现。**

此时每个集合元素使用紧挨着列表节点保存，一个保存元素成员（member），另一个保存元素的分值（score）。

![image-20210530125029479](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530125029479.png)

![image-20210530125047702](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530125047702.png)

压缩列表中集合元素按分值从小到大排序，分值较小的处于表头。

**skiplist编码的有序集合对象使用zset结构作为底层实现。**

```c
typedef struct zset {
    zskiplist *zsl;
    dict *dict;
}
```

zset结构中的zsl跳跃表按分值大小从小到大保存所有集合元素，每个跳跃表节点都保存了一个集合元素（object保存元素，score保存元素分值）。ZRANGE和ZRANK通过跳跃表API实现。

除此之外，zset的dict字典为有序集合创建宇哥从成员到分值的银蛇，字典的每个键值对都保存一个集合元素（键为元素，值为分数）。ZSCORE通过字典实现O(1)复杂度查找指定成员分值。

有序集合每个元素的成员都是一个字符串对象，每个元素的分值都是一个double类型浮点数。

虽然zset结构同时使用跳跃表和字典来保存有序集合，但是两种数据结构通过共享指针来共享相同的元素和分值。

总的来说，zset结构同时使用跳跃表和字典是兼顾了两种数据结构的特性：字典无序但取值很快，skiplist需要遍历查找取值，但是使用与范围查找。

![image-20210530130015295](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530130015295.png)

![image-20210530130033435](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210530130033435.png)

有序集合满足一下条件，ziplist编码：

+ 有序集合保存的所有元素成员的长度都小于64字节
+ 有序集合保存的元素小于128
+ 不满足以上条件使用skiplist编码

有序集合命令

| 命令      | `ziplist` 编码的实现方法                                     | `zset` 编码的实现方法                                        |
| :-------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| ZADD      | 调用 `ziplistInsert` 函数， 将成员和分值作为两个节点分别插入到压缩列表。 | 先调用 `zslInsert` 函数， 将新元素添加到跳跃表， 然后调用 `dictAdd` 函数， 将新元素关联到字典。 |
| ZCARD     | 调用 `ziplistLen` 函数， 获得压缩列表包含节点的数量， 将这个数量除以 `2` 得出集合元素的数量。 | 访问跳跃表数据结构的 `length` 属性， 直接返回集合元素的数量。 |
| ZCOUNT    | 遍历压缩列表， 统计分值在给定范围内的节点的数量。            | 遍历跳跃表， 统计分值在给定范围内的节点的数量。              |
| ZRANGE    | 从表头向表尾遍历压缩列表， 返回给定索引范围内的所有元素。    | 从表头向表尾遍历跳跃表， 返回给定索引范围内的所有元素。      |
| ZREVRANGE | 从表尾向表头遍历压缩列表， 返回给定索引范围内的所有元素。    | 从表尾向表头遍历跳跃表， 返回给定索引范围内的所有元素。      |
| ZRANK     | 从表头向表尾遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。 | 从表头向表尾遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。 |
| ZREVRANK  | 从表尾向表头遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。 | 从表尾向表头遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。 |
| ZREM      | 遍历压缩列表， 删除所有包含给定成员的节点， 以及被删除成员节点旁边的分值节点。 | 遍历跳跃表， 删除所有包含了给定成员的跳跃表节点。 并在字典中解除被删除元素的成员和分值的关联。 |
| ZSCORE    | 遍历压缩列表， 查找包含了给定成员的节点， 然后取出成员节点旁边的分值节点保存的元素分值。 | 直接从字典中取出给定成员的分值。                             |















