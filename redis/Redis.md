# Redis

## 基本概念

> 简述对Redis的认识
>
> 简述对Memcached的认识
>
> 简述Redis和Memcached的区别
>
> 简述使用Redis的好处

+ Redis是一种支持key-value等多种数据结构的储存系统，常用于缓存、事件发布订阅、高速队列等场景；
+ Redis提供了丰富的数据结构，可以最大限度节省内存以及提供数据查询效率；
+ Redis读写性能优异，读速度解决11万次每秒、写速度接近8万次每秒；
+ Redis支持丰富的特性，如发布订阅、通知、可以过期等；
+ Redis提供了AOF和RDB等持久化方式，保障数据安全；
+ Reids对于分布式有良好支持，具备高可用特性；



## 数据结构与对象

> 简述Redis中数据结构与对象的关系
>
> 简述Redis不同对象与编码的关系

+ Redis支持的数据结构由：String、List、Hash、Set、SortedSet
+ String通过简单动态字符串来实现；
+ List通过双向链表和压缩链表来实现；
+ Hash通过哈希表或压缩链表来实现；
+ Set通过整数数组或哈希表来实现；
+ Sorted Set通过跳表或压缩列表来实现；



> 简述Redis中简单字符串数据结构的认识(用于实现默认字符串)

+ String中字符串编码方式可以是int、raw和embstr
+ 当一个字符串保存的是整数值，且在long的范围，这个整数值会保存指针区域；
+ 当一个字符串保存的是字符串，且长度大于32字节，则采用SDS来保存，此时编码设置为raw；
+ 当一个字符串保存的是字符串，且长度小于等于32字节，则采用embstr，此时编码格式为embstr；
+ embstr是专门用于保存短字符串优化编码方式，embstr保存短字符串有以下好处：
  + embstr只分配一次内存（embstr拼接在redisObject之后，sds需要新建一个sdshdr）；
  + embstr的编码的字符串只需要调用一次内存释放；
  + embstr支持对象保存在连续的内存中，可以更好利用缓存；
+ Redis中的简单动态字符串(SDS)是一种动态的字符串；
+ 简单动态字符串类似于Java中的ArrayList，可以实现空间预分配，空间的惰性释放；
+ 简单动态字符串是二进制安全的，允许储存特殊字符；



> 简述Redis中链表数据结构的认识(用于实现列表的键)

+ Redis中的List由两种数据结构来实现：压缩链表和双向链表；
+ 当List中的保存的数据长度小于64字节，且元素个数小于512个，此时采用压缩列表；
+ 压缩列表是一种特殊编码的连续内存组成的顺序型数据结构；
+ 压缩列表中每个节点记录了当前节点的编码方式、内容、以及上一个节点的大小；
+ 由于压缩列表中每一个节点长度不同，因此需要通过遍历来获取数据；
+ 因此可以看出，当数据量较大时，不使用使用压缩链表；
+ 使用压缩链表的的好处体现在时间效率上；
+ 时间表现在压缩链表是连续的内存结构，可以利用CPU缓存；



> 简述Redis中字典数据结构的认识(用于实现数据库)

+ Redis中Hash有两种数据结构实现：压缩链表和哈希表；
+ 当Hash保存的所有键值对的键和值都小于64字节，且个数小于512个是，采用压缩列表，否则使用哈希表；
+ Redis中的哈希表使用链地址来解决哈希冲突的问题，哈希冲突的元素同next指针串联起来；
+ 采用链地址法解决哈希冲突是，如果哈希表中元素太多，会造成链表过长，查询效率低；
+ 解决链表过长方法是重用新分配更大的hash表，从而保证冲突的概率变小；
+ 在重分配的过程中，Redis采用渐进式rehash的方式来保证性能稳定；
+ 即将数据从旧表移动到新表的过程分摊到每次的查询中，进而减少一次性rehash的性能抖动；

+ 在渐进式rehash的过程中，会同时存在旧表和新表，此时如果新增数据会在新表中新增；
+ 如果要查询数据则需要在两张表中查询；



> 简述Redis中跳跃表数据结构的认识(用于实现有序集合)

+ 跳表一种有序的数据结构，可以认为是链表的扩展；
+ 它克服了链表随机访问慢的缺点，通过维持多个指向其他节点的节点的指针达到快速访问的目的；
+ 跳表支持平均O(logN)的节点查找，可以同顺序操作批量插入节点；
+ 大部分情况下，跳表的效率可以与平衡树媲美，而且跳表的是吸纳比平衡树简单；
+ 跳表可以被用来Redis中Sorted Set的实现；



> 简述Redis中整数集合数据结构的认识(用于实现集合的键)

+ 当一个集合中只包含整数元素且这个集合的元素个数不多时，Redis使用数组作为Set的底层实现；
+ 整数数组中每个元素都是有序的，且不会出现重复项目；
+ 整数数组中同一时刻所有元素空间大小是相同的，但不同时刻元素的大小可能不同；
+ 数组中的元素大小可能是8字节、18字节、32字节以及64字节；
+ 当一个新元素添加到整数数组的时候，如果这个元素比数组所有元素的类型都要长，则整数数组需要先升级，然后才能将元素添加到整数数组中。



> 简述Redis中压缩列表数据结构的认识(用于实现列表的键)

+ 当List中的保存的数据长度小于64字节，且元素个数小于512个，此时采用压缩列表；
+ 压缩列表是一种特殊编码的连续内存组成的顺序型数据结构；
+ 压缩列表中每个节点记录了当前节点的编码方式、内容、以及上一个节点的大小；
+ 由于压缩列表中每一个节点长度不同，因此需要通过遍历来获取数据；
+ 因此可以看出，当数据量较大时，不使用使用压缩链表；
+ 使用压缩链表的的好处体现在时间效率上；
+ 时间表现在压缩链表是连续的内存结构，可以利用CPU缓存；



> 简述对字符串对象的认识

+ String中字符串编码方式可以是int、raw和embstr
+ 当一个字符串保存的是整数值，且在long的范围，这个整数值会保存指针区域；
+ 当一个字符串保存的是字符串，且长度大于32字节，则采用SDS来保存，此时编码设置为raw；
+ 当一个字符串保存的是字符串，且长度小于等于32字节，则采用embstr，此时编码格式为embstr；
+ embstr是专门用于保存短字符串优化编码方式，embstr保存短字符串有以下好处：
  + embstr只分配一次内存（embstr拼接在redisObject之后，sds需要新建一个sdshdr）；
  + embstr的编码的字符串只需要调用一次内存释放；
  + embstr支持对象保存在连续的内存中，可以更好利用缓存；
+ Redis中的简单动态字符串(SDS)是一种动态的字符串；
+ 简单动态字符串类似于Java中的ArrayList，可以实现空间预分配，空间的惰性释放；
+ 简单动态字符串是二进制安全的，允许储存特殊字符；



> 简述对列表对象的认识

+ 当List中的保存的数据长度小于64字节，且元素个数小于512个，此时采用压缩列表；
+ 压缩列表是一种特殊编码的连续内存组成的顺序型数据结构；
+ 压缩列表中每个节点记录了当前节点的编码方式、内容、以及上一个节点的大小；
+ 由于压缩列表中每一个节点长度不同，因此需要通过遍历来获取数据；
+ 因此可以看出，当数据量较大时，不使用使用压缩链表；
+ 使用压缩链表的的好处体现在时间效率上；
+ 时间表现在压缩链表是连续的内存结构，可以利用CPU缓存；



> 简述对哈希对象的认识

+ Redis中Hash有两种数据结构实现：压缩链表和哈希表；
+ 当Hash保存的所有键值对的键和值都小于64字节，且个数小于512个是，采用压缩列表，否则使用哈希表；
+ Redis中的哈希表使用链地址来解决哈希冲突的问题，哈希冲突的元素同next指针串联起来；
+ 采用链地址法解决哈希冲突是，如果哈希表中元素太多，会造成链表过长，查询效率低；
+ 解决链表过长方法是重用新分配更大的hash表，从而保证冲突的概率变小；
+ 在重分配的过程中，Redis采用渐进式rehash的方式来保证性能稳定；
+ 即将数据从旧表移动到新表的过程分摊到每次的查询中，进而减少一次性rehash的性能抖动；

+ 在渐进式rehash的过程中，会同时存在旧表和新表，此时如果新增数据会在新表中新增；
+ 如果要查询数据则需要在两张表中查询；



> 简述对集合对象的认识

+ Redis中集合有两种实现：数组集合或哈希表；
+ 当集合中所有元素都是整数值，且元素不超过512时，使整数集合实现，负责使用哈希表实现；



> 简述对有序集合对象的认识
>
> 简述为什么有序集合同时采用跳表和字典来实现?

+ Redis中有序集合有了两种实现方式：压缩表 或 跳表+字典；
+  压缩表用于有序集合中元素长度小于64字节，且元素个数小于128个的场景；
+ 当集合中元素较长或元素个数较多的时候，Sorted Set采用跳表+字典的方式来实现；
+ 有序集合中每个成员都是一个字符串对象，每个元素的分值都是一个double类型的浮点数；
+ Sorted Set同时使用跳表和字典来实现是兼顾了两种数据结构的特性；
+ 字典无需但取值很快，可以用于查询一个数据的分值（score）；
+ 跳表需要遍历查找值，但是适用于访问查找，有利于根据分值范围查询元素；



## 持久化

> 简述Redis的持久化策略

+ Redis是内存数据库，将数据信息保存在内存中，一旦进程退出或发生宕机，数据将会全部丢失；
+ 通常可以通过后端数据库恢复这些数据，但后端服务器存在性能瓶颈；
+ 对于大数据量恢复，不仅会对数据带来巨大压力，而且恢复起来很慢；
+ 因此Redis提供了四种持久化方案：RDB、AOF、虚拟内存和DISKSTORE；
+ 虚拟内存在Redis2.4开始不建议使用，Redis3.2无法配置；
+ DISKSTORE从Redis2.8提出，但目前位置没有找到这些配置；
+ 因此目前Redis主流的持久化方式有2种：AOF和RDB。

> 简述RDB

+ RDB是Redis DataBase简写，是内存快照的意思；
+ RDB持久化就是把当前进程数据生成快照保存在磁盘上；
+ RDB持久化的触发方式有两种：手动触发和自动触发；
+ 手动触发由save和bgsave命令支持；
+ save命令会阻塞当前服务器，知道RDB完成为止，因此对于数据量大的线上环境不建议使用；
+ bgsave会在Redis进程执行fork操作创建子进程，持久化过程由子进程负责，完成之后自动结束；

+ 自动触发则由4中情况触发：
  + 在conf文件中配置了save m n，m秒内修改n次，自动触发bgsave；
  + 主从复制时，从节点从主节点进行全量复制也会触发bgsave；
  + 执行debug reload命令重新加载redis也会触发bgsave；
  + 默认情况下执行shutdown命令如果没有开启AOF，也会触发bgsave；

+ RDB的优点是：
  + RDB文件是某个时间点的快照，通过算法进行压缩，压缩后的文件体积远小于内存大小，适用于备份、全量复制等场景；
  + Redis加载RDB文件恢复远快于AOF方式；
+ RDB实时性不够，无法做到纳米级的持久化；
+ 每次调用bgsave都需要fork子进程，fork子进程属于重量级操作；
+ RDB文件是二进制的，无可读性，AOF可以在了解其结构的情况下修补；
+ 不同Redis的版本RDB可能不兼容；

> 简述AOF

+ AOF是写后日志，Redis先执行命令，再把数据写入内存，然后记录日志；
+ AOF日志中记录的是Redis收到的命令，这些命令以文本形式保存；
+ AOF采用的写后策略有两方面好处：
  + 避免额外的检查开销：AOF只记录执行成功的命令，如果是语法错误将无法执行成功，也不会被记录；
  + 不会阻塞当前写操作；
+ 但AOF的写后策略存在风险：
  + 如果命令执行完成，写日志之前宕机，会丢失数据；
  + 如果主线程写磁盘压力大，会导致写盘慢，阻塞后继操作；

+ AOF记录过程分为：命令追加、文件写入和文件同步；
  + 命令追加：当AOF持久化功能开启，服务器在在执行完一个写命令之后，会以协议格式将执行将写命令追加到服务器的aof_buf中缓存；
  + 文件写入与同步：Redis提供了三种策略「appendfsync」来配置文件写入的时机
    + Always：同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
    + Everysec：每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
    + No：操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。
+ 由于AOF日志会记录每个写命令到AOF文件中，随着时间的增长，AOF文件会越来越大；
+ 如果不对AOF日志进行控制，会对Redis服务器，甚至操作系统造成影响；
+ 同时，如果AOF文件过大将会导致恢复起来很慢，Redis通过AOF重写机制来对AOF文件进行压缩；
+ aof重写过程由主进程fork处理的后台进程执行，fork会把主线程的内存拷贝给子进程；
+ 因此aof重写可以在不影响主线程的情况下，逐一把数据写成操作，既然重写日志；



> 简述混合持久化的理解

+ Redis4.0提出了混合使用AOF和RDB的方法进行持久化；
+ 简而言之，就是以一定频率执行RDB，在两次RDB之间使用AOF记录命令；
+ 这样就快照不需要很频繁执行过，避免了频繁fork对主线程的影响；
+ 另外AOF只需要记录两次快照的操作，不会出现文件过大的情况，避免重写的开销；



> 简述RDB与AOF的对比

| RDB              | AOF            |
| ---------------- | -------------- |
| 基于内存快照写   | 基于命令写     |
| 全量备份         | 增量备份       |
| 恢复快           | 恢复慢         |
| 二进制，无可读性 | 命令文本，可读 |
| 兼容性不足       | 良好兼容性     |



## 并发

> 简述Redis所谓的单线程
>
> Redis哪里不使用单线程?

+ Reids单线程表示Redis的网络IO和键值对读写由一个线程完成；
+ 但Redis的其他功能，如持久化，异步删除、集群数据同步等有额外的线程执行；
+ Redis使用单线程有以下原因：
  + 多线程编程负责，不利于系统维护；
  + 多线程往往需要考虑并发控制，需要考虑锁的粒度，负责可能导致系统吞吐量比单线程低；
  + 多线程存在线程上下文切换的消耗；
+ 经过Redis主流程运行在单线程模式下，但Redis利用了操作系统提供的IO多路复用机制；
+ 该机制允许单个线程同时存多个监听的套接字和已连接的套接字；
+ 这样多个客户端可以通过网络直接连接到Redis服务器中，Redis则不断选择时间进行执行；



> Redis绝对线程安全么?
>
> Redis的并发竞争问题如何解决

## 复制

> 简述对Redis复制的理解

+ AOF和RDB两种持久化机制可以保证单点环境的数据安全，但无法保证数据的高可靠与高可用；
+ Redis的高可靠与高可用需要通过Redis的主从库模式开实现；
+ 在主从库模式下，数据同时保持在多个实例，保证了数据高可用；
+ 除此之外，主从库模式下，当主库宕机，从库还可以继续提供访问，保证了访问的高可用；
+ 主从模式下，主从库之间采用读写分离的方式：
  + 主库和从库都可以接收读操作；
  + 但写操作只允许有主库执行，然后主库将写操作同步给从库；



> 简述对旧版复制的理解
>
> 简述对新版复制的理解

+ Redis2.8之前只有全量复制，Redis2.8之后支持全量和增量复制；
+ 启动多个Redis实例是，可以通过replicaof命令形成主从库关系，随后开始复制数据；
+ 实现从库会给主库发送psync命令启动复制，由于是第一次数据复制，主库会将所有数据同步给从库；
+ 具体而言 ，主库执行gbsave命令，生成RDB文件，然后将文件发送给从库；
+ 由于从库可能保存了数据，为了避免对数据造成干扰，收到全量复制时会将本数据库清空；
+ 当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。

## 集群

> 简述对哨兵的认识

+ 哨兵机制有Redis2.8引入，核心功能是主节点的自动故障转移；
+ 哨兵主要实现了一下的功能：
  + 监控：哨兵会不断地检查主节点和从节点是否运作正常；
  + 自动故障转移：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点；
  + 配置提供者：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址；
  + 通知：哨兵可以将故障转移的结果发送给客户端；
+ [主从复制](https://www.pdai.tech/md/db/nosql-redis/db-redis-x-copy.html)和[哨兵机制](https://www.pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html)保障了高可用。

> 简述对集群认识

+ 主从复制与哨兵机制保证了高可用，读写分离控制了主从读并发能力；
+ 但对于写能力以及储存能力仍然无法进行扩展，只能是主节点的上限；
+ 面对海量数据，必须需要关键主节点之间的集群，且每个分片节点之间采用主从与哨兵机制进行保证；



> 简述集群分片的实现原理

+ Redis集群分片通过引入哈希槽概念来实现；
+ Redis集群分片中有2^14个哈希槽，每key通过CRC16后对2^14-1进行取模来决定反转那个槽；
+ Redis集群中的每个分片节点都负责一部分的哈希槽；



简述集群故障转移的过程

简述选举新的主节点的方式

#### 发布订阅

简述对Redis中发布订阅的认识

#### 事务

简述对Redis事务的认识
简述对Redis中Watch命令的认识

#### 其他

简述Redis的高可用是怎么实现?
为什么Redis的速度快?
简述对Redis通讯协议的理解
简述Redis的键淘汰策略
简述Redis的键生存时间和过期时间
如何判定一个键是否过期?
简述过期键的删除策略
如何保证Redis中的数据都是热点数据
简述Redis作为消息队列和其他消息队列应用的区别
简述对缓存穿透、雪崩、降级以及预热的理解
简述Redis有哪些架构模式
简述Redis如何优化内存使用
简述对一致性哈希的理解