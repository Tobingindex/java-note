# Redis核心技术与实战-实践篇-数据结构

## String

#### 概述

场景，开发一个图片储存系统，要求这个系统能够快熟记录图片ID和图片在储存系统的ID（简称图片储存对象ID）。同时还要根据图片ID快速查找到图片对象储存ID。

因为图片数量巨大，因此采用10位数来表示图片ID和图片储存ID，如：

```bash
photo_id:1101000051
photo_obj_id:3301000051
```

由于photo_id和photo_obj_id是一一对应的关系，而不是一个集合，因此考虑使用String。由于可以把数据转换为二进制自己数组，因此String像“万金油”一样，可以保持二进制数据。此例中photo_id作为key，photo_obj_id作为value。

在一亿张图片下，大约使用6.4GB内存。随着图片不断增加，Redis大内存将会导致生成RDB过程中花费时间太长，进而影响Redis主线程的响应。这时String不再是一个合适的选择。

#### 为什么String类型内存开销大？

上面，保存一亿张图片花了6.4GB内存，平均一个图片ID和图片尺寸对象ID的记录平均用64字节。

但实际上，一组图片ID以及储存对象ID的记录实际只需要16字节即可。即图片ID以及储存对象ID分别是10位的数字，可以用Long来保存，一个Long8个字节，仅需16字节。

然而在使用String类型的时候，除了要储存数据部分，还需要记录额外的信息，如内存空间记录数据长度、空间使用等，这些也称为元数据。这种情况下，当保存的数据较小，数据量加大，元数据占的空间就显得浪费了。

String在保存64位有符号整数时，会把它保存为一个8字节的Long类型整数，这种保存方式通常称为int编码方式。

当保存的数据包含字符时，String类型会用简单动态字符串（Simple Dynamic String，SDS）结构体来保存，如下图：

![image-20210524204215168](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210524204215168.png)

+ **buf**：字节数组，保存实际的数据。为了表示字节数组的结束，Redis会自动在数组最后加上一个“\0”，这就会额外占用一个字节的开销。
+ **len**：占用4个字节，表示buf已用长度。
+ **alloc**：占用4个字节，表示buf实际分配的长度，一般大于len。

从上面可以看出，buf是保存实际数据，len和alloc是额外的数据，一共占用了8个字节。

除此之外，String类型还有RedisObject结构体的开销。因为Redis的数据类型很多，而且不同数据类型都有相同的元数据要记录（比如最后一次访问时间、被引用的次数等），所以Redis会用一个RedisObject结构体来统一记录这些元数据，同时指向实际的数据。

![image-20210524204637920](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210524204637920.png)

一个RedisObject包含了8个字节的元数据和8个字节的指针，这个指针再进一步指向具体的数据所在，列入执行String类型的SDS所在的内存地址。

**为了节省内存空间，Redis还对Long类型整数和SDS的内存布局做了专门的设计。**

一方面，当保存的是Long类型整数的时候，RedisObject的指针会直接赋值为整数数据这就不用额外的指针在执行整数，节省了指针的空间开销。

另一方面，当保存是字符串的时候，如果字符串小于44个字节时，RedisObject中的元数据、指针和SDS是一块连续的内存区域，这样就可以避免内存碎片。这种布局也称为**embstr编码方式**。

当字符串大于44个字节，SDS的数据量就开始变多，Redis不再把SDS和RedisObject布局在一起，而是个SDS分配独立的空间，并用指针指向SDS结结构，这种布局方式称为**raw编码方式**。

![image-20210524205832992](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210524205832992.png)

熟悉了String对不同对数据的编码原理之后，再次分析储存一个10位整数的：

引用10位的图片ID和图片储存对象ID是Long类型的整数，所以可以直接用int编码的RedisObject保存。

从上面可以知道，int编码方式分别占用元数据（8Byte）、数据部分（8Byte），此时每个ID占用16Byte，两个ID占用32Byte。

Redis中会使用一个全局的哈希表来保存保存所有的键值对，哈希表的每一项是一个distEntry的结构体，用来直线一对键值对。distEntry结构体中有是哪个8字节的指针（key、value、next），一共24字节。

![image-20210524210618168](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210524210618168.png)

虽然实际占用的24字节，但是Redis在内存分配时使用的是jemalloc内存分配库。jemalloc在分配内存的时候，会向2^N字节对其，知道大于实际内存的最小2^N内存。由于24不是2^N字节，因此会采用32字节，因此distEntry占用的32字节。

最终，distEntry（32字节）+key（16字节）+value（16字节）=64字节。

因此使用String保存图片ID和图片储存对象ID的时候就需要占用64字节，而实际有效信息仅有16字节，存在48字节的额外数据，在上面的场景下，就存在月4.8GB内存空间用来保存元数据，非常浪费。

#### 用什么数据结构可以节省内存？

Redis有一种底层数据结构，叫做压缩列表（ziplist），是一种非常节省内存的结构。

ziplist的主要构成如下：表头三个字段zlbytes/zltail和zllen，分别表示列表长度、列表尾的偏移量，以及列表中的元素个数。压缩列表还有一个zlend，表示列表结束。

![image-20210524211617479](https://tobing-markdown.oss-cn-shenzhen.aliyuncs.com/image-20210524211617479.png)

压缩列表之所以节省内存，在于它使用一系列连续的entry保存数据，每个entry的元素包含以下几部分：

+ **prev_len：前一个entry的长度。**有两种取值情况：1字节或5字节。
  + 1字节：表示上一个entry的长度小于254字节。虽然1字节能表示255，但是255长度被用来特使指定为zlend元素。
  + 5字节：大于或等于254
+ **encoding：编码方式，1字节。**
+ **len：自身长度，4字节。**
+ **content：保存实际数据。**

和数组类型，这些entry连续存放，不需要用指针来进行指向，可以节省指针的类型。

接下来如果使用压缩列表来保存图片ID的映射，其占用的内存为：

每个图片ID占用8字节，每个entry的prev_len1字节，engry实际占用（1+1+4+8=14）14字节。实际分配16字节。（内存对齐）而使用String的时候，一个distEntry就需要占用32字节。（List、Hash和Sorted Set都使用了ziplist）

虽然ziplist和String的entry结构的占用区别很大，ziplist仅占用16字节，而string则需要32字节。但是如何使用ziplist且能够做到一一对应呢？

#### 如何用集合类型保持单值的键值对？

在保存单值键值对时，可以采用基于Hash类型的二级编码方式。即把一个单值的数据拆分为两部分，前一部分作为集合的key，后一部分作为Hash集合的value，这样就可以把单值数据保存到Hash集合中。

如把图片ID前7位作为Hash类型的键，后3位和图片储存对象ID分别作为Hash类型的key和value。

```bash
# 使用字符串设置
set 1101000051 3301000051
get 1101000051

# 使用hash设置
hset 1101000 051 3301000051
hget 1101000 051
```

才采用二级编码的时候，ID长度是由讲究的。

Redis Hash类型有两种底层实现结构，分别是压缩列表和哈希表。

Hash类型设置了用压缩列表保存数据的两个阈值，当超过阈值，Hash类型将会用哈希表来保存数据。分别对应：

+ hash-max-ziplist-entries：表示用压缩列表保存时哈希表集合中的最大元素个数。
+ hash-max-ziplist-value：表示用压缩类列表保存时哈希表中单个元素的最大长度。

当往Hash集合中写入元素个数超过hash-max-ziplist-entries或写入的单个元素超过hash-max-ziplist-value，Redis就会自动把Hash类型的实现结构由压缩列表转为哈希表，而转换为哈希表之后，在节省内存方面，将没有压缩列表那么高效。

**为了充分使用压缩列表的精简内存布局，一般控制保存在Hash集合中的元素个数。**

因此，在刚才的二级编码中，只用图片ID最后3位作为Hash集合的key，也就保证了集合元素个数不超过1000，同时，可以报hash-max-ziplist-entries设置为1000，这样就可以一直使用压缩列表来节省内存空间。

#### 总结

String虽然可以使用在很多场景，但是并不“适用”所有这些场景。在保存的键值本身的占用空间不大的时候，String元数据可能会占用较多的空间，成为开销的主导，其中包含了RedisObject、distEntry、SDS结构等。

针对这种情况，可以使用压缩列表来保存数据。需要注意的是，使用Redis Hash类型储存数据的时候，需要将数据拆分为两部分，即采用二级编码。

#### 评论区补充

保存图片的例子，除了用String和Hash存储之外，还可以用Sorted Set存储（勉强）。

Sorted Set与Hash类似，当元素数量少于zset-max-ziplist-entries，并且每个元素内存占用小于zset-max-ziplist-value时，默认也采用ziplist结构存储。我们可以把zset-max-ziplist-entries参数设置为1000，这样Sorted Set默认就会使用ziplist存储了，member和score也会紧凑排列存储，可以节省内存空间。

使用zadd 1101000 3302000080 060命令存储图片ID和对象ID的映射关系，查询时使用zscore 1101000 060获取结果。

但是Sorted Set使用ziplist存储时的缺点是，这个ziplist是需要按照score排序的（为了方便zrange和zrevrange命令的使用），所以在插入一个元素时，需要先根据score找到对应的位置，然后把member和score插入进去，这也意味着Sorted Set插入元素的性能没有Hash高（这也是前面说勉强能用Sorte Set存储的原因）。而Hash在插入元素时，只需要将新的元素插入到ziplist的尾部即可，不需要定位到指定位置。

不管是使用Hash还是Sorted Set，当采用ziplist方式存储时，虽然可以节省内存空间，但是在查询指定元素时，都要遍历整个ziplist，找到指定的元素。所以使用ziplist方式存储时，虽然可以利用CPU高速缓存，但也不适合存储过多的数据（hash-max-ziplist-entries和zset-max-ziplist-entries不宜设置过大），否则查询性能就会下降比较厉害。整体来说，这样的方案就是时间换空间，我们需要权衡使用。

当使用ziplist存储时，我们尽量存储int数据，ziplist在设计时每个entry都进行了优化，针对要存储的数据，会尽量选择占用内存小的方式存储（整数比字符串在存储时占用内存更小），这也有利于我们节省Redis的内存。还有，因为ziplist是每个元素紧凑排列，而且每个元素存储了上一个元素的长度，所以当修改其中一个元素超过一定大小时，会引发多个元素的级联调整（前面一个元素发生大的变动，后面的元素都要重新排列位置，重新分配内存），这也会引发性能问题，需要注意。

另外，使用Hash和Sorted Set存储时，虽然节省了内存空间，但是设置过期变得困难（无法控制每个元素的过期，只能整个key设置过期，或者业务层单独维护每个元素过期删除的逻辑，但比较复杂）。而使用String虽然占用内存多，但是每个key都可以单独设置过期时间，还可以设置maxmemory和淘汰策略，以这种方式控制整个实例的内存上限。

所以在选用Hash和Sorted Set存储时，意味着把Redis当做数据库使用，这样就需要务必保证Redis的可靠性（做好备份、主从副本），防止实例宕机引发数据丢失的风险。而采用String存储时，可以把Redis当做缓存使用，每个key设置过期时间，同时设置maxmemory和淘汰策略，控制整个实例的内存上限，这种方案需要在数据库层（例如MySQL）也存储一份映射关系，当Redis中的缓存过期或被淘汰时，需要从数据库中重新查询重建缓存，同时需要保证数据库和缓存的一致性，这些逻辑也需要编写业务代码实现。

总之，各有利弊，我们需要根据实际场景进行选择。

## 集合

#### 概述

Web 和移动应用常常遇到这种场景，一个key对应一个数据集合：

+ 设计APP中每天用户登录信息：一天对应一系列用户id或移动设备id
+ 电商网站上商品的用户评论列表：一个商品对应一系列评论
+ 用户在手机APP上的签到打开信息：一天对应一系列用户的签到记录
+ 应用网站上的网页访问信息：一个网页对一系列的访问点击

Redis 集合类型就是一个键对应一系列数据，因此非常适合储存上述的数据。但是在上述的场景中，除了要记录信息，往往还需要对集合中的数据进行统计，如：

+ 移动应用需要统计每天新增用户以及第二天用户留存数；
+ 在电商网站的商品评论中，需要统计评论列表中的最新评论；
+ 在签到打开中，需要统计一个月连续打开的用户数；
+ 在网页访问记录中，需要统计独访客（Unique Visitor）量。

通常情况下，上述场景的用户量是巨大的，如百万、千万、甚至亿级。因此需要选择非常高效统计大量数据的集合类型。

**为了能够选择合适的集合，需要了解常用的集合统计模式。**集合类型常见的统计模式主要有四种，包括聚合统计、排序统计、二值状态统计和基数统计。

#### 聚合统计

聚合统计，统计多个集和元素的聚合结果，包括：统计多个集合的共有元素（交集统计）；把两个集合相比，统计其中一个集合独有的元素（差集统计）；统计多集合的所有元素（并集统计）。

上述提到的业务场景中，统计APP每天新增用户和第二天流程用户数，正好对应聚合统计。

为了完成上述的任务，使用两个集合：

**集合一：保存所有登录过APP的用户ID**【使用Set类型】（累积用户Set）

+ key：`user:id`
+ value：Set集合，保存登录过的用户id

需要注意累积用户Set并没有记录日期，因此不能根据它来统计每天的新增用户。

**集合二：保存当天登录过的APP的用户ID**【使用Set类型】（每日用户Set）

+ key：`user:id:{date}`
+ value：Set结合，保存当天登录用户id

基于上述两个集合，如果统计每日新增的用户数，将集合一和集合二求差集即可：

+ 使用SDIFFSTORE命令将集合一（累积用户Set）和集合二（当天用户Set）求出差值，就是每日新增用户数
+ 使用SUNIONSTORE命令将集合一和集合二求并集并将结果保存在集合一中

同需要统计用户留存率，将两天的集合二求交集即可：

+ 使用SINTERSTORE命令将两天的集合二球交集

例子如下：

```bash
## 在user:id中记录所有用户记录
sadd user:id 1 2 3 5 7 8 9

## 在user:id:{date}中记录当天访问用户
sadd user:id:20210621 1 2 3 4 6
sadd user:id:20210622 1 3 4 8 9

## 统计当天新增用户【注意两者的顺序不能反】
sdiffstore user:new user:id:20210621 user:id

## 统计客户留存率
sinterstore user:id:rem user:id:20210622 user:id:20210621
```

需要注意的是，Set的并、交、差集的时间复杂度比较高，在数据量比较大的情况下，直接执行这些计算会导致Redis实例阻塞。在实际环境中，可以在主从集群中选择一个从库，让它专门负责聚合计算，或者把数据读到客户端，通过客户端来完成聚合统计。

#### 排序统计

在电商网站中，往往需要提供最新的评论列表，其中需要包含所有评论中的最新留言，这就要求集合类型能对元素保证有序性。

在Redis 的这四种集合类型中，List 和 Sorted Set 属于有序集合。其中 List 是按照元素插入顺序排序，而Sorted Set可以根据元素的权重排序。

但需要只有的是，在使用 List 的时候，如果使用分页查询 List 可能会存问题，`lrange key start stop  ` 使用的是start和stop，而在用户插入新数据的时候，将会导致查到前面数据。

与List相比，Sorted Set 就不存在这种问题，因为它是根据元素的权重来排序和获取数据的。可以根据评论的时间先后给每条评论设置一个权重值，然后再把评论保存到Sorted Set 中。Sorted Set 的 ZRANGEBYSCORE 命令就可以按权重排序返回元素。这样即使集合中的元素频繁更新，Sorted Set 也能通过 ZRANGEBYSCORE 命令准确地获取按序排列的数据。

因此在面对展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页展示，建议优先考虑Sorted Set。

#### 二值统计

二值统计，也称二值状态统计。此处的二值状态是指集合取值就只有0和1两种。如在签到打开的场景中，只有签到（1）和未签到（0），是典型的二值状态。

在签到统计的时候，每个用户一天的签到用1个bit就能表示，一个月的签到用31个bit就可以，而一年的签到只需要365个bit，不需要太复杂的集合类型。这时候，可以使用Bitmap。

Bitmap是 Redis 中一种扩展的数据类型，底层通过 String 实现。由于 String 是二进制安全的，因此可以用于保存二进制的字节数组，因此 Redis 包字符串的每一个位利用起来，用来表示一个元素的二值状态，因此可以把Bitmap看做一个bit数组。

Bitmap 提供了 GETBIT/SETBIT 操作，使用一个偏移值 offset 对 bit 数组的某一个 bit 位进行读和写。但是需要注意的是，Bitmap的偏移量是从0考试的，即offset的小值是0。当使用SETBIT对一个bit位进行写操作的时候，这个bit会被设置为1。Bitmap还提供了BITCOUNT操作，用来统计这个bit数组中所有“1”的个数。

下面是使用Bitmap来记录用户的签到情况：

```bash
## id为3000用户在2021年6月3号签到
local:0>setbit uid:sign:3000:202106 2 1

## id为3000用户在2021年6月4号签到
local:0>setbit uid:sign:3000:202106 3 1

## id为3000用户在2021年6月6号签到
local:0>setbit uid:sign:3000:202106 5 1

## 查看id为3000用户在2021年6月5号是否签到
local:0>getbit uid:sign:3000:202106 4

## 统计id为3000用户在2021年6月的签到次数
local:0>bitcount uid:sign:3000:202106
```

Bitmap还提供了BITOP命令来支持将Bitmap按为进行“与”、“或”、“异或”操作，操作的结果保存在一个新的Bitmap中。

加入要统计1亿用户10天的连续签到情况，就可以考虑每一天使用一个Bitmap，长度为1亿。之后将这个十个Bitmap采用“与”运算，最终使用BITCOUNT命令就可以统计出10天内连续签到的用户数。其中占用的内存只需要大约10*10^8bit = 120MB内存，内存压力不算大。但是需要注意的是需要为这些数据设置过期时间，以免长期占用内存。

从上面可以看出，在二值统计的场景中，可以考虑使用Bitmap，因为它只需要使用1个bit就可以表示0或1。在海量数据时，可以有效的节省内存。

#### 基数统计

基数统计指的是统计一个集合中不重复元素个数。对应于上面的场景就是统计网页的UV。

在统计网页UV时，需要对同一用户的访问进行去重，而Redis集合类型中，Set类型默认支持去重，在需要去重时可以优先考虑使用Set。

Set 提供了 SCAED命令来获取集合中元素个数。

但是在使用Set统计UV时，如果这个页面的访问量很大，超过了千万级别。这时一个页面的Set就需要记录千万个用户的ID。对于较大规模的商城，这样的页面可能有成千上万个，如果每个页面都用一个Set，将会花费很大的内存空间。

处理用Set统计UV，Hash也可以实现类似的效果（Java的HashSet底层采用了HashMap），原理并不难，此处不再展开。但是和Set统计的时候类似，Hash统计也存在较大内存浪费。

这是较好的解决方案可能就是使用Redis提供的HyperLogLog。

HyperLogLog是一种用于统计技术的数据集合类型，它的最大优势在于，但集合元素数量非常多的时候，它计算计算需要的空间总是固定的，而且空间很小。

在Redis中，每个HyperLogLog只需要花费12KB内存就可以计算接近2^64个元素是基数。

```bash
## 使用pfadd命令为某个页面添加UV
local:0>pfadd page1 user1 user2 user3 user user432 usera asdfas

## 使用pfcount统计某个有页面的UV
local:0>pfcount page1

```

使用HyperLogLog的时候需要注意，HyperLogLog并不是精确值，给出的统计是存在误差的，误算率为0.81%。

+ [HyperLogLog原理](http://antirez.com/news/75)

#### 总结

![image-20210621152058783](https://gitee.com/tobing/imagebed/raw/master/image-20210621152058783.png)

#### 评论区补充

使用Sorted Set可以实现统计一段时间内的在线用户数：用户上线时使用zadd online_users $timestamp $user_id把用户添加到Sorted Set中，使用zcount online_users $start_timestamp $end_timestamp就可以得出指定时间段内的在线用户数。

如果key是以天划分的，还可以执行zinterstore online_users_tmp 2 online_users\_{date1} online_users_{date2} aggregate max，把结果存储到online_users_tmp中，然后通过zrange online_users_tmp 0 -1 withscores就可以得到这2天都在线过的用户，并且score就是这些用户最近一次的上线时间。

还有一个有意思的方式，使用Set记录数据，再使用zunionstore命令求并集。例如sadd user1 apple orange banana、sadd user2 apple banana peach记录2个用户喜欢的水果，使用zunionstore fruits_union 2 user1 user2把结果存储到fruits_union这个key中，zrange fruits_union 0 -1 withscores可以得出每种水果被喜欢的次数。

使用HyperLogLog计算UV时，补充一点，还可以使用pfcount page1:uv page2:uv page3:uv或pfmerge page_union:uv page1:uv page2:uv page3:uv得出3个页面的UV总和。

另外，需要指出老师文章描述不严谨的地方：“Set数据类型，使用SUNIONSTORE、SDIFFSTORE、SINTERSTORE做并集、差集、交集时，选择一个从库进行聚合计算”。这3个命令都会在Redis中生成一个新key，而从库默认是readonly不可写的，所以这些命令只能在主库使用。想在从库上操作，可以使用SUNION、SDIFF、SINTER，这些命令可以计算出结果，但不会生成新key。

最后需要提醒一下：

1、如果是在集群模式使用多个key聚合计算的命令，一定要注意，因为这些key可能分布在不同的实例上，多个实例之间是无法做聚合运算的，这样操作可能会直接报错或者得到的结果是错误的！

2、当数据量非常大时，使用这些统计命令，因为复杂度较高，可能会有阻塞Redis的风险，建议把这些统计数据与在线业务数据拆分开，实例单独部署，防止在做统计操作时影响到在线业务。

## Geo

#### 概述

除了常见的5种数据类型，Redis还提供了3中扩展数据类型来应对一些特殊的场景，分别是Bitmap、HyperLogLog和GEO。

#### 面向LBS的GEO数据类型

日常生活中常常需要用到“附近的餐馆”、在打车软件上叫车，这些都离不开LBS（Location-based Service，位置信息服务）的应用。LBS应用访问的数据就是和人或物关联的一组经纬度信息，而要能查询相邻的经纬度反问，GEO就非常实用应用在LBS访问的场景中。

#### GEO底层结构

一般而言，在设计一个数据类型的底层结构时，首先要知道，要处理的数据有什么访问特征。

对于GEO类型，以叫车服务为例，分析LBS应用中经纬度的存取特点。

1. 每辆网约车有一个编号，网约车将自己的经纬度信息发送给叫车应用
2. 用户在叫车的时候，叫车应用获取用户的经纬度信息
3. 有了车辆的经纬度信息以及用户的经纬度信息就可以实现查找用户附近的车辆
4. 匹配到最近或较近的用户以及车辆之后，就会把这些数据返回给用户和车辆司机

从上面可以看到，我们只需要一个编号（key）和一个经纬度信息（value）就能将一个信息保存起来。如果需要保存一些系列这种类型的数据，只需要使用Hash集合即可。

显然使用Hash来保存和更新编号的经纬度信息是可行的，但是如果LBS中往往涉及范围查询，这是要保证元素的有序性来保证查询高效性，而Hash是无序的，这显然不能满足LBS需求。

说到映射，不得不提到Sorted Set，Sorted Set 支持将一个数据绑定一个double的score。但是经纬度信息是二元的数据，无法直接由一个double来保存。

