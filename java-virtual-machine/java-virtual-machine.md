# Java-Virtual-Machine

日常的Java开发中，我们使用JDK提供的javac工具，对编写的源代码进行编译生成class文件，然后使用java工具，执行class文件。

在使用[java](https://docs.oracle.com/en/java/javase/13/docs/specs/man/java.html)工具时，它会启动Java虚拟机来加载指定的类，并执行类的main方法来执行程序。

## 类文件结构

我们常说，Java时一门跨平台的编程语言。在使用Java来编写程序的时候，我们使用编译工具生成的是与平台无关的class字节码文件，它运行在Java虚拟机之上，不通过平台运行着不同的Java虚拟机的示例。正是借助字节码文件，可以实现「一次编译，随处运行」特点。

Java虚拟机在执行字节码文件是，并不会关心字节码文件是否由Java语言编写编译得到的，只要符合《Java虚拟机规范》中定义的字节码文件格式，都可以运行与Java虚拟机之上。

### Class文件结构

《Java虚拟机规范》中定义的Class文件格式主要由以下几部分组成：

+ **magic：魔数**。固定为0xCAFFBABE，确定文件是否为虚拟机结束的Class文件
+ **minor_version：次版本号**。JDK1.2~JDK12，全部固定为0
+ **major_version：主版本号**。编译该类文件的JDK版本，用于向下兼容校验，虚拟机会拒执行超过其版本号的Class文件
+ **constant_pool_count：常量池容量计数值**。从1开始，0用于表示「不引用任何一个常量池项目」
+ **constant_pool：常量池**。主要存放两大类常量：字面量和符号引用
  + 字面量：Java语言层面的常量，如文本字符串、声明为final的常量值等。
  + 符号引用：Class文件不会保存各个方法、字段最终的内存布局。虚拟机做类加载时， 将会从常量池获得对应的符号引用， 再在类创建时或运行时解析、 翻译到具体的内存地址之中。
    + 模块导入或开放的包
    + 类和接口的全限定名
    + 字段名称和标识符
    + 方法名称和描述符
    + 方法句柄和方法类型
    + 动态调用点和动态常量
+ **access_flags：访问标志**。识别类或接口层次的访问信息（是否class/interface/public/abstract/final等）
+ **this_class：类索引**。确定类的全限定类名
+ **super_class：父类索引**。确定该类父类的全限定类名，只要一个
+ **interfaces_count：接口索引计数**。
+ **interfaces：接口索引**。按照implements后顺序从左到右排序
+ **fields_count：字段表集合容量计数**。
+ **fields：字段表集合**。描述接接口或类中声明的变量，包含类和实例变量，不包含方法内局部变量。一个字段可以包含以下信息
  + 作用域：public、private、protected
  + 实例变量/类变量(static修饰)
  + 可变性(final)
  + 并发可见性(volatile)
  + 是否可序列化(transient)
  + 字段类型：基本类型、对象、数组
+ **methods_count：方法表集合容量计数**。
+ **methods：方法表集合**。存储方法的描述，包含访问标志、名称索引、描述符索引、属性表集合。方法内的字节码指令不在方法表集合，而在属性表集合的Code属性。
+ **attributes_count：属性表集合容量计数**。
+ **attributes：属性表集合**。Class文件、 字段表、 方法表都可以携带自己的属性表集合， 以描述某些场景专有的信息。
  + Code：方法表中Java代码编译生成的字节码指令
  + ConstantValue：字段表中final关键字定义的常量值
  + Deprecated：类、方法表、字段表中被声明为deprecated的方法和字段
  + Exceptions：方法抛出的异常列表
  + EnclosingMethod：局部类或匿名类所在的外围方法
  + InnerClasses：内部类列表
  + LineNumberTable：Java源码的行号与字节码指令对应关系
  + LocalVariableTable：方法的局部变量描述
  + StackMapTable：检查和处理目标方法的局部变量和操作数栈所需要类型是否匹配
  + Signature：支持泛型情况下的方法签名。
  + SourceFile：源文件名称。
  + SourceDebugExtension：储存额外调试信息。
  + LocalVariableTypeTable：支持泛型。

> 补充1：简单名称、全限定名、描述符

+ 简单名称：没有制定类型和参数叙事的方法或字段名称
+ 描述符：模式字段数据类型、方法的参数列表(包含数量、类型以及顺序)和返回值
+ 全限定名：类全面中包「.」替换为「/」，用「;」分割多个全限定类名

基本数据类型(byte/char/double/float/int/long/short/boolean)以及无返回值(void)类型使用大写字符表示。数组类型在每个维度前使用前置「[」描述，如`java.lang.String[][]`表示为`[[Ljava/lang/String;`。

> 补充2：字段表集合

字段表集合不会列出从父类或父接口中继承而来的字段，但有可能出现Java代码不存在的字段，编译器会自动在内部类中添加执行外部类实例的字段，来保持外部类的访问性。

Java语言中字段无法重载，遵从名称唯一；对于Class文件格式，遵从描述符唯一。

> 补充2：方法表集合

父类中没有被子类重写的方法不会出现在方法表集合中，但有可能出现编译器自动添加的方法，如类构造器方法`<clinit>`方法实例构造器`cinit`方法。

重载要求方法有相同的方法名和有不同的方法签名：Java代码的方法签名只包含方法名称、参数顺序以及参数类型，注意没有返回值类型。

> 补充3：泛型支持-Signature

JDK 5新增，可选定长属性。在JDK 5里面大幅增强了Java语言的语法， 在此之后， 任何类、 接口、 初始化方法或成员的泛型签名如果包含了类型变量或参数化类型 ，则Signature属性会为它记录泛型签名信息。

之所以要专门使用这样一个属性去记录泛型类型， 是因为Java语言的泛型采用的是擦除法实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。

使用擦除法的好处是实现简单（主要修改javac编译器， 虚拟机内部只做了很少的改动)、 非常容易实现向后兼容，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取的泛型类型，最终的数据来源也是这个属性。 

> 补充4：注解支持-

JDK 5中，Java语法进行了多项增强，其中包含了提供对注解的支持。为了储存源码中的注解信息，Class文件增加了RuntimeVisibleAnnotations、RuntimeInvisibleAnnotations、 RuntimeVisibleParameterAnnotations和RuntimeInvisibleParameterAnnotations四个属性。

### 字节码指令

Java虚拟机的指令长度为一个字节，由操作码与操作数(可选)构成。Java虚拟机是面向操作数栈而不是面向寄存器的，因此大多数指令都不包含操作数。

Java虚拟机解析器在解析操作码时，执行模型如下：

```java
do {
	自动计算寄存器的值加1;
	根据PC寄存器指示的位置，从字节码流中取出操作数码;
	if (字节码存在操作数) 从字节码流中取出操作数;
	执行操作码定义的操作;
} while (字节码流长度 > 0)
```

在Java虚拟机的指令集中，并非每种数据类型和每一种操作都有对应指令。如大部分指令都没有支持`byte`、`char`和`short`，甚至没有支持`boolean`类型。编译器会在运行期将`byte`和`short`类型的数据带符号扩展为`int`，将`boolean`和`char`零位扩展为相应的`int`类型。

字节码按照功能可以分为9类。

+ 加载和存储指令：用于将数据从栈帧中的局部变量表和操作数栈之间进行传输

+ 运算指令：用于对两个操作树栈的值就行特定的运算，并把结果重新存入操作数栈顶

+ 类型转换指令：可以将不同的数值类型相互转换，这些转换一般用于是实现用户代码的显示类型转换

  + 宽化类型转换：int=>long/flaot/double、long=>float/double、float=>double，自动
  + 窄化类型转换：除了上的情况，其他必须显式使用转换指令，可能会存在精度丢失问题

+ 对象创建和访问指令：Java虚拟机把对类实例和数组的创建与操作使用不同的字节码指令

  + 类实例相关：new/getfield/putfield/getstatic/pustatic/instanceof/checkcast
  + 数组相关：newarray/anewarray/multinewarray/\<x\>aload/\<x\>astore/arrarylength

+ 操作数栈管理指令：操作操作数栈和操作普通栈类似，如pop/pop2/dup/dup2等

+ 控制转移指令：可以让Java虚拟机有条件或无条件地从指定位置指令的下一条指令继续执行程序（可以认为控制指令就是在有条件或无条件修改PC寄存器的值）

  + 条件分支：ifeq/iflt/ifle/ifne/ifnull/ifnonnull/if_icmpeq等
  + 符合条件分支：tableswitch/looupswitch
  + 无条件分支：goto/goto_w/jsr/jsr_w/ret

+ 方法调用和返回指令

  + invokevirutal：调用实例方法，根据对象实际类型分派
  + invokeinterface：调用接口方法，运行时搜索实现该接口方法的对象，找出方法调用
  + invokespecial：调用需要特殊处理的实例方法，如实例初始化方法、私有方法和父类方法
  + invokestatic：调用静态方法
  + invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法。（与上面对比）

+ 异常处理指令：Java程序中显式抛出异常操作都由athrow指令完成。

  + 异常表：Java虚拟机中，处理异常不是由字节码指令来完成，而是采用异常表完成

+ 同步指令：用于支持方法级和方法内部一段指令序列的同步，同步结构是使用Monitor实现

  + 方法级同步是隐级的，无需通过字节码指令控制，其实现在方法调用和返回操作之中
  + 虚拟机会从方法常量池中的方法表结构ACC_SYNCHRONIZED判断方法是否同步
  + 在方法调用时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否被设置
  + 如果同步方法执行期间抛出异常，而且方法内无处理，同步方法持有的管程会在异常抛出到同步方法外界时自动释放
  + Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义


## 类的加载

我们使用的javac编译得到的Class文件描述了各类的信息，这些信息最终需要加载到虚拟机中才能被运行和使用。

Java虚拟机中类加载器负责把类描述文件加载到内存中，并对数据进行校验、转换解析和初始化，最终形成被虚拟机直接使用的Java类型。

### 类的加载过程

一个类型从加载到虚拟机内存中，到卸载出内存为止，整个生命周期会经历七个阶段。

+ 加载：获取二进制字节流，将静态储存结构转换为方法区运行时数据，内存中生成反映该类的java.lang.Class对象
+ 验证：确保Class文件字节流中包含的信息符合《Java虚拟机规范》的全部约束，保证这些信息被当做代码运行后不会危害虚拟机自身安全。主要会有四阶段校验：
  + 文件格式校验：魔数、主次版本号、常量池常量类型、指向常量池的索引、UTF-8编码等【保证字节流能够正确解析到方法区之内，后继阶段基于方法区存储结构，不会直接读取、操作字节流】
  + 元数据校验：语义分析，保证描述信息系符合要求。包含是否有父类、父类是否可以被继承、是否实现父类或接口要求实现的方法(非抽象类)【对元数据进行语义校验】
  + 字节码校验：通过数据流和控制流分析，确定程序语义合法性、合逻辑性
  + 符号引用校验：将符合引用转换为直接引用时，判断类是否确实或禁止访问它依赖的某些外部类、方法、字段等资源。如全限定类名是否能够定位类、指定类是否存在符合方法字段描述的方法和字段、访问性等。
+ 准备：为类中定义的变量(不包含实例变量)分配内存(方法区)设置初始值。
+ 解析：将常量池的符号引用替换为直接引用。对同一个符号引用进行多次解析很常见，因此虚拟机通常会对解析进行缓存，从而避免重复解析。(invokedynamaic除外)
+ 初始化：Java虚拟机真正开始执行类中编写的Java程序代码，执行类构造器`<clinit>()`方法的过程。而上述阶段除了类加载阶段可以通过自定义类加载器的方式进行局部参与，其他动作都是由Java虚拟来主导的。
+ 使用
+ 卸载

> 加载、验证、准备、初始化、卸载的顺序是确定的，解析阶段则不一定

> 补充1：数组类的加载

对于非数组类的加载，既可以Java虚拟机内置的引导类加载器，也可以使用用自定义的类加载器。用户可以同定义自己的类加载器来字节流的获取方式。

对于数组类，它本身不通过类加载器创建，而是由Java虚拟机直接在内存中动态构建，但是数据的元素类型仍然需要通过类加载器来加载。

数组类的创建遵循以下规则：

+ 如果数组的组件类型是引用类型，递归采用此处定义的加载过程来加载这个组件类型，数组会被标识在加载该组件类型的类加载器的类名称空间；
+ 如果数据类型不是引用类型，Java迅疾把数据标记为引导类加载器关联；
+ 数组类的可访问性与组件类型的可访问性一致，如果组件类型不是引用类型，数组类可访问性将默认为public

> 补充2：数组的元素类型与组件类型

元素类型指的是数组去掉所有维度的类型；组件类型指的是数组去掉一个维度的类型。

> 补充3：验证阶段的字节码校验

校验阶段需要通过数据流分析和逻辑流分析程序语义合法。由于数据流分析和控制流分析的高度复杂性， Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中， 在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化， 把尽可能多的校验辅助措施挪到Javac编译器里进行。 具体做法是给方法体Code属性的属性表中新增加了一项名为“StackMapTable”的新属性。

> 补充4：符合引用与直接引用

符号引用：用一组符号描述引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位目标即可。与虚拟机实现的内存布局无关，引用的目标不一定是已经记载到虚拟机的内容。

直接引用：可以是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。与虚拟机实现的内存布局相关，同一个符合引用在不同虚拟机实例翻译得到的直接引用一般不相同。有了直接引用，则表示其引用的对象一定在虚拟机内存中。

> 补充5：解析的详细过程

解析过程中，主要是将常量池中的符合引用转换为直接引用，转换的对象包含了接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

+ 类和接口的解析：如果不是数组类型，要解析类的全限定类名传递到类加载器进行加载，这个期间可能又会触发其他类的加载，一旦出现异常，解析工作就全部失败；如果是数组类型且元素类型，按非数组类型的方式来加载元素类型，紧接着虚拟机生成一个代表该数组维度和元素的数组对象；如果这两步都没有问题，虚拟机实际上已经生成了该类或接口。
+ 字段解析：解析一个未解析的字段符号引用，会先将字段所属类或接口的符号引用进行解析。
+ 方法解析：和字段解析类似，先将方法所属的类的符号引用进行解析。
+ 接口方法解析：和上述类似。

> 补充6：`clinit<>()`

`clinit<>()`方法是由javac编译器自动收集类中所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的，编译器的收集顺序由语句在源文件中出现的顺序决定。静态语句块只能访问到定义在静态语句块前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

`clinit<>()`方法与类的构造器(即`init<>()`方法)不同，它不需要显式调用父类构造器，Java虚拟机会保证子类的`clinit<>()`方法执行前，父类的`clinit<>()`方法已经执行完毕。因此在Java虚拟机中，第一个被执行`clinit<>()`方法的类型肯定是java.lang.Object。

`clinit<>()`方法对于接口或类而言不是必须的，如果一个类中没有静态语句块，有没有对变量的赋值操作，编译器不会生成该方法。

接口中不能有静态语句块，但仍然有变量初始化的赋值操作，因此接口和类会生成`clinit<>()`方法。但与类不同，执行接口的`clinit<>()`方法不需要先执行父接口的`clinit<>()`方法。因为只有当父接口中的定义的变量被使用时，父接口才会被初始化。

Java虚拟机会保证一个类的`clinit<>()`方法会在多线程环境下正确地被加锁同步。

> 补充7：《Java虚拟机规范》规定6种类必须立即初始化的场景

1. 遇到new/getstatic/putstaic/inovkestatic四条字节码指令，常见的代码场景有：
   + 数据
   + 读取或设置一个类型的静态字段(被final修饰、已在编译器把结果放到常量池的静态字段除外)
   + 调用一个类型的静态方法
2. 使用java.lang.reflect包的方法对类型进行反射调用时。
3. 初始化类时，如果发现父类没有进行初始化，先触发父类的初始化。
4. 启动虚拟机时，用户需要制定要执行的主类，虚拟机会先初始化这个类。
5. JDK7引入的动态语言支持....
6. JDK8加入的接口默认方法，如果具有默认方法接口实现类发生初始化，该接口需要先初始化

> 补充8：不必立即初始化的特殊场景

1. 通过子类引用父类定义的静态字段，只会触发父类的初始化，不会触发子类的初始化
2. 数组的初始化不会导致其原始类型初始化，只会导致虚拟机自动生成数组类初始化
3. 常量的使用不会导致常量所在类被初始化

### 类加载器

在类的加载阶段，允许让应用程序自定义类加载器来获取所需的类。

除了实现类的加载，类加载器还与类本身一起确认类在Java虚拟机的唯一性。

唯一性包含了Class对象的equals方法、isAssignableFrom方法、isInstance方法的返回结果。

从Java虚拟机角度，只存在两种不同的类加载器。

+ 启动类加载器：C++实现，虚拟机自身一部分
+ 其他类加载器：Java实现，独立存在于虚拟机外部，全部继承自java.lang.ClassLoader

从JDK1.2，Java一致保存三层类加载器、双亲委派的类加载器架构。

+ 启动类加载器：负责加载「JAVA_HOME\bin」目录，且是Java虚拟机能够识别的类库到虚拟机内存中。C++实现，无法直接引用
+ 扩展类加载器：负责加载「JAVA_HOME\lib\ext」目录，或java.ext.dirs系统环境变量指定路径的所有类库。Java实现，可以直接引用
+ 系统/应用程序类加载器：负责加载用户类路径上所有类库(CLASSPATH，[默认为当前目录](https://docs.oracle.com/javase/tutorial/essential/environment/paths.html))

JDK 9之前的Java应用都是由这三种加载器通过双亲委派机制的方式来相互协作完成加载。除此之外，用户可以通过加入自定义加载器进行扩展。

> 补充1：双亲委派模型

如果一个类的加载器收到了类加载的请求，首先不会自己尝试加载这类，而是把这个请求交给父类，每一层的类加载器都是如此，因此所有的加载请求最终都会传递到顶层的类加载器，只有当父类加载器反馈自己无法完成这个类的请求时(它的搜索范围没有找到所需类)，子加载器才会阐述自己完成加载。

通过使用双亲委派模型来组织类加载器之间的关系，可以让Java中的类和对应的类加载器有优先的层次关系。如对于lang包下的类，存放与rt.jar包下，无论是哪个类加载器尝试加载这个类，最终都会委派到引导类加载器。这样一来就能保证无论哪个类加载器尝试加载的lang包下的类，得到的都是同一个类(类加载器+类决定类的唯一性)。

如果不使用双亲委派模型，有各个类加载器自行加载，容易造成混乱。

因此双亲委派模型可以保证Java程序的稳定运行。

> 补充2：破坏双亲委派模型

双亲委派模型是一个建议性模型，并不具有强制性。双亲委派在历史上曾经出现3次较大规模的“被破坏”的情况。

第一次出现在JDK1.2前。双亲委派模型在JDK1.2之前就已经出现，而java.lang.ClassLoader在Java的第一个版本就已经存在。对于已经存在的用户自定义类加载器，考虑到兼容性，设计者在引入双亲委派模型时添加了findClass。在双亲委派具体逻辑中，如果父类加载失败，会调用自己的findClass方法完成加载。这样一来既不会影响用户按照自己的意愿加载类，又可以保证新写出的类加载器符合双亲委派规则。

第二次被破坏是由于其自身缺陷导致。对于SPI服务，JDK只负责定义接口，具体实现时需要调用厂商对应的实现。这就会出现，对于JDK定义的接口由启动类加载器加载(java.sql.Driver)，对于相应的实现则由应用程序类加载器进行加载(如com.mysql.cj.jdbc.Driver)。显然如果不采取一定的策略，父类加载器将访问拿到子类加载器的加载的代码。这就回导致在获取java.sql.Driver实现类时无法获取到相应的实例，这时需要运行父类加载器请求子类加载器完成类的加载，违反了双亲委派模型自下而上的请求方式。

第三次破坏是用户对程序动态性的追求而导致的。「动态性」是指：代码热替换、模块热部署。对于主流动态模块化规范OSGi，它实现模块化热部署的关键在于其自定义的类加载器机制，每个程序模块都有自己的类加载器，当需要更换一个模块时，连同类加载器一起换掉来实现代码的热替换。在OSGi中不使用双亲委派的树形结构，而是发展为网状结构。

[补充阅读](https://www.zhihu.com/question/49667892/answer/690288611)

## 运行时数据区

通过java命令启动虚拟机，对相应的class文件加载、链接、初始化之后，静态的class结构会换转到运行时数据区。

Java虚拟机在执行Java程序过程中会把它管理的内存划分为若干个不同的数据区域。这些区域有不同的功能和声明周期。

《Java虚拟机规范》固定，Java虚拟机管理的内存包含以下结构：

+ **堆**：线程共享，是虚拟机管理内存中最大的一块。唯一目的是**存放对象实例**。绝大多数对象在堆上分配。Java堆中可以划分出多个线程私有的分配缓冲区(TLAB)，来避免线程竞争，提高独享分配效率【垃圾收集器管理的区域，-Xmx与-Xms】
+ **方法区**：线程共享，储存**被虚拟机加载的类型信息、常量、静态变量、即时编译器编译的代码缓存。**【回收条件苛刻，但是有必要】
  + JDK8之前，对于Hot-Spot虚拟机，方法区的实现为永久代（更容易导致内存溢出）
  + JDK8及之后，对于Hot-Spot虚拟机，方法区的实现为元空间（采用本地内存实现）
+ **Java虚拟机栈**：线程私有，每个方法执行时，Java虚拟机都会同步在虚拟机栈中同步创建一个栈帧用于储存局部变量表、操作数栈、动态连接、方法入口等信息。【固定栈-SOE，动态栈-OOM】
+ **本地方法栈**：线程私有，为虚拟机使用本地方法服务。Hot-Spot虚拟机直接将本地方法栈与Java虚拟机栈合并。
+ **程序计数器**：线程私有，当前线程执行的字节码行号指示器。程序计数器可以保证线程切换之后能够恢复到正确的执行位置，因此它是线程私有的。【唯一一处无OOM的区域】

> 补充1：直接内存

直接内存不属于虚拟机运行时数据区，也不是《Java虚拟机规范》定义的内存区域，但是这部分内存被频繁使用，而且可能会导致OOM。

JDK1.4引入了NIO类，它基于通道和缓冲区的I/O方式，可以使用Native函数直接分配堆外内存，之后可以通过一个储存在Java堆中的DirectByteBuffer对象来操作这片堆外内存。在堆外内存可以避免Java对到Native对的数据复制，在一些场景中可以显著提高性能。

直接内存大小 不受Java堆大小限制，但是会受到操作系统内存的大小限制。

### HotSpot堆实现

**对象创建**

Java虚拟机遇到new指令时，首先检查指令参数是否能够在常量池中定位到一条类的符号引用，并检查符号引用代表的类是否已经被加载、解析和初始化过。

类加载检查通过之后，虚拟机为新生对象分配内存。由于对象所需内存在加载完成已经确定，因此只需把一块确定内存从堆中划分出来即可。

+ 如果堆中内存规整，虚拟机可以「对撞指针」将内存分为使用和未使用两部分。
+ 如果堆中内存不规整，虚拟机需要维护「空闲列表」来记录那些内存可用，那些不可用。

堆内存是否规整由垃圾收集器来决定。

+ 如果垃圾收集器具有空间压缩整理功能，则系统采用的分配算法是指针碰撞，简单高效；
+ 如果垃圾收集器是基于清除算法，则系统采用的分配算法是空闲列表法。

对象创建的行为不是原子性的，而且非常频繁，因此在并发环境下需要保证分配内存的线程安全，主要有两种方式。

+ 对为对象分配内存空间这一行为进行同步处理保证原子性。（实际通过CAS+失败重试保证原子性）
+ 使用TLAB，为每个线程在堆中预先分配一小块内存用于内存分配。（类似于线程私有变量避免线程竞争）

内存分配完毕需要将分配的内存空间初始化为零值。如果使用TLAB方式，可以提前值TLAB分配是进行。（这一步保证了对象的**实例字段**可以在不赋初值就可以会直接使用）

初始化之后，还需要对对象进行必要设置，如**对象属于哪个类**、如果获取该类的元数据、对象的哈希码、**对象的GC分代年龄**。（这些信息存储在对象头中）

综上，从Java虚拟机角度，一个新的对象已经产生；但从Java程序角度，对象创建才刚刚开始-`<init>()`尚未执行，其他信息仍未准备好。（一般而言，字节码中的new指令都会在后面跟随invokespecial用于执行`<init>()`方法）

**对象布局**

在堆中创建好的对象可以分为三部分。

+ **对象头**：包含两类信息：Mark Word与类型指针
  + Mark Word：用于储存对象自身运行的数据，如hashCode、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳
  + 类型指针：指向类型元数据，通过它确定属于哪个类。（数组类型无法通过元数据推断数组大小）
+ **实例数据**：程序代码中定义的各种类型的字段内容，包含父类继承而来的。（虚拟默认将宽度相同的分配在一起，在这个前提下，父类出现在子类之前）
+ **对齐填充**：非必须，仅起占位符作用。（保证为8字节的整数倍）

**对象的访问定位**

创建好的对象可以栈上的reference数据来访问，主流的访问方式有两种：

+ **句柄访问**：Java堆中划分一块内存作为句柄池，reference储存的是句柄地址，句柄中包含对象实例数据与类型数据各自具体地址信息
+ **直接指针**：Java堆中对象需要考虑如何放置访问类型数据相关信息，referenc储存的是对象地址

![image-20210817190137166](https://gitee.com/tobing/imagebed/raw/master/image-20210817190137166.png)

> 两种存储方式各有优势。
>
> 使用句柄访问的最大好处是reference中储存的是稳定句柄地址，对象移动时只会改变实例数据指针，而reference本身不会改变；（有利于垃圾回收的对象移动）
>
> 使用会直接指针访问的最大好处是速度更快，节省了异常指针定位的开销。（Hot-Spot采用的对象访问方式。）

## 垃圾收集

### 垃圾收集算法

商业虚拟机的垃圾收集器大多基于「分代收集」设计。分代收集建立在两个分代假设之上：

+ 弱分代假设：绝大多数的对象都是朝生夕死
+ 强分代假说：熬过越多垃圾收集的对象越难消亡

两个分代假说奠定了垃圾收集器的设计原则：**收集器将Java对分出不同区域，将会是对象依照年龄分配到不同的区域中储存**。在Java对分出不同区域之后，垃圾收集器每次只回收一部分区域。

一般而言，<font style="color:red">**至少把Java堆划分为新生代和老年代两个区域**</font>。**新生代**中，每次垃圾收集会有大批对象死去，每次回收后存活的少量对象，将会**逐步晋升代老年代**中存放。

但分代收集存在一个明显的困难：<font style="color:red">**对象不是孤立的，对象之间会存在跨代引用**</font>。

引用存在**跨代引用**，在新生代进行收集时，新生代对象可以被老年代引用，为此在扫描时，需要在规定的GCRoots之外，额外扫描老年代所有对象，确保可达性分析结果是正确的。同样地，老年代也存在同样问题。遍历老年代虽然可行，但是会为内存回收带来很大的性能负担。为了解决这个问题，为分代收集理论添加了第三条经验法则：

+ 跨代引用假说：跨代引用相当于对于同代引用来说仅占少数。

依据上述假说，

<font style="color:red">不应再为少量跨代引用扫描整个老年代。只需在新生代建立全局**Remembered Set**，整个结构把老年代分为若干小块，记录老年代哪一块内存会存在跨代引用。此后发生MinorGC时，只有包含了跨代引用的小块内存中的对象才会被加入GCRoots中扫描。</font>

> 补充1：各种GC

PartialGC：目标不是完整会涉及整个Java堆的垃圾回收，又分为以下GC。

+ MinorGC/YoungGC：新生代垃圾收集；
+ MajorGC/OldGC：老年代垃圾收集。目前只有CMS收集器有单独收集老年代的行为；
+ MixedGC：整个新生代和部分老年代的垃圾收集。目前只有G1收集器有这种行为；
+ FullGC：收集整个Java堆和方法区的垃圾收集。

**标记-清除算法**

标记-清除算法分为「标记」和「清除」两个阶段，先标记出所有需要回收的对象，标记完成之后统一回收。作为最基础的收集算法，它主要有两大缺点：

+ 执行效率不稳定，如果堆中有大量对象且大部分部分需要回收，这时需要进行大量标记和清除动作，标记清除执行效率随着对象增加而降低。
+ 内存空间碎片化，标记、清除之后会有大量不连续的内存碎片。碎片太多会导致无法找到连续的内存来分配大对象将会提前触发垃圾收集操作。

**标记-复制算法**

为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，有人提出了「半区」复制。即将内存划分为两半，每次使用一半，当这一半用完，将存活的对象复制到另外一半，然后把已使用的内存空间进行清理。

如果内存中多数对象都是存活，这种算法会产生大量内存间复制，但对于多数对象可回收，则只需要复制少数对象，且每次都是针对一半内存进行回收，不需要考虑空间碎片问题。

虽然标记复制算法简单、高效，但是浪费的内存也很多。

现代的商用Java虚拟机在**新生代**大多采用标记-复制算法进行垃圾收集，但是并不是按照1:1的比例划分。（基于「新生代中的对象98%熬不过第一轮收集」）

基于朝生夕死的特点，Appel式回收将新生区分为一块较大Eden和两块较小Survivor，每次内存分配只使用Eden和其中一块Survivor。HotSpot虚拟机的Serial、ParNew等新生代垃圾收集器都是基于这个策略来设计新生代内存布局，默认的比例为Eden:Survivor=8:1。

**当Survivor空间不足容纳异常MinorGC之后存活的对象，需要依赖其他内存区域（大多是老年代）进行分配担保。**即如果Survivor空间没有足够的空间存放上一次新生代收集的存活对象时，这些对象会通过担保机制直接居然老年代。（**逃生门**）

**标记-整理算法**

标记-复制算法不适合使用与具有大量存活对象的场景。而对于老年代对象往往存活率高，这是将不再适合使用标记-复制算法。

