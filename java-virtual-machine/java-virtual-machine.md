# Java-Virtual-Machine

日常的Java开发中，我们使用JDK提供的javac工具，对编写的源代码进行编译生成class文件，然后使用java工具，执行class文件。

在使用[java](https://docs.oracle.com/en/java/javase/13/docs/specs/man/java.html)工具时，它会启动Java虚拟机来加载指定的类，并执行类的main方法来执行程序。

## 类文件结构

我们常说，Java时一门跨平台的编程语言。在使用Java来编写程序的时候，我们使用编译工具生成的是与平台无关的class字节码文件，它运行在Java虚拟机之上，不通过平台运行着不同的Java虚拟机的示例。正是借助字节码文件，可以实现「一次编译，随处运行」特点。

Java虚拟机在执行字节码文件是，并不会关心字节码文件是否由Java语言编写编译得到的，只要符合《Java虚拟机规范》中定义的字节码文件格式，都可以运行与Java虚拟机之上。

### Class文件结构

《Java虚拟机规范》中定义的Class文件格式主要由以下几部分组成：

+ **magic：魔数**。固定为0xCAFFBABE，确定文件是否为虚拟机结束的Class文件
+ **minor_version：次版本号**。JDK1.2~JDK12，全部固定为0
+ **major_version：主版本号**。编译该类文件的JDK版本，用于向下兼容校验，虚拟机会拒执行超过其版本号的Class文件
+ **constant_pool_count：常量池容量计数值**。从1开始，0用于表示「不引用任何一个常量池项目」
+ **constant_pool：常量池**。主要存放两大类常量：字面量和符号引用
  + 字面量：Java语言层面的常量，如文本字符串、声明为final的常量值等。
  + 符号引用：Class文件不会保存各个方法、字段最终的内存布局。虚拟机做类加载时， 将会从常量池获得对应的符号引用， 再在类创建时或运行时解析、 翻译到具体的内存地址之中。
    + 模块导入或开放的包
    + 类和接口的全限定名
    + 字段名称和标识符
    + 方法名称和描述符
    + 方法句柄和方法类型
    + 动态调用点和动态常量
+ **access_flags：访问标志**。识别类或接口层次的访问信息（是否class/interface/public/abstract/final等）
+ **this_class：类索引**。确定类的全限定类名
+ **super_class：父类索引**。确定该类父类的全限定类名，只要一个
+ **interfaces_count：接口索引计数**。
+ **interfaces：接口索引**。按照implements后顺序从左到右排序
+ **fields_count：字段表集合容量计数**。
+ **fields：字段表集合**。描述接接口或类中声明的变量，包含类和实例变量，不包含方法内局部变量。一个字段可以包含以下信息
  + 作用域：public、private、protected
  + 实例变量/类变量(static修饰)
  + 可变性(final)
  + 并发可见性(volatile)
  + 是否可序列化(transient)
  + 字段类型：基本类型、对象、数组
+ **methods_count：方法表集合容量计数**。
+ **methods：方法表集合**。存储方法的描述，包含访问标志、名称索引、描述符索引、属性表集合。方法内的字节码指令不在方法表集合，而在属性表集合的Code属性。
+ **attributes_count：属性表集合容量计数**。
+ **attributes：属性表集合**。Class文件、 字段表、 方法表都可以携带自己的属性表集合， 以描述某些场景专有的信息。
  + Code：方法表中Java代码编译生成的字节码指令
  + ConstantValue：字段表中final关键字定义的常量值
  + Deprecated：类、方法表、字段表中被声明为deprecated的方法和字段
  + Exceptions：方法抛出的异常列表
  + EnclosingMethod：局部类或匿名类所在的外围方法
  + InnerClasses：内部类列表
  + LineNumberTable：Java源码的行号与字节码指令对应关系
  + LocalVariableTable：方法的局部变量描述
  + StackMapTable：检查和处理目标方法的局部变量和操作数栈所需要类型是否匹配
  + Signature：支持泛型情况下的方法签名。
  + SourceFile：源文件名称。
  + SourceDebugExtension：储存额外调试信息。
  + LocalVariableTypeTable：支持泛型。

> 补充1：简单名称、全限定名、描述符

+ 简单名称：没有制定类型和参数叙事的方法或字段名称
+ 描述符：模式字段数据类型、方法的参数列表(包含数量、类型以及顺序)和返回值
+ 全限定名：类全面中包「.」替换为「/」，用「;」分割多个全限定类名

基本数据类型(byte/char/double/float/int/long/short/boolean)以及无返回值(void)类型使用大写字符表示。数组类型在每个维度前使用前置「[」描述，如`java.lang.String[][]`表示为`[[Ljava/lang/String;`。

> 补充2：字段表集合

字段表集合不会列出从父类或父接口中继承而来的字段，但有可能出现Java代码不存在的字段，编译器会自动在内部类中添加执行外部类实例的字段，来保持外部类的访问性。

Java语言中字段无法重载，遵从名称唯一；对于Class文件格式，遵从描述符唯一。

> 补充2：方法表集合

父类中没有被子类重写的方法不会出现在方法表集合中，但有可能出现编译器自动添加的方法，如类构造器方法`<clinit>`方法实例构造器`cinit`方法。

重载要求方法有相同的方法名和有不同的方法签名：Java代码的方法签名只包含方法名称、参数顺序以及参数类型，注意没有返回值类型。

> 补充3：泛型支持-Signature

JDK 5新增，可选定长属性。在JDK 5里面大幅增强了Java语言的语法， 在此之后， 任何类、 接口、 初始化方法或成员的泛型签名如果包含了类型变量或参数化类型 ，则Signature属性会为它记录泛型签名信息。

之所以要专门使用这样一个属性去记录泛型类型， 是因为Java语言的泛型采用的是擦除法实现的伪泛型，字节码（Code属性）中所有的泛型信息编译（类型变量、参数化类型）在编译之后都通通被擦除掉。

使用擦除法的好处是实现简单（主要修改javac编译器， 虚拟机内部只做了很少的改动)、 非常容易实现向后兼容，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得泛型信息。Signature属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取的泛型类型，最终的数据来源也是这个属性。 

> 补充4：注解支持-

JDK 5中，Java语法进行了多项增强，其中包含了提供对注解的支持。为了储存源码中的注解信息，Class文件增加了RuntimeVisibleAnnotations、RuntimeInvisibleAnnotations、 RuntimeVisibleParameterAnnotations和RuntimeInvisibleParameterAnnotations四个属性。

### 字节码指令

Java虚拟机的指令长度为一个字节，由操作码与操作数(可选)构成。Java虚拟机是面向操作数栈而不是面向寄存器的，因此大多数指令都不包含操作数。

Java虚拟机解析器在解析操作码时，执行模型如下：

```java
do {
	自动计算寄存器的值加1;
	根据PC寄存器指示的位置，从字节码流中取出操作数码;
	if (字节码存在操作数) 从字节码流中取出操作数;
	执行操作码定义的操作;
} while (字节码流长度 > 0)
```

在Java虚拟机的指令集中，并非每种数据类型和每一种操作都有对应指令。如大部分指令都没有支持`byte`、`char`和`short`，甚至没有支持`boolean`类型。编译器会在运行期将`byte`和`short`类型的数据带符号扩展为`int`，将`boolean`和`char`零位扩展为相应的`int`类型。

字节码按照功能可以分为9类。

+ 加载和存储指令：用于将数据从栈帧中的局部变量表和操作数栈之间进行传输

+ 运算指令：用于对两个操作树栈的值就行特定的运算，并把结果重新存入操作数栈顶

+ 类型转换指令：可以将不同的数值类型相互转换，这些转换一般用于是实现用户代码的显示类型转换

  + 宽化类型转换：int=>long/flaot/double、long=>float/double、float=>double，自动
  + 窄化类型转换：除了上的情况，其他必须显式使用转换指令，可能会存在精度丢失问题

+ 对象创建和访问指令：Java虚拟机把对类实例和数组的创建与操作使用不同的字节码指令

  + 类实例相关：new/getfield/putfield/getstatic/pustatic/instanceof/checkcast
  + 数组相关：newarray/anewarray/multinewarray/\<x\>aload/\<x\>astore/arrarylength

+ 操作数栈管理指令：操作操作数栈和操作普通栈类似，如pop/pop2/dup/dup2等

+ 控制转移指令：可以让Java虚拟机有条件或无条件地从指定位置指令的下一条指令继续执行程序（可以认为控制指令就是在有条件或无条件修改PC寄存器的值）

  + 条件分支：ifeq/iflt/ifle/ifne/ifnull/ifnonnull/if_icmpeq等
  + 符合条件分支：tableswitch/looupswitch
  + 无条件分支：goto/goto_w/jsr/jsr_w/ret

+ 方法调用和返回指令

  + invokevirutal：调用实例方法，根据对象实际类型分派
  + invokeinterface：调用接口方法，运行时搜索实现该接口方法的对象，找出方法调用
  + invokespecial：调用需要特殊处理的实例方法，如实例初始化方法、私有方法和父类方法
  + invokestatic：调用静态方法
  + invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法。（与上面对比）

+ 异常处理指令：Java程序中显式抛出异常操作都由athrow指令完成。

  + 异常表：Java虚拟机中，处理异常不是由字节码指令来完成，而是采用异常表完成

+ 同步指令：用于支持方法级和方法内部一段指令序列的同步，同步结构是使用Monitor实现

  + 方法级同步是隐级的，无需通过字节码指令控制，其实现在方法调用和返回操作之中
  + 虚拟机会从方法常量池中的方法表结构ACC_SYNCHRONIZED判断方法是否同步
  + 在方法调用时，调用指令会检查方法的ACC_SYNCHRONIZED访问标志是否被设置
  + 如果同步方法执行期间抛出异常，而且方法内无处理，同步方法持有的管程会在异常抛出到同步方法外界时自动释放
  + Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义


## 类的加载

我们使用的javac编译得到的Class文件描述了各类的信息，这些信息最终需要加载到虚拟机中才能被运行和使用。

Java虚拟机中类加载器负责把类描述文件加载到内存中，并对数据进行校验、转换解析和初始化，最终形成被虚拟机直接使用的Java类型。

### 类的加载过程

一个类型从加载到虚拟机内存中，到卸载出内存为止，整个生命周期会经历七个阶段。

+ 加载：获取二进制字节流，将静态储存结构转换为方法区运行时数据，内存中生成反映该类的java.lang.Class对象
+ 验证：确保Class文件字节流中包含的信息符合《Java虚拟机规范》的全部约束，保证这些信息被当做代码运行后不会危害虚拟机自身安全。主要会有四阶段校验：
  + 文件格式校验：魔数、主次版本号、常量池常量类型、指向常量池的索引、UTF-8编码等【保证字节流能够正确解析到方法区之内，后继阶段基于方法区存储结构，不会直接读取、操作字节流】
  + 元数据校验：语义分析，保证描述信息系符合要求。包含是否有父类、父类是否可以被继承、是否实现父类或接口要求实现的方法(非抽象类)【对元数据进行语义校验】
  + 字节码校验：通过数据流和控制流分析，确定程序语义合法性、合逻辑性
  + 符号引用校验：将符合引用转换为直接引用时，判断类是否确实或禁止访问它依赖的某些外部类、方法、字段等资源。如全限定类名是否能够定位类、指定类是否存在符合方法字段描述的方法和字段、访问性等。
+ 准备：为类中定义的变量(不包含实例变量)分配内存(方法区)设置初始值。
+ 解析：将常量池的符号引用替换为直接引用。对同一个符号引用进行多次解析很常见，因此虚拟机通常会对解析进行缓存，从而避免重复解析。(invokedynamaic除外)
+ 初始化：Java虚拟机真正开始执行类中编写的Java程序代码，执行类构造器`<clinit>()`方法的过程。而上述阶段除了类加载阶段可以通过自定义类加载器的方式进行局部参与，其他动作都是由Java虚拟来主导的。
+ 使用
+ 卸载

> 加载、验证、准备、初始化、卸载的顺序是确定的，解析阶段则不一定

> 补充1：数组类的加载

对于非数组类的加载，既可以Java虚拟机内置的引导类加载器，也可以使用用自定义的类加载器。用户可以同定义自己的类加载器来字节流的获取方式。

对于数组类，它本身不通过类加载器创建，而是由Java虚拟机直接在内存中动态构建，但是数据的元素类型仍然需要通过类加载器来加载。

数组类的创建遵循以下规则：

+ 如果数组的组件类型是引用类型，递归采用此处定义的加载过程来加载这个组件类型，数组会被标识在加载该组件类型的类加载器的类名称空间；
+ 如果数据类型不是引用类型，Java迅疾把数据标记为引导类加载器关联；
+ 数组类的可访问性与组件类型的可访问性一致，如果组件类型不是引用类型，数组类可访问性将默认为public

> 补充2：数组的元素类型与组件类型

元素类型指的是数组去掉所有维度的类型；组件类型指的是数组去掉一个维度的类型。

> 补充3：验证阶段的字节码校验

校验阶段需要通过数据流分析和逻辑流分析程序语义合法。由于数据流分析和控制流分析的高度复杂性， Java虚拟机的设计团队为了避免过多的执行时间消耗在字节码验证阶段中， 在JDK 6之后的Javac编译器和Java虚拟机里进行了一项联合优化， 把尽可能多的校验辅助措施挪到Javac编译器里进行。 具体做法是给方法体Code属性的属性表中新增加了一项名为“StackMapTable”的新属性。

> 补充4：符合引用与直接引用

符号引用：用一组符号描述引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位目标即可。与虚拟机实现的内存布局无关，引用的目标不一定是已经记载到虚拟机的内容。

直接引用：可以是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。与虚拟机实现的内存布局相关，同一个符合引用在不同虚拟机实例翻译得到的直接引用一般不相同。有了直接引用，则表示其引用的对象一定在虚拟机内存中。

> 补充5：解析的详细过程

解析过程中，主要是将常量池中的符合引用转换为直接引用，转换的对象包含了接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。

+ 类和接口的解析：如果不是数组类型，要解析类的全限定类名传递到类加载器进行加载，这个期间可能又会触发其他类的加载，一旦出现异常，解析工作就全部失败；如果是数组类型且元素类型，按非数组类型的方式来加载元素类型，紧接着虚拟机生成一个代表该数组维度和元素的数组对象；如果这两步都没有问题，虚拟机实际上已经生成了该类或接口。
+ 字段解析：解析一个未解析的字段符号引用，会先将字段所属类或接口的符号引用进行解析。
+ 方法解析：和字段解析类似，先将方法所属的类的符号引用进行解析。
+ 接口方法解析：和上述类似。

> 补充6：`clinit<>()`

`clinit<>()`方法是由javac编译器自动收集类中所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的，编译器的收集顺序由语句在源文件中出现的顺序决定。静态语句块只能访问到定义在静态语句块前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

`clinit<>()`方法与类的构造器(即`init<>()`方法)不同，它不需要显式调用父类构造器，Java虚拟机会保证子类的`clinit<>()`方法执行前，父类的`clinit<>()`方法已经执行完毕。因此在Java虚拟机中，第一个被执行`clinit<>()`方法的类型肯定是java.lang.Object。

`clinit<>()`方法对于接口或类而言不是必须的，如果一个类中没有静态语句块，有没有对变量的赋值操作，编译器不会生成该方法。

接口中不能有静态语句块，但仍然有变量初始化的赋值操作，因此接口和类会生成`clinit<>()`方法。但与类不同，执行接口的`clinit<>()`方法不需要先执行父接口的`clinit<>()`方法。因为只有当父接口中的定义的变量被使用时，父接口才会被初始化。

Java虚拟机会保证一个类的`clinit<>()`方法会在多线程环境下正确地被加锁同步。

> 补充7：《Java虚拟机规范》规定6种类必须立即初始化的场景

1. 遇到new/getstatic/putstaic/inovkestatic四条字节码指令，常见的代码场景有：
   + 数据
   + 读取或设置一个类型的静态字段(被final修饰、已在编译器把结果放到常量池的静态字段除外)
   + 调用一个类型的静态方法
2. 使用java.lang.reflect包的方法对类型进行反射调用时。
3. 初始化类时，如果发现父类没有进行初始化，先触发父类的初始化。
4. 启动虚拟机时，用户需要制定要执行的主类，虚拟机会先初始化这个类。
5. JDK7引入的动态语言支持....
6. JDK8加入的接口默认方法，如果具有默认方法接口实现类发生初始化，该接口需要先初始化

> 补充8：不必立即初始化的特殊场景

1. 通过子类引用父类定义的静态字段，只会触发父类的初始化，不会触发子类的初始化
2. 数组的初始化不会导致其原始类型初始化，只会导致虚拟机自动生成数组类初始化
3. 常量的使用不会导致常量所在类被初始化

### 类加载器

在类的加载阶段，允许让应用程序自定义类加载器来获取所需的类。

除了实现类的加载，类加载器还与类本身一起确认类在Java虚拟机的唯一性。

唯一性包含了Class对象的equals方法、isAssignableFrom方法、isInstance方法的返回结果。

从Java虚拟机角度，只存在两种不同的类加载器。

+ 启动类加载器：C++实现，虚拟机自身一部分
+ 其他类加载器：Java实现，独立存在于虚拟机外部，全部继承自java.lang.ClassLoader

从JDK1.2，Java一致保存三层类加载器、双亲委派的类加载器架构。

+ 启动类加载器：负责加载「JAVA_HOME\bin」目录，且是Java虚拟机能够识别的类库到虚拟机内存中。C++实现，无法直接引用
+ 扩展类加载器：负责加载「JAVA_HOME\lib\ext」目录，或java.ext.dirs系统环境变量指定路径的所有类库。Java实现，可以直接引用
+ 系统/应用程序类加载器：负责加载用户类路径上所有类库(CLASSPATH，[默认为当前目录](https://docs.oracle.com/javase/tutorial/essential/environment/paths.html))

JDK 9之前的Java应用都是由这三种加载器通过双亲委派机制的方式来相互协作完成加载。除此之外，用户可以通过加入自定义加载器进行扩展。

> 补充1：双亲委派模型

如果一个类的加载器收到了类加载的请求，首先不会自己尝试加载这类，而是把这个请求交给父类，每一层的类加载器都是如此，因此所有的加载请求最终都会传递到顶层的类加载器，只有当父类加载器反馈自己无法完成这个类的请求时(它的搜索范围没有找到所需类)，子加载器才会阐述自己完成加载。

通过使用双亲委派模型来组织类加载器之间的关系，可以让Java中的类和对应的类加载器有优先的层次关系。如对于lang包下的类，存放与rt.jar包下，无论是哪个类加载器尝试加载这个类，最终都会委派到引导类加载器。这样一来就能保证无论哪个类加载器尝试加载的lang包下的类，得到的都是同一个类(类加载器+类决定类的唯一性)。

如果不使用双亲委派模型，有各个类加载器自行加载，容易造成混乱。

因此双亲委派模型可以保证Java程序的稳定运行。

> 补充2：破坏双亲委派模型

双亲委派模型是一个建议性模型，并不具有强制性。双亲委派在历史上曾经出现3次较大规模的“被破坏”的情况。

第一次出现在JDK1.2前。双亲委派模型在JDK1.2之前就已经出现，而java.lang.ClassLoader在Java的第一个版本就已经存在。对于已经存在的用户自定义类加载器，考虑到兼容性，设计者在引入双亲委派模型时添加了findClass。在双亲委派具体逻辑中，如果父类加载失败，会调用自己的findClass方法完成加载。这样一来既不会影响用户按照自己的意愿加载类，又可以保证新写出的类加载器符合双亲委派规则。

第二次被破坏是由于其自身缺陷导致。对于SPI服务，JDK只负责定义接口，具体实现时需要调用厂商对应的实现。这就会出现，对于JDK定义的接口由启动类加载器加载(java.sql.Driver)，对于相应的实现则由应用程序类加载器进行加载(如com.mysql.cj.jdbc.Driver)。显然如果不采取一定的策略，父类加载器将访问拿到子类加载器的加载的代码。这就回导致在获取java.sql.Driver实现类时无法获取到相应的实例，这时需要运行父类加载器请求子类加载器完成类的加载，违反了双亲委派模型自下而上的请求方式。

第三次破坏是用户对程序动态性的追求而导致的。「动态性」是指：代码热替换、模块热部署。对于主流动态模块化规范OSGi，它实现模块化热部署的关键在于其自定义的类加载器机制，每个程序模块都有自己的类加载器，当需要更换一个模块时，连同类加载器一起换掉来实现代码的热替换。在OSGi中不使用双亲委派的树形结构，而是发展为网状结构。

[补充阅读](https://www.zhihu.com/question/49667892/answer/690288611)

## 运行时数据区

通过java命令启动虚拟机，对相应的class文件加载、链接、初始化之后，静态的class结构会换转到运行时数据区。

Java虚拟机在执行Java程序过程中会把它管理的内存划分为若干个不同的数据区域。这些区域有不同的功能和声明周期。

《Java虚拟机规范》固定，Java虚拟机管理的内存包含以下结构：

+ **堆**：线程共享，是虚拟机管理内存中最大的一块。唯一目的是**存放对象实例**。绝大多数对象在堆上分配。Java堆中可以划分出多个线程私有的分配缓冲区(TLAB)，来避免线程竞争，提高独享分配效率【垃圾收集器管理的区域，-Xmx与-Xms】
+ **方法区**：线程共享，储存**被虚拟机加载的类型信息、常量、静态变量、即时编译器编译的代码缓存。**【回收条件苛刻，但是有必要】
  + JDK8之前，对于Hot-Spot虚拟机，方法区的实现为永久代（更容易导致内存溢出）
  + JDK8及之后，对于Hot-Spot虚拟机，方法区的实现为元空间（采用本地内存实现）
+ **Java虚拟机栈**：线程私有，每个方法执行时，Java虚拟机都会同步在虚拟机栈中同步创建一个栈帧用于储存局部变量表、操作数栈、动态连接、方法入口等信息。【固定栈-SOE，动态栈-OOM】
+ **本地方法栈**：线程私有，为虚拟机使用本地方法服务。Hot-Spot虚拟机直接将本地方法栈与Java虚拟机栈合并。
+ **程序计数器**：线程私有，当前线程执行的字节码行号指示器。程序计数器可以保证线程切换之后能够恢复到正确的执行位置，因此它是线程私有的。【唯一一处无OOM的区域】

> 补充1：直接内存

直接内存不属于虚拟机运行时数据区，也不是《Java虚拟机规范》定义的内存区域，但是这部分内存被频繁使用，而且可能会导致OOM。

JDK1.4引入了NIO类，它基于通道和缓冲区的I/O方式，可以使用Native函数直接分配堆外内存，之后可以通过一个储存在Java堆中的DirectByteBuffer对象来操作这片堆外内存。在堆外内存可以避免Java对到Native对的数据复制，在一些场景中可以显著提高性能。

直接内存大小 不受Java堆大小限制，但是会受到操作系统内存的大小限制。

### HotSpot堆实现

**对象创建**

Java虚拟机遇到new指令时，首先检查指令参数是否能够在常量池中定位到一条类的符号引用，并检查符号引用代表的类是否已经被加载、解析和初始化过。

类加载检查通过之后，虚拟机为新生对象分配内存。由于对象所需内存在加载完成已经确定，因此只需把一块确定内存从堆中划分出来即可。

+ 如果堆中内存规整，虚拟机可以「对撞指针」将内存分为使用和未使用两部分。
+ 如果堆中内存不规整，虚拟机需要维护「空闲列表」来记录那些内存可用，那些不可用。

堆内存是否规整由垃圾收集器来决定。

+ 如果垃圾收集器具有空间压缩整理功能，则系统采用的分配算法是指针碰撞，简单高效；
+ 如果垃圾收集器是基于清除算法，则系统采用的分配算法是空闲列表法。

对象创建的行为不是原子性的，而且非常频繁，因此在并发环境下需要保证分配内存的线程安全，主要有两种方式。

+ 对为对象分配内存空间这一行为进行同步处理保证原子性。（实际通过CAS+失败重试保证原子性）
+ 使用TLAB，为每个线程在堆中预先分配一小块内存用于内存分配。（类似于线程私有变量避免线程竞争）

内存分配完毕需要将分配的内存空间初始化为零值。如果使用TLAB方式，可以提前值TLAB分配是进行。（这一步保证了对象的**实例字段**可以在不赋初值就可以会直接使用）

初始化之后，还需要对对象进行必要设置，如**对象属于哪个类**、如果获取该类的元数据、对象的哈希码、**对象的GC分代年龄**。（这些信息存储在对象头中）

综上，从Java虚拟机角度，一个新的对象已经产生；但从Java程序角度，对象创建才刚刚开始-`<init>()`尚未执行，其他信息仍未准备好。（一般而言，字节码中的new指令都会在后面跟随invokespecial用于执行`<init>()`方法）

**对象布局**

在堆中创建好的对象可以分为三部分。

+ **对象头**：包含两类信息：Mark Word与类型指针
  + Mark Word：用于储存对象自身运行的数据，如hashCode、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳
  + 类型指针：指向类型元数据，通过它确定属于哪个类。（数组类型无法通过元数据推断数组大小）
+ **实例数据**：程序代码中定义的各种类型的字段内容，包含父类继承而来的。（虚拟默认将宽度相同的分配在一起，在这个前提下，父类出现在子类之前）
+ **对齐填充**：非必须，仅起占位符作用。（保证为8字节的整数倍）

**对象的访问定位**

创建好的对象可以栈上的reference数据来访问，主流的访问方式有两种：

+ **句柄访问**：Java堆中划分一块内存作为句柄池，reference储存的是句柄地址，句柄中包含对象实例数据与类型数据各自具体地址信息
+ **直接指针**：Java堆中对象需要考虑如何放置访问类型数据相关信息，referenc储存的是对象地址

![image-20210817190137166](https://gitee.com/tobing/imagebed/raw/master/image-20210817190137166.png)

> 两种存储方式各有优势。
>
> 使用句柄访问的最大好处是reference中储存的是稳定句柄地址，对象移动时只会改变实例数据指针，而reference本身不会改变；（有利于垃圾回收的对象移动）
>
> 使用会直接指针访问的最大好处是速度更快，节省了异常指针定位的开销。（Hot-Spot采用的对象访问方式。）

## 垃圾收集

在Java运行时区域中，有些内存区域的生命周期与线程相关，如**程序计数器、虚拟机栈、本地方法栈**；线程中的栈帧随着方法的进入和退出不断的执行出栈和入栈操作。每个栈帧分配的内存在类结构确定是就已知。因此这些区域的内存分配和回收具有固定性，无需过多考虑回收问题。

对于**堆和方法区**两个区域则存在显著的不确定性：一个接口的多个实现类所需的内存可能不一样，一个方法创建的不同条件分支需要的内存也可能不一样，只有处于运行期此案能知道程序究竟需要创建那些对象、需要创建多少对象，这部分的内存分配和回收是动态的。

<font style="color:red">**综上所述，垃圾收集器关注的主要是堆和方法区的内存管理。**</font>

垃圾收集包含两部分内容，即对象**存活判定算法**和**垃圾收集算法**。前者区分哪些对象属于垃圾，后者确定对对象回收的具体方案。

### 存活判定算法

判定对象是否存活，主流的主要有两种算法，引用计数法和可达性分析算法。

**引用计数法**

在对象中添加一个**计数器**，每当有对象引用它就加一，引用失效减一，任何时刻计数器为零则表示对象不可用。

这种算法算法原理简单，效率较高，被用于COM、ActionScript3、FlashPlayer、Python中用于内存管理。但是存在缺陷，即很难解决对象之间相互**循环引用的问题**。

**可达性分析算法**

主流的商业编程语言（如C#/Java/Lisp）都是通过可达性分析算法来判定对象是否存活。

算法基本思路是，通过**一系列的「GCRoots」的根对象作为起始节点集**，从这些节点开始，根据引用关系**向下搜索**，搜索完毕如果某个对象到GCRoots没有任何链引用，则次对象是不可达的。

其中在Java中，可以固定作为GCRoots的对象包含：

+ 虚拟机栈中引用的对象：如调用方法使用到的参数、局部变量、临时变量等；
+ 方法区中类静态属性引用的对象：如Java引用类型静态常量；
+ 方法区中常量引用的对象：如字符串常量池中的引用；
+ 本地方法栈中Native方法引用的对象；
+ Java虚拟机内部的引用：如基本数据类型对应的Class对象，常驻的异常对象、系统加载类等；
+ 被同步锁持有的对象；
+ 反映Java虚拟机内部情况的对象：如JMXBean、JVMTI、本地代码缓存等

除了这些固定的GCRoots之外，在进行垃圾回收时，可能会临时加入新的对象和上面共同作为GCRoots。（如RememberedSet）

> 补充1：Java中的4种引用

判定对象的存活与「引用」离不开关系。

JDK1.2前，Java中的reference定义比较狭隘，只有「被引用」和「未被引用」两种状态，无法描述「食之无味，弃之可惜」（即内存够可能保留，内存紧张可以回收）的对象；

JDK1.2后，Java对reference进行了扩充，将引用分为了4种。

+ 强引用：平时使用的引用，无论何时只要存在强引用，垃圾收集器就不会将对应的对象回收；
+ 软引用：用于描述可用、但非必须的对象。被软引用关联的对象，在系统将要发生内存溢出前，会把这些对象进行回收，这个回收这些对象仍未有足够内存，才会抛出内存溢出；（SoftReference类实现）
+ 弱引用：用于描述非必须的对象，弱引用关联的对象只能生产到下一次垃圾收集为止，无论内存是否足够。（WeakReference类实现）
+ 虚引用：一个对象是否有虚引用存在完全不会对其生产时间构成影响，也无法通过虚引用来获取一个对象实例。**设置虚引用关联的唯一目的是能在该对象被回收时收到一个系统通知**。（PhantomReference类实现）

> 补充2：finalize方法

java.lang.Object#finalize方法是对象逃离死亡命运的最后一次机会，可以在方法中与引用链重新建立连接，从而避免被回收。

有必要执行finalize方法的对象会别放置到F-Queue队列，并由虚拟机创建的地调度的Finalizer线程执行器finalize方法。

不鼓励使用该方法拯救对象，应该经历避免使用。因为它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，已被官方声明为不推荐使用的语法。

> 补充3：方法区的回收

与Java堆相比，方法区垃圾收集的性价比往往比较低，回收条件苛刻。方法区的垃圾收集主要有两部分内容：废弃的常量和不再使用的类型。常量的废弃回收相对简单，对于类型的回收需要满足以下条件：

+ 类的所有实例已经被回收，即Java堆中不存在该类及其任何派生的子类；

+ 加载该类的类加载器已经被回收，通常只会出现在可替换类加载器的场景，如OSGi、JSP等，否则很难达成；
+ 该类的对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

经过对于方法区中类型的回收很苛刻，但是对于在大量使用反射、 动态代理、 CGLib等字节码框架， 动态生成JSP以及OSGi这类频繁自定义类加载器的场景中， 类型的卸载很有必要。

### 垃圾收集算法

商业虚拟机的垃圾收集器大多基于「分代收集」设计。分代收集建立在两个分代假设之上：

+ 弱分代假设：绝大多数的对象都是朝生夕死
+ 强分代假说：熬过越多垃圾收集的对象越难消亡

两个分代假说奠定了垃圾收集器的设计原则：**收集器将Java对分出不同区域，将会是对象依照年龄分配到不同的区域中储存**。在Java对分出不同区域之后，垃圾收集器每次只回收一部分区域。

一般而言，<font style="color:red">**至少把Java堆划分为新生代和老年代两个区域**</font>。**新生代**中，每次垃圾收集会有大批对象死去，每次回收后存活的少量对象，将会**逐步晋升代老年代**中存放。

但分代收集存在一个明显的困难：<font style="color:red">**对象不是孤立的，对象之间会存在跨代引用**</font>。

引用存在**跨代引用**，在新生代进行收集时，新生代对象可以被老年代引用，为此在扫描时，需要在规定的GCRoots之外，额外扫描老年代所有对象，确保可达性分析结果是正确的。同样地，老年代也存在同样问题。遍历老年代虽然可行，但是会为内存回收带来很大的性能负担。为了解决这个问题，为分代收集理论添加了第三条经验法则：

+ 跨代引用假说：跨代引用相当于对于同代引用来说仅占少数。

依据上述假说，

<font style="color:red">不应再为少量跨代引用扫描整个老年代。只需在新生代建立全局**Remembered Set**，整个结构把老年代分为若干小块，记录老年代哪一块内存会存在跨代引用。此后发生MinorGC时，只有包含了跨代引用的小块内存中的对象才会被加入GCRoots中扫描。</font>

> 补充1：各种GC

PartialGC：目标不是完整会涉及整个Java堆的垃圾回收，又分为以下GC。

+ MinorGC/YoungGC：新生代垃圾收集；
+ MajorGC/OldGC：老年代垃圾收集。目前只有CMS收集器有单独收集老年代的行为；
+ MixedGC：整个新生代和部分老年代的垃圾收集。目前只有G1收集器有这种行为；
+ FullGC：收集整个Java堆和方法区的垃圾收集。

**标记-清除算法**

标记-清除算法分为「标记」和「清除」两个阶段，先标记出所有需要回收的对象，标记完成之后统一回收。作为最基础的收集算法，它主要有两大缺点：

+ 执行效率不稳定，如果堆中有大量对象且大部分部分需要回收，这时需要进行大量标记和清除动作，标记清除执行效率随着对象增加而降低。
+ 内存空间碎片化，标记、清除之后会有大量不连续的内存碎片。碎片太多会导致无法找到连续的内存来分配大对象将会提前触发垃圾收集操作。

**标记-复制算法**

为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，有人提出了「半区」复制。即将内存划分为两半，每次使用一半，当这一半用完，将存活的对象复制到另外一半，然后把已使用的内存空间进行清理。

如果内存中多数对象都是存活，这种算法会产生大量内存间复制，但对于多数对象可回收，则只需要复制少数对象，且每次都是针对一半内存进行回收，不需要考虑空间碎片问题。

虽然标记复制算法简单、高效，但是浪费的内存也很多。

现代的商用Java虚拟机在**新生代**大多采用标记-复制算法进行垃圾收集，但是并不是按照1:1的比例划分。（基于「新生代中的对象98%熬不过第一轮收集」）

基于朝生夕死的特点，Appel式回收将新生区分为一块较大Eden和两块较小Survivor，每次内存分配只使用Eden和其中一块Survivor。HotSpot虚拟机的Serial、ParNew等新生代垃圾收集器都是基于这个策略来设计新生代内存布局，默认的比例为Eden:Survivor=8:1。

**当Survivor空间不足容纳异常MinorGC之后存活的对象，需要依赖其他内存区域（大多是老年代）进行分配担保。**即如果Survivor空间没有足够的空间存放上一次新生代收集的存活对象时，这些对象会通过担保机制直接居然老年代。（**逃生门**）

**标记-整理算法**

标记-复制算法不适合使用于具有大量存活对象的场景（如老年代）。针对老年代独享的存亡特征，人们提出了「标记-整理算法」，其标记过程与「标记-清除」算法一直，但后继步骤不是直接对对象进行清除，而是让存活的独享往内存空间一端移动，然后直接清理边界以外的内存。（移动式回收算法）

由于标记-整理是移动式回收算法，对于老年代的具有大量存活对象，移动对象并更新引用对象的地方，是一种极为负重的操作，而且这种**移动对象的操作必须要全程暂停用户应用程序才能进行**。（Stop The World）

> 补充1：停顿时间与吞吐量的权衡

对于标记-整理算法，属于移动式回收，需要移动存活对象，停顿时间相对较长，但是系统吞吐量高；【吞吐量优先：Parallel Scavenge】

对于标记-清除算法，属于非移动式回收，需要在分配时考虑内存碎片化的问题，系统吞吐量会有所下降，但是停顿时间较短。【低延迟优先：CMS】

除此之外，还有折中的方式。即虚拟机平时多数使用标记-清除，暂时容忍内存碎片的存在，直到内存碎片化程度大到影响对象分配，在采用标记-整理算法收集。【CMS对于碎片化采用此解决方案】

### HotSpot垃圾收集

**根节点枚举**

HotSpot在判断对象存活的时候，采用的是可达性分析算法。在可达性分析算法中，需要从GCRoots集合找出引用链进而确定存活的对象。在这个过程中主要可以分为两步：根节点枚举与遍历引用链。

对于遍历引用链，可以做到与用户线程一起并发。<font style="color:red">**在根节点枚举时，必须要在一个能保障一致性的快照中进行，因此这个过程需要Stop The World。**</font>

当用户线程停顿下来时，并不需要一个不漏检查所有执行上下文和全局的引用位置，虚拟机可以使用一组OopMap的数据结构来记录对象引用存放的位置。一旦类加载动作完成，HotSpot就会把对象内偏移量是什么类型的数据计算出来。

**安全点**

通过OopMap可以快速准确完成GCRoots枚举。但是导致引用变化或指令或导致OopMap内容变化的指令很多，如果为每一条指令生成对应的OopMap将需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本将会十分高昂。

在HotSpot中只能在特定位置(安全点)中能够停顿下来开始垃圾收集。对于安全点的选择，不能太少以至于导致收集器等待时间过长，也不能太频繁导致增大运行的内存负荷。因此安全点位置基本选取在「是否具有让程序长时间执行的特征」进行选定，如方法调用、循环跳转、异常跳转等，在这些地方才会产生安全点。

让垃圾收集时，让所有线程都到达最近安全点，主要有两种方案：**抢先式中断**和**主动式中断**。

+ 抢先式中断不需要线程的执行代码主动去配合， 在垃圾收集发生时， 系统首先把所有用户线程全部中断， 如果发现有用户线程中断的地方不在安全点上， 就恢复这条线程执行， 让它一会再重新中断， 直到跑到安全点上。【基本没有虚拟机实现采用抢先式】
+ 主动式中断的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方和安全点是重合的， 另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。

**安全区域**

安全点机制保证了程序**执行**时，在不太长的时候就会遇到可以进入垃圾收集过程的安全点。

但是对于程序「不执行」  的时候（如用户线程处于Sleep或Blocked状态），这是线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断自己，虚拟机显然也不能等待线程重新分配处理器时间。这是就需要引入安全区域来解决。

**安全区域是指能够给在某一端代码片段中，引用关系不会发生变化，因此这个区域任意地方开始垃圾收集都是安全的。**

当用户线程进入安全区域时，首先会标识自己已经进入了安全区域，当线程要离开安全区域时，要检测虚拟机是否已经完成了**根节点枚举**。如果完成了线程就当没事发生，继续执行；否则必须要一直等待其完成。

**记忆集与卡表**

为了解决对象跨代引用，会在新生代建立RememberedSet的数据结构，避免将整个老年代加入GCRoots扫描范围。除了新生代和老年代之间的跨代引用问题，对于涉及部分回收行为的垃圾收集器都会存在跨代回收问题，如G1、ZGC和Shenandoah等。

RememberedSet是用于记录从非收集区指向收集区的指针集合的抽象数据结构。在垃圾收集器中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了， 并不需要了解这些跨代指针的全部细节。因此设计者在实现记忆集是会选择更为粗狂的记录粒度来节省记忆集的储存和维护成本。

HotSpot中对于RememberedSet的实现是卡表，卡表中记录了**每块内存块(卡页)**是否包含跨代指针。一般而言，卡页大小为2的N次幂的字节数，HotSpot中卡页是2的9次方。如卡页的0/1/2号元素对应了0x0000~0x01FF、0x0200~0x03FF、0x0400~0x05FF的内存块。

一个卡页中通常包含多个对象，只要一个对象的字段存在跨代指针就将对应的卡表数组元素标识为1，表示这个元素变脏了。在垃圾收集发生是，只需要筛选出卡表变脏的元素就能轻易得出那些卡页内存块包含了跨代指针，将其加入GCRoots一起扫描即可。

**写屏障**

HotSpot中使用卡表来实现RememberedSet，卡表中的每个元素记录了每块内存块是否存在跨代引用（内存块是否变脏）。

由于Java是编译与执行并存的，因此需要在机器码层面来维护卡表的动作放到每个复制操作之中。**HotSpot虚拟机是通过写屏障技术来维护卡表状态的。**

应用写屏障之后虚拟机就会为所有赋值操作生成相应的指令， 一旦收集器在写屏障中增加了更新卡表操作， 无论更新的是不是老年代对新生代对象的引用， 每次只要对引用进行更新， 就会产生额外的开销， 不过这个开销与Minor GC时扫描整个老年代的代价相比还是低得多的。  

除了写屏障的开销，卡表在高并发下还存在**伪共享**问题。假设处理器的缓存行大小为64字节， 由于一个卡表元素占1个字节， 64个卡表元素将共享同一个缓存行。这64个卡表元素对应的卡页总的内存为32KB（64×512字节） ， 也就是说如果不同线程更新的对象正好处于这32KB的内存区域内， 就会导致更新卡表时正好写入同一个缓存行而影响性能。

一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏。

**并发可达性分析**

在根枚举过程中经过各种优化加持，可以保证其带来的停顿相对固定。但是从GCRoots往下遍历对象图时，其停顿时间必定与Java对容量的大小成正比。

> 三色标记

+ 白色：对象未被垃圾收集器访问。（刚开始所有都是白色，分析结束仍为白色表示不可达）

+ 黑色：对象已经被垃圾收集器访问，且这个对象的所有引用都已经扫描过。（如果有对象引用指向内饰，无须重复重新扫描；黑色不可能直接指向白色）
+ 灰色，对象已经被垃圾收集器访问，但是对象至少存在一个引用仍没有被扫描过。

可达性分析的扫描过程，可以看作对象图上一股以灰色为波峰的波纹从黑向白推进的过程。

如果用户线程与收集器并发执行，收集器在对象图上标记颜色，同时用户线程在修改引用。这是可以会出现两种结果。

+ 把原本消亡的对象错误标记为存活。（可以容忍，下次收集清理掉就好）
+ 把原本存活的对象错误标记为已消亡。（致命后果，程序肯定会因此发生错误）

![image-20210818154038298](https://gitee.com/tobing/imagebed/raw/master/image-20210818154038298.png)

+ ①初始状态只要GCRoots是黑色；
+ ②扫描过程，以灰色为波峰从黑向白推进，灰色是黑色和白色的分界线；
+ ③扫描顺利完成，黑色是存活，白色是存活的对象；
+ ④如果用户标记时并发修改了引用关系，可能存在：正在扫描的灰色对象的一个引用被切断，同时原来引用的对象又与扫描过的黑色对象建立了索引关系；
+ ⑤还可能存在：切断后重新被黑色对象引用的对象可能是原有引用链的一部分。由于黑色对象不会重新扫描，这将导致扫描结束后出现两个被黑色对象引用的对象仍是白色，这个是非常危险的。

Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题。

+ 赋值器插入了一条或多条从黑色对象到白色对象的新引用；
+ 赋值器插入了全部从灰色对象到该白色对象的直接或间接引用。

因此，如果要解决并发扫描时的对象消失问题，只需要破坏这两个条件的任意一个即可。由此产生了两种解决方案：

+ **增量更新**：破坏第一个条件，当黑色对象插入新的指向白色对象的引用关系时， 就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。   【CMS】
+ **原始快照**：破坏第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。  【G1、Shenandoah】

无论是对引用关系记录的插入还是删除， 虚拟机的记录操作都是通过写屏障实现的。

### 经典垃圾收集器

不存在万能的收集器，值存在对具体应用最合适的收集器。

#### Serial收集器

+ 新生代，单线程
+ 工作时必须暂停所有工作线程
+ Hotspot虚拟机运行在客户端模式的默认新生代垃圾收集器
+ 适用于资源受限环境，如用户桌面应用场景以及流行的部分微服务应用中
+ 无线程开销，可以专心收集，可以获得最高的单线程收集效率

#### ParNew收集器

+ 新生代，多线程并行收集
+ Serial收集器的多线程版本，两者的收集算法、STW、对象分配规则、回收策略一致
+ 处理Serial外，只有ParNew能与CMS一起配合使用
+ JDK1.9之后，ParNew与CMS组合不再是官方推荐的服务端模式下的收集器

#### Parallel Scavenge收集器

+ 新生代，多线程并行收集，标记-复制算法
+ Parallel Scavenge关注可控吞吐量；CMS关注短暂的停顿时间

#### Serial Old收集器

+ Serial老年代版本，单线程，标记-整理算法
+ 客户端模式下，   与Parallel Scavenge收集器搭配使用 (JDK1.5以及之前)
+ CMS收集器发送失败时的后备预案

#### Parallel Old收集器

+ 老年代，多线程并发收集，标记-整理
+ Parallel Scavenge收集器的老年代版本
+ Parallel Old收集器出现后， “吞吐量优先”收集器终于有了比较名副其实的搭配组合
+ 在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。   

#### CMS收集器

+ 老年代，多线程并发收集，标记-清除
+ 最短回收停顿时间为目标的收集器 ，运行过程包含以下四个步骤：
  1. 初始标记：STW，仅标记GCRoots直接关联的对象，速度很快；
  2. 并发标记：从GCRoots直接关联的对象开始遍历整个对象图，不停顿；
  3. 重新标记：STW，修正并发标记期间用户程序运行修改导致的变动标记；
  4. 并发清除：清理掉被标记阶段标记为依据死亡的对象。
+ 经过CMS可以实现并发低停顿，但是存在以下缺点：
  1. 对处理器资源非常敏感；
  2. 无法处理浮动垃圾，有可能会出现CMF从而导致另一次STW的FullGC；
  3. 基于标记-清除算法，容易产生内存碎片，容易导致提前FullGC。

#### G1收集器

+ 面向局部收集，基于Region的内存布局，低停顿时间
+ 面向服务端应用，在JDK9服务端模式默认收集器

+ 收集是根据分区的垃圾数量进行回收，计算收益最大的(Mixed GC)
+ 虽然仍然保留新生代和老年代概念，但是新生代和老年代不再固定，是一系列区域的动态集合
+ 将堆分为多个独立Region，Region之间仍然存在跨代引用问题，仍然是使用RememberedSet解决
+ 由于Region较多，而且需要使用双向卡表记录引用关系（谁指向我，我指向谁），因此耗费的内存页相对较多
+ 可以由用户指定期望的停顿时间，可在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡
+ 不考虑线程运行过程中的动作，G1收集器运行大致可以分为四个步骤：
  1. 初始标记：STW，进标记GCRoots直接关联的对象，耗时很短；
  2. 并发标记：从GCRoots对堆中对象进行可达性分析，递归整个对象图，找出回收的对象；与用户查询并发执行，扫描完毕还要重新处理SATB记录下在并发时改定的对象；
  3. 最终标记：STW，处理并发阶段结束或仍遗留的最后少量SATB记录；
  4. 筛选回收：STW，否则更新Region统计数据，多各个Region回收价值/成本进行排序，根据期望的停顿时间制定回收集合，可以自由选择任意多Region构成回收集。

#### 低延迟的需求

衡量垃圾收集器的三项重要标准是：内存占用、吞吐量和延迟。三者共同构成了一个不可能三角形。

在这三项指标中，延迟的重要性日益显著，越发备受关注，原因是随着计算机硬件发展、性能提升，可以容忍多一点内存消耗，同时硬件规格的提升也有利于降低收集器运行时对应用程序的影响。但是硬件规格的提高反而为延迟带来了负面影响，如回收1TB堆内存划分的时间显然比回收1GB堆内存划分的时间要长。

### 内存分配与回收策略

Java技术体系的自动内存管理根本目的是自动化解决两个问题：自动为对象分配内存、自动回收分配给对象的内存。

`-XX:+PrintGCDetails`收集器日志参数

#### 对象优先分配在Eden

大多数情况，对象在新生代Eden区中分配，当Eden没有足够空间，发起一次MinorGC。

#### 大对象直接进入老年代

需要大量连续内存空间的大对象在分配空间是容易导致内存明明存在不少空间，但是要提前触发垃圾收集，已获得足够的空间安置，当复制对象是，大对象的内存复制开销大。

指定大于设定值的对象直接进入老年代分配，可以避免在Eden去以及两个Survivor之间复制，产生大量内存复制操作。

#### 长期存活对象进入老年代

虚拟机在每个对象头储存了对象的年龄计数，对象在Survivor区中每熬过一次MinorGC，年龄就增加1，当年龄增加到一定程度，会被晋升到老年代。

`-XX:MaxTenuringThreshold`指定对象晋升阈值。

#### 动态对象年龄判定

为了更好适应不同程序的内存状况，HotSpot不永远要求对象年龄必须大于指定值才能晋升到老年代，如果Survivor空间中相同年龄所有对象大小总和大于Survivor空间一半，年龄大于或等于该年龄的对象可以直接进入老年代。

#### 空间分配担保

发生MinorGC前，虚拟机必须先检查**老年代最大可用连续空间释放大于等于新生代所有对象总空间**，如果条件成立，MinorGC确保是安全的；如果不成立，虚拟机会根据设置的参数查看是否允许担保失败，如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小， 如果大于， 将尝试进行一次Minor GC， 尽管这次Minor GC是有风险的； 如果小于直接FullGC。

如果设置的参数本身就不允许担保失败，直接FullGC。

`-XX:HandlePromotionFailure`设置是否允许担保失败。

> 补充1：并行垃圾收集与并发垃圾收集

+ 并行（Parallel）：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。

+ 并发（Concurrent）：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。

> 补充2：吞吐量与停顿时间

吞吐量 = 代码运行时间 / （运行用户代码时间 + 运行垃圾收集时间）

停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序， 良
好的响应速度能提升用户体验；

而高吞吐量则可以最高效率地利用处理器资源， 尽快完成程序的运算
任务， 主要适合在后台运算而不需要太多交互的分析任务。  

## 执行引擎

「虚拟机」相对于「物理机」概念，两种机器都有代码执行能力，区别是物理机的执行引擎是建立在处理器、缓存、指令集和操作系统层面；而虚拟机的执行引擎是由软件实现，可以不受物理条件限制地定制指令集与执行引擎的结构体系，能够执行不被硬件直接支持的指令集格式。

### 运行时栈帧结构

Java虚拟机以方法作为最基本的执行单元。栈帧是用于支持虚拟机进行方法调用和方法执行背后的数据结构，储存了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每个方法的调用到执行结束都对应着一个栈帧在虚拟机中入栈到出栈的过程。

在编译Java程序源码是，栈帧所需的局部变量表大小，操作数栈深度就已经被分析处理并且写入到方法表的Code属性之中。

**局部变量表**

局部变量表是一组变量值的存储空间，用于存放**方法参数**和**方法内部定义的局部变量**。局部变量表容量以变量槽为最小单位。储存了：

+ boolean、 byte、 char、 short、 int、float、 reference和returnAddress【小于等于32位】
+ long、double【大于32位】

对于reference类型表示对一个对象实例的引用，通过它可以直接或间接查找对象在Java堆中的数据存放的起始地址或索引；查找对象所属数据类型在方法区中的储存的类型信息。

对于64位的数据，Java虚拟机会将其分配两个连续的变量槽空间。

Java虚拟机通过索引定位的方式使用局部变量表。当一个方法被调用，Java虚拟机会使用局部变量表来完成**参数值到参数变量列表的传递过程**。如果是实例方法，局部变量表的第0位索引默认是用于传递方法所在索引的引用，通过this来访问这个隐含参数。

**操作数栈**

操作数栈的每个元素都可以是包括long和double在内的任意Java数据类型。方法刚开始执行时，方法的操作数栈是空的，方法执行过程中会有各种字节码指令往操作数栈写入和提取内容。

**动态连接**

每个栈帧都包含一个指向运行时常量池中栈帧所属方法的引用，这个引用是为支持方法调用过程中的动态连接。

Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数 。这些符号引用一部分会在类加载阶段或第一次使用的时候转换为直接引用，这种转换称为静态解析。另外一部分将在每一次运行期间都转换为直接引用，这部分称为动态解析。

**方法返回地址**

当一个方法执行后，只有两种方式退出这个方法。

+ 第一种方式：执行引擎遇到一个方法返回字节码指令，这时候有可能会有返回值传递个上层的方法调用者【正常调用完成】
+ 第二种方式：执行过程中遇到异常，且异常没有被妥善处理，导致方法退出【异常调用完成】

无论以何种方式退出，在方法退出之后必须返回到最初的方法被调用的位置，这样程序才能继续执行下去，方法返回时可能需要在栈帧中保存一些信息，保证其恢复上层主调方法的执行状态。

+ 方法正常退出，主调方法的PC计数器的值可以作为返回地址，栈帧可能会保存该值
+ 方法异常退出，返回地址需要通过异常向量表来确定，栈帧一般不会保存这部分信息

### 方法调用

方法调用不等同于方法中的代码被执行，方法调用阶段的唯一任务是确定被调用方法的版本，未涉及内部的具体执行。

Class文件的编译不包含传统编程语言的编译连接步骤，一切方法调用在Clas文件里储存的都只是符合引用，而不是方法实际的运行时内存布局的入口地址。这个特性给Java带来了更强大的动态扩展能力。





