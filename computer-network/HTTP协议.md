# HTTP协议

## 概述

### HTTP简介

HTTP，超文本传输协议。

+ 协议：HTTP是一个用于计算机世界的协议，使用计算机能够理解的语言确立一种计算机之间交流通信的规范，以及相关的各种控制和错误处理的方式。
+ 传输：HTTP是一个在计算机中专门用于两点间传输数据的约定和规范。
+ 超文本：超文本意味着超越了普通文本，能够从一个超文本跳转到另一个超文本。

HTTP是计算机中专门用于两点之间传送文字、图片、音频、视频等超文本数据的约定和规范。

HTTP不是孤立的协议，通常运行在TCP/IP协议栈之上，依靠IP协议实现寻址和路由、TCP协议可以是实现可靠传输、DNS协议实现域名炒作、SSL/TLS协议实现安全通信。

### HTTP发展

#### HTTP/1.0

HTTP/1.0 版本在 1996 年正式发布 ，相比于0.9版本，有以下区别：

1. 增加HEAD、POST等新方法；
2. 增加了响应状态码，标记可能的错误原因；
3. 引入协议版本号的概念；
4. 引入了HTTP Header概念，让HTTP处理请求和响应更加灵活；
5. 传输的数据不再仅限与文本。

HTTP/1.0不是一个「标准」，只是记录实践和模式的参考文档，不具有收集约束力。

#### HTTP/1.1

1999 年，HTTP/1.1发布了RFC文档（编号为 2616），正式确立了延续十余年的传奇。HTTP/1.1是对HTTP/1.0的小幅度修正，但它是一个「正式标准」。相比于HTTP/1.0，HTTP/1.1主要有以下改变：

1. 添加PUT、DELETE等新方法；
2. 增加缓存管理和控制；
3. 明确连接管理、允许持久连接；
4. 允许响应数据的分开，有利于传输大文件；
5. 强制要求Host头，让互联网主机托管称为可能。

HTTP/1.1的推出是众望所归，互联网在它的保驾护航下迈开大步，由此走上了康庄大道，开启了后继的Web1.0、Web2.0的时代。

由于HTTP/1.1太过与庞大而复杂，因此在2014年又做了一次修订，原来的一个大文档被拆分成了六份较小的文档，编号为 7230-7235，优化了一些细节，但此外没有任何实质性的改动。  

#### HTTP/2.0

HTTP/1.1发布之后，互联网呈现爆发式增长，这期间也出现了对HTTP不满的意见。主要是连接慢，无法跟上迅速发展的互联网。由于HTTP/1.1一致岿然不动，后来Google实现开发了浏览器的Chrome，然后退出了新的SPDY协议。由于Chrome的用户占有率高，互联网标准化组织以Google的SPDY为基础开始制定新的HTTP协议。

2015年，HTTP/2.0发布，RFC编号7540。HTTP/2.0的制定充分考虑了当今互联网的现状：宽带、移动、不安全，在高度兼容HTTP/1.1的同时性能方面进行了很多的努力，主要特点有：

1. 二进制协议，不再是纯文本；
2. 可以发起多个请求，废弃1.1的管道；
3. 使用专用算法压缩头部，减少数据传输量；
4. 允许服务器主动向客户端推送数据；
5. 增请了安全性，「事实上」要求加密通信。

尽管HTTP/2.0已经退出几年，但由于HTTP/1.1太过于经典和强势，目前普及率还较低。

[Historical trends in the usage statistics of site elements for websites](https://w3techs.com/technologies/history_overview/site_element/all)

#### HTTP/3.0

在HTTP/2.0处于草案时，Google有发明了一个新的协议QUIC，初始它使用与Chrome。但依托于其庞大的用户量以及数据量，推动QUCI协议称为互联网的既定事实。

2018年，互联网标准化组织将HTTP over QUIC更名为「HTTP/3.0」，HTTP/3正式进入标准化制定阶段。

### HTTP相关概念

#### CDN

浏览器和服务器是HTTP协议的两个端点，但浏览器通常不会直接连接到服务器，而需要通过一些中间节点。其中包含了CDN。

CDN，Content Delivery  Network，内容分发网络。它应用了HTTP协议汇总的缓存和代理技术，代替源站响应客户端的请求。

CND可以缓存源站的数据，让浏览器的请求不用到达源站服务器，直接在中间节点就可以获取响应。一般而言，CDN可以找到距离用户最近的节点， 大幅度降低响应时间。

CDN是如今互联网中一项重要的基础设施，除了可以实现网络加速，还提供负载均衡、安全防护、边缘计算、跨运营商网络等，能够成倍放大源站服务器的服务能力。

#### TCP/IP

TCP/IP协议是目前网络中事实上的标准通信协议。它是一系列网络通信协议的统称，该协议有四层，包含了：应用层、运输层、网络层、链接层。

TCP/IP协议中最重要的两个协议时TCP和IP协议：

+ IP协议，解决寻址和路由问题，以及然后两节点间传输数据。

IP协议使用IP地址来定位互联网上的每一台计算机。目前使用的IP协议版本大多数时v4，其地址使用32位存储，通过「点分十进制」来表示。

+ TCP，传输控制协议，基于IP协议提供可靠的、字节流形式的通信。

「可靠」代表数据不丢失，「字节流」代表数据完整性。

#### DNS

在TCP/IP协议中，IP层使用IP地址来表示计算机。这种数字形式的方式在方便于在计算机中表示，但对于人类而言并不方便记忆和输入。

域名系统（Domain Name System）采用有意义的名字来作为IP地址的等价替代。为了实现域名与IP的等价替换，需要对域名进行解析。

#### URI/URL

TCP/IP中的IP地址标识了网络中的主机，DNS可以帮助我们记忆网络中的主机地址。URI则是可以唯一标识互联网中的资源。

URI，统一资源标识符，通常表示在是URL。URL是URI的一个子集。

URI主要有三个基本部分构成：

+ 协议名：访问该资源使用的协议，如HTTP、FTP等
+ 主机名：互联网主机的标识，如IP地址、域名
+ 路径：资源在主机中的位置，使用「/」分割多级目录

#### HTTPS

通过TCP/IP、DNS和URI，可以方便地定位的互联网任意一台主机的任意文件。但是互联网中的通信是不安全的，为了能够实现数据的安全传输，于是有了HTTPS。

HTTPS相当于HTTP+SSL/TLS+TCP/IP。其中

+ SSL：Secure Socket Layer，由网景公司发明，发展到3.0标准化，改为TLS
+ TLS：Transport Layer Security

SSL使用密码学研究成果，结合对称、非对称加密、摘要算法、数字签名、数字证书等技术，可以在不安全的环境中为通信双方创建宇哥秘密的、安全的传输通道。

[HTTP最佳实践](https://developers.google.com/search/docs/advanced/security/https)

HTTPS是一种互联网通信协议，可以保护用户与网站之间传输数据的完整性与机密性。使用HTTPS发送的数据会被TLS（传输层安全协议）得到保护，包含了三重关键保护：

+ 加密：对交换的数据加密，可以避免隐私数据被别人窃取；
+ 数据完整性：数据在传输节点被修改或损坏都会被检查出来；
+ 身份验证：证明用户是与目标网站通信，保护用户免遭中间人攻击。

使用HTTPS协议时，需要获取安全证书，证书有CA(证书授权机构)办法，CA会验证网站是否属于申请人的组织，从而保护访问者免受中间人攻击。

在使用HTTPS协议之后，之前的HTTP网站可以同永久重定向到HTTPS网页或资源。

#### 代理

代理是HTTP协议中请求返和应答方的中间一环，可以转发客户端的请求，也可以转发服务器的应答。常见的代理有：

+ 匿名代理：完全隐匿被代理的集群，外界看到的只有代理服务器；
+ 透明代理：传输过程中「透明开放」，外界既知道代理，也值得客户端；
+ 正向代理：靠近客户端，代表客户端向服务器发送请求；
+ 反向代理：靠近服务器端，代表服务器响应客户端的请求；

代理在传输过程插入一个「中间层」，因此可以在这里做很多事情：

+ 负载均衡：把访问请求均衡分散到多太机器，实现访问集群化；
+ 内容缓存：缓存上下行数据，减轻后端压力；
+ 安全防护：隐匿IP，使用WAF等工具抵御网络攻击，包含被代理的机器；
+ 数据处理：提供压缩、加密等额外的功能。

### TCP/IP模型

TCP/IP协议是事实上的网络通信标准，TCP通过提出「分层」的概念，把复制的网络通信分为多个层次，在把每个层次分配给不同的职责，层次内只专心做自己的事情。用「分而治之」的思想，可以把大问题拆分为数个小问题，从而解决网络通信的难题。

TCP/IP协议一共有四层，自下而上：

+ 链路层：复制以太网、WIFI等底层网络发送原始数据包，工作在网课上，使用MAC地址标记设备；
+ 网际层：主要包含了IP协议，这一层通过IP地址取代MAC地址，把许多局域网、广域网连接成一个虚拟的大网络，在这个网络找具体设备是需要把IP地址翻译为MAC地址；
+ 传输层：保证IP地址标记的两点之间传输数据。包含TCP和UDP两种协议，TCP是有状态协议，需要先建立连接才能发送数据，能保证数据不重复；UDP是无状态协议，不事先建立连接，可以发送任意数据，不保证数据能够发送到对方。TCP数据是连续的「字节流」，有先后顺序，UDP是否分散的小数据包，是顺序发，乱序收的；
+ 应用层：有各种具体应用协议，如SSH、FTP、SMTP、HTTP等。

TCP/IP在工作时，协议栈会按照以下流程工作(以HTTP通信为例)：

1. HTTP将HTML等超文本数据添加上HTTP协议数据打包成HTTP数据包；
2. TCP层会将HTTP数据包添加上TCP头部；
3. TCP数据包到达网络层会被添加上IP头；
4. 在数据链路层会被添加长MAC头等信息；
5. 接收方收到或者会将其进行依次解包。



### OSI分层模型

TCP/IP发明于1970，当时除了很多其他协议，网络的协议比较混乱。这时国际标准组织未来统一标注，于是提出了OSI模型，将网络分为七层，分别是：

+ 物理层：网络的物理形式，如电缆、光纤、网卡、集线器等；
+ 数据链路层：基本相当于TCP/IP的链路层；
+ 网络层：相当于TCP/IP的网际层；
+ 传输层：相当于TCP/IP的传输层；
+ 会话层：维护网络中的连接状态，即保持会优化和同步；
+ 表示层：把数据转换为合适、可理解的语法和语义；
+ 应用层：面向具体应用传输数据。

鉴于TCP/IP协议已经是事实上的标准，因此OSI发时就表明是一个参考模型，指导具体网络协议的实现。

与TCP/IP协议相比，OSI模型主要有以下特点：

+ TCP/IP是纯软件的协议栈，没有规定网络应有的网络设备；
+ OSI模型通过物理层规范了网络的物理设备；
+ TCP/IP的每一层只有名字没有编号；
+ OSI模型为每一层明确了标号，最底层是第一层，最上面是第七层，便于表示；

![image-20210909133028642](https://gitee.com/tobing/imagebed/raw/master/image-20210909133028642.png)

由于OSI分成模型在四层上划分太细，而TCP/IP实际应用时的会话管理、编码转换、压缩等和具体应用经常联系很紧密，很难分开。如HTTP协议包含了连接管理和数据格式定义。



### HTTP请求的过程

> 通过IP地址的方式进行HTTP请求

HTTP协议运行再TCP/IP协议基础上，使用TCP协议实现数据的可靠传输，因此浏览器要使用HTTP协议收发数据，首先需要建立TCP链接。

抓包分析可以知道，浏览器使用5208端口，服务器使用80端口。经过SYN、SYN/ACK、ACK三个包之后，浏览器与服务器的TCP连接建立起来。

建立了可靠的TCP连接之后，HTTP协议开始工作。于是浏览器开始安装HTTP协议规定的格式，发送一个「GET / HTTP/1.1」的请求报文。

随后Web服务器回来浏览器发送的HTTP请求报文，表示在TCP协议层面收到了该报文。

Web服务器收到报文之后会按照HTTP协议的规定来解析报文，判断浏览器需要进行的动作。

Web服务器通过解析HTTP报文发现需要获取目录下的默认文件，就从磁盘中读取文件，再拼接成HTTP格式的报文，发送回去一个「HTTP/1.1 200 OK」的HTTP包。

浏览器在收到Web服务器的HTTP请求报文之后，也会先服务器回复一个ACK响应，表示TCP协议层面收到了该报文。

浏览器拿到响应数据之后，对内容进行解析，如对HTML、JavaScript、CSS等进行解析。

> 通过域名的方式进行HTTP请求

与通过IP地址方式进行HTTP请求不同，通过域名访问的时候需要多一步将域名转换为IP地址，需要使用DNS进行域名到IP地址的转换。

由于直接使用外部的DNS服务器速度较慢，通常在域名解析的过程存在多级缓存。实现浏览器会先查看本地缓存是否存在需要访问的域名；如果没有会查看操作系统的缓存；如果仍然没有会检查本地的域名解析文件hosts；如果没有才会请求外部的DNS服务器。

+ [Firefox 浏览器缓存](about:networking#dns)

> 真实环境的HTTP请求

1. 访问互联网上的主机时，需要接入到互联网中；
2. 在接入网络时，网络运营商会给设备分配一个IP地址，这些地址通常是动态分配的；
3. 当需要使用域名访问网站时，需要进行域名解析；
4. 一般会经历浏览器缓存、操作系统缓存、本地DNS、根DNS、顶级DNS、权威DNS的解析；
5. 由于CDN的存在，DNS解析的过程可能会得出一个CDN服务器的IP地址；
6. 在CND中，缓存了大部分网站中的静态资源，如图片、CSS，因此会有部分请求不需要发送到APPLE，CDN可以直接响应；
7. 对于由PHP、Java等后台服务器动态生成的页面属于「动态资源」，CDN无法缓存，这是只能从目标网站获取；
8. 目标网站对外表现是一个IP地址，为了保证高并发，内部需要一系列架构机制；
9. 通常服务器的入口是负载均衡设备，如四层LVS或七层Nginx，而后面是许多的服务器过程的集群；
10. 负载均衡设备会先访问系统里的缓存服务器，来减轻后端应用服务器的压力。如Redis等；
11. 至此，一个来自的服务器请求顺利被处理完成，准备将结果返回到浏览器；
12. 响应结果在返回时，仍然需要经过的路由器、网关、代理；
13. 如果一个资源允许缓存，经过CDN时会对其进行缓存，这样一来下次获取该资源就可以直接从CDN返回；
14. 最后，响应结果回到浏览器，被其浏览器解析，如果解析发现存在超链接指向其他资源，会重复上述的过程请求数据，直到所有的数据都下载完。

### HTTP 报文

HTTP协议规范了报文的格式，规定了其组成成分，解析规则，处理策略等。

#### 报文头部(header)

HTTP头数据都是ASCII的文本，容易理解。HTTP协议有三大部分组成：

+ 起始行：描述请求或相应的基本信息，对于请求报文是请求行，响应报文是状态行；【header部分】
+ 头部：使用key-value形式详细说明报文；【header部分】
+ 消息正文：实际传输的数据，不一定是文本，可以是图片、视频等二进制数据。【body】

HTTP协议固定报文必须要由header，body可以没有。

![image-20210909230949756](https://gitee.com/tobing/imagebed/raw/master/image-20210909230949756.png)

**请求行**

请求报文的起始行，简要描述了客户端要如何操作服务端的资源。可以细分为三部分：

+ 请求方法：一个动词，如GET/POST，表示对资源的操作；
+ 请求目标：通常是有个URI，标记了请求方法要操作的资源；
+ 版本号：报文使用的HTTP协议版本。

三部分通常使用空格分隔，最后使用换行表示结束。

**状态行**

响应报文的起始行表示了服务器响应的状态。可以细分为三部分：

+ 版本号：表示报文使用的HTTP协议版本；
+ 状态码：三位数，用代码的形式表示处理结果，如200/500等；
+ 原因：作为数字状态码补充。

**头部字段**

头部字段是key-value形式，key和value之间使用「:」分隔，使用CRLF换行表示字段结束。使用头字段是需要注意以下几点：

1. 字段名不区分大小写；
2. 字段名不允许出现空格，可以使用「-」，不可以使用「_」；
3. 字段名后面必须紧挨着「:」，不能有空格，「:」后字段值有多个空格；
4. 字段的顺序没有意义；
5. 字段原则上不能重复，重复这个字段本身的语义允许，如Set-Cookie。

HTTP协议规定了很多的头部字段，实现了各种功能，但基本上可以分为四大类。

+ 通用字段：在请求头和响应头都可以出现；
+ 请求字段：仅在请求头出现；
+ 响应字段：仅在响应头出现；
+ 实体字段：属于通用字段，专门描述body的额外信息。

host：请求字段，唯一一个HTTP/1.1固定必须出现的字段，告诉服务器这个请求由哪个主机处理，一个计算机托管多个虚拟主机时通过该字段选择；

**user-agent**：请求字段，使用一个字符串描述HTTP请求的客户端，服务器依赖它来返回最合适此浏览器显示的页面；

**date**：通用字段，通常出现在响应头，表示HTTP报文创建的时间，客户端可以使用这个字段搭配其他字段决定缓存策略；

**server**：响应字段，告诉客户端当前Web服务的软件名称和版本号，如百度的BWS/1.1。这个字段会将服务器部分信息暴露给外界，因此可能会存在安全风险；

**content-length**：报文的body长度，没有这个字段表示body不定长，需要使用chunked方式分段传输。

#### 标准请求方法

HTTP/1.1规定了八种方法，单词都必须大写。

+ **GET：获取资源，元老级方法；**

  在URI使用「#」可以在获取页面后直接定位到某个标签所在的位置；使用if-Modified-Since字段就变成了「有条件的请求」，仅当资源内修改时才会执行获取动作；使用Range字段就是「范围请求」，获取资源的一部分数据。

+ **HEAD：获取资源的元信息；**

  HEAD是GET方法简化版，响应头与GET完全相同，可以用在不真正获取资源的场合，避免body数据的浪费；如检查一个文件是否存在，检查文件是否有最新版本；

+ **POST：向资源提交数据；**

  POST和PUT方法相URI指定的资源提交数据，数据放在body中。

  POST通常表示新建，PUT通常表示修改；

+ **PUT：类似POST；**

  PUT使用较少，功能与POST相近。

+ **DELETE：删除资源；**

  DELETE方法指示服务器删除资源。

+ **CONNECT：建立特殊的连接隧道；**

  比较特殊，要求服务器为客户端和另一条远程服务器建立一条特殊的连接隧道，Web服务器在中间充当了代理的角色。

+ **OPTIONS：列出对资源可行的方法；**

  列出可对资源的操作方法，在响应头的Allow字段返回，功能有限。

+ **TRACE：追踪请求-响应的传输路径。**

  对于HTTP链路的测试或诊断，可以显示出请求-响应的传输路径。但存在漏洞，通常被禁用。

安全：在HTTP协议中，安全是指请求方法不会破坏服务器上的资源，即不会对服务器上的资源实际上造成修改，只有GET和HEAD符合。

幂等：多次执行相同的操作，结果相同。GET、PUT和HEAD是幂等的，POST不是幂等的。

> [GET vs POST](https://www.w3schools.com/tags/ref_httpmethods.asp)

【GET】

+ GET请求用于请求特定的资源数据；
+ GET请求中的请求的键值对信息会放到URL上；
+ GET请求可以被缓存；
+ GET请求会保留在浏览器历史；
+ GET请求可以被添加到书签中；
+ GET请求不应该用于处理敏感数据；
+ GET请求有长度的的限制（浏览器上的限制）；
+ GET请求仅仅用来请求数据，而非修改数据；

【POST】

+ POST请求用于发送数据到服务器新建或修改资源；
+ POST请求发送到服务器的数据会保存在请求体中；
+ POST不会被缓存；
+ POST请求的记录不会保存在浏览器历史中；
+ POST请求也可以被添加到书签中；
+ POST请求的长度没有限制；

| 比较          | GET                                                          | POST                                                         |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 返回/重新加载 | 无害的                                                       | 数据会被重新提交                                             |
| 浏览器书签    | 可以添加到书签                                               | 不可以添加到书签                                             |
| 编码类型      | application/x-www-form-urlencoded                            | application/x-www-form-urlencoded;multipart/form-data(二进制使用) |
| 浏览器历史    | 参数保留着浏览器历史记录                                     | 参数不会保存在浏览器历史记录                                 |
| 数据长度限制  | 有限制，发送数据时，GET方法会将数据添加到URL上；URL的长度会被限制（最大的URL长度是2048个字符） | 无限制                                                       |
| 数据类型限制  | 仅允许ASCII字符                                              | 无限制，二进制数据也被允许                                   |
| 安全性        | GET不POST安全性要差，因为数据在URL中展示；不要使用GET发送密码等敏感信息 | POST比GET更加安全，因为参数不会保存在浏览器历史或Web服务器日志中 |
| 可见性        | 对接在URL中，对每个人可见                                    | 数据不会展示在URL中                                          |

#### HTTP实体内容(body)

> 数据类型与数据压缩

HTTP实体部分可以是各种各样的数据，数据的类型通过[MIME标准](https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%94%A8%E9%80%94%E4%BA%92%E8%81%AF%E7%B6%B2%E9%83%B5%E4%BB%B6%E6%93%B4%E5%B1%95)来表示。【MIME type】

除此之外，为了提供传输效率，HTTP协议有时候还会压缩数据。【Encoding type】

有了MIME type以及Encoding Type，浏览器和服务器都可以轻松识别body中的数据类型，进而正确处理数据。

HTTP协议还定义了用于客户端和服务器进行「内容协商」的字段。

+ 客户端使用Accept头告诉服务器希望接收的数据；
+ 服务器使用Content头告诉客户端实际发送的数据；

```sh
# 【request headers】

accept: text/html,application/xhtml+xml,application/xml;	# 客户端支持的数据类型
accept-encoding: gzip, deflate, br		# 客户端支持的编码压缩类型
accept-language: zh-CN,zh;q=0.9,en;q=0.8# 客户端期望的自然语言类型

# 【response headers】

content-encoding: gzip		# 服务器返回内容的压缩方式
content-language: zh		# 服务器返回内容的自然语言类型
content-length: 20628		# 服务器返回内容的长度
content-type: text/html; charset=UTF-8		# 服务器返回的内容格式

vary: Accept-Encoding,Cookie,Accept-Language,Authorization	# 服务器在内容协商时参考的请求头字段
```

通过数据压缩的方式可以一定程度地压缩请求内容的大小，提供传输效率。

> 数据分块

除此之外，HTTP还会通过使用「分块传输」的方式，将大文件拆分为多个小文件，分批次发给浏览器，浏览器收到之后在进行组装。HTTP协议中通过「chunked」表示数据分块。

分块传输除了可以用于传输大文件，还可以用于「流式数据」处理。如数据库动态生成的表单页，body数据的长度未知，无法在「content-length」给出切确长度，只能用chunked方式分块发送。

从上面可以知道chunked与content-length是互斥的。

分块传输的编码规则实现起来比较简单，采用明文的方式表示，每个分块包含两部分：

+ 长度头：使用16进制表示长度；CRLF结尾
+ 数据块：真实的数据块；CRLF结尾

数据分块的最后会使用一个长度为0的块表示结束。

> 范围请求

有了分块编码，可以轻松收发大文件，但对于超大文件，有时候需要对其进行范围访问。如在使用B站看动漫的时候，有时候我们会拖动跳过开头的OP(片头曲)，这时就需要对数据进行范围访问。HTTP协议通过两部分字段来实现对访问请求的支持。

+ Content-Range：表示服务器支持的范围请求；
+ range：表示客户端请求的数据范围

需要注意，range的大小必须在Content-Range范围之内，否则会返回416错误；如果range范围正确，服务器会计算range的偏移，读取文件片段，返回206状态码(Partial Content)，表示请求了原数据的部分内容。

除了可以实现视频的进度拖拽，常用下载工具中的**多段下载、断点续传**也是基于这个来实现，要点如下：

1. 发送HEAD，查看服务器是否支持范围请求，并获取文件大小；
2. 开启N个线程，每个线程使用range字段划分出各自负责下载的片段，发请求传输数据；
3. 下载中断时，只需要根据上传的下载记录，用range请求剩下的部分即可；

[断点续传实战](https://cloud.tencent.com/developer/article/1541199)

### HTTP 特性

#### 长连接与短链接

HTTP底层的数据基于TCP/IP。早期每次发送请求前需要先与服务器建立连接，收到响应报文之后会立即关闭连接。这种方式客户端与服务器的整个连接过程很短暂，因此被称为「短链接」。

显然，短链接想到耗费资源，没发送一个HTTP请求，需要包含：TCP三次握手+TCP四次挥手+请求报文+TCP的ACK报文。

针对于短链接暴露出来的缺点，HTTP协议提出了「长连接」。使用长连接时每次可以在一个TCP会话中进行多次HTTP请求。

HTTP/1.1开始，默认是「长连接」，通过`connection:keep-alive`字段表述是一个长连接。

尽管「长连接」降低重复的TCP建立以及释放的报文，但是TCP连接长时间不被关闭，会占用服务器的资源。在并发较高的场景，将可能导致资源耗尽，无法正常为真正有需要的用户提供访问。

#### 队头阻塞

由于HTTP是基于「请求-应答」模型，HTTP规定报文「一发一收」，形成一个先进先出的「串行」队列。这样，如果队首的请求因为处理太慢延误了时间，那么队列中后面的请求将不得不要一起等待。

由于HTTP/1.1是基于「请求-应答」模型，因此无法从根本解决队头阻塞的问题。HTTP/1.1通过「并发连接」的方式来缓解队头阻塞的问题。即允许每个客户端与服务器端创建多个连接来实现较少队头阻塞发生的情况。

#### TCP缺点

由于TCP协议存在「慢启动」、「拥塞窗口」等特性，通常创建的「新连接」会比打开了一段时间的「热连接」要慢一点，因此长连接比短连接多一层优势。

#### 重定向

在浏览器中， 存在两种跳转。

+ 主动挑战：浏览器使用者主动发起；
+ 被动跳转：由服务器发起的跳转，这种方式有被称为「重定向」。

重定向按照时效性，又可以分为两种：

+ 永久重定向：原来的URI永久性不存在，今后的所有请求必须用新的URI。服务器会返回301状态码表征，浏览器收到之后可以更新书签等优化。常用于新域名、服务器更换，需要通知浏览器浏览器和搜索引擎更新到新地址；
+ 临时重定向：原来的URI处于为临时维护状态，新的URI是临时的。服务器会返回302状态码表征，浏览器只会执行简单的跳转页面，不记录新的URI。常用于不重要的功能入口暂时关闭，保证核心服务能够正常运行。

重定向使用时存在两个问题：

+ 性能损耗：重定向机制决定了跳转了两次请求-应答。站内重定向可以长连接复用，但是站外定向要打开两个连接。
+ 循环跳转：重定向的策略设置可以会出现循环的情况，如之前实现Cookie遇到了循环的问题。

#### 无状态

HTTP是无状态，但是HTTP记录用户请求的状态又是很有必要的，于是人们引入了一些机制来支持HTTP实现状态记忆。

> Cookie机制

一种方式就是使用Cookie来记录客户端的信息，在每次请求的时候服务器可以通过Cookie可以实现找他的记忆。

Cookie的实现主要需要使用两个字段：set-cookie和cookie。

1. 用户第一次访问服务器时，服务器不知道其身份，会为其创建一个身份标识；
2. 身份标识的格式为「key=value」，会被放到响应头部的「set-cookie」字段返回给浏览器；
3. 浏览器收到响应报文之后，如果发现「set-cookie」，会将其保存下来，下次请求是会把这个值发送到服务器；
4. 用户通过浏览器第二次访问服务器时，服务器可以通过cookie识别用户身份，实现个性化功能；
5. 有一个「key=value」的能力有限，服务器支持为响应头添加多个「set-cookie」；
6. 与服务器不同，浏览器在发送多个cookie时将其放到一行，使用；分割；

> Cookie安全

显然，Cookie有浏览器负责储存，而不是操作系统，因此Cookie的作用域是浏览器中。由于Cookie是储存在浏览器中，而这些数据通常是关键信息，因此需要使用一些手段来防止泄密。

+ 设置生命周期：使用Expires和Max-Age两个属性来设置Cookie的作用时间；
  + Expires：过期时间，绝对时间，可以理解为deadline；
  + Max-Age：收到报文的时间加上Max-Age可以得到失效时间，相对时间，单位秒；【优先使用】
  + 如果两者都不指定，Cookie仅在浏览器运行时有效；
+ 设置作用域：通过Domain设置Cookie所属域名，Path指定Cookie所属路径；
+ 规避跨站脚本(XSS)：httponly会告诉浏览器此Cookie只能通过HTTP协议传输，禁止其他方式访问，浏览器JS引擎会禁用操作cookie的一切API，脚本攻击页也无从谈起。
+ 规避跨站请求伪造(XSPF)：samesite可以规范XSRF攻击，可以严格限定Cookie不能随着跳转连接跨站发送。

> Cookie应用

Cookie使得服务器有记忆能力，保存客户端的状态。

Cookie的一个基本用途是身份识别，保存用户的登录信息，实现会话事务。

Cookie另一个常见用途是广告跟踪。

#### 缓存控制

HTTP分为服务器端和客户端，除此之外还可以会存在代理服务器，因此缓存主要与以下三种相关。

> 服务器缓存控制

## HTTPS

HTTP是不安全的协议，传输的过程使用的是明文的方式进行传输。

安全的通信过程通常会具备以下四个特性：

+ 机密性：对数据加密，只能由可信的人访问；
+ 完整性：数据在传输过程中没有被篡改；
+ 身份认证：能证明对方的真实的身份；
+ 不可否认：发生的行为具有不可否认性；

HTTPS是一个具备上述特性的安全协议。RFC协议中，HTTPS只有7页，非常简单，这是因为处理安全部分，其他大部分都复用了HTTP协议的内容。

与HTTP相比，HTTPS协议将HTTP下层的TCP/IP协议换成了SSL/TLS。收发报文页不再使用Socket API而是调用专门的安全接口。

![image-20210912204839622](https://gitee.com/tobing/imagebed/raw/master/image-20210912204839622.png)

### SSL/TLS

SSL，Secure Sockets Layer，位于OSI的会话层，有网景公司发明；SSL发展到v3时被改名为TLS(Transport Layer Security)，正式标准化。

TLS由路由协议、握手协议、警告协议、变更密码规范协议、扩展协议等几个子协议组成，综合使用能力对称加密、非对称加密、身份认证等许多密码学前沿技术。

浏览器和服务器使用TLS建立连接时，需要使用一组密码套件来实现安全通信，密码套件格式为「**密钥交换算法+签名算法+对称加密算法+摘要算法**」。

TLS中使用混合加密的方式进行通信：

+ 通信刚开始时使用非对称算法，解决密钥交换的问题；
+ 在安全交换了对称密钥之后，全程使用对称加密来机密数据；

使用混合加密的方式可以保证数据传输的安全性，但是不能确保对方是否是真正自己想要访问的服务器。这时需要借助数字签名。

#### 数字签名

数字签名原理比较简单，即采用非对称算法，使用私钥对数据进行加密，对方通过公钥进行解密。由于如果加密原文，会导致加密时间较长，而报文摘要与原文具有相同的表征含义且长度固定，因此只需要机密元素的报文摘要即可。

这样一来，由于私钥只有对方知道，如果对方的公钥能够正确机密这段数据，表示这段数据一定是对方的发送过来的。

#### 数字证书与CA

引入了数字签名，还有一个问题：公钥的可信度问题。

由于任意人都可以通过开源工具生成密钥对，如果黑客伪装成一个源站， 发送自己的公钥给对方，这样就整个通信就处于不安全状态。

为了保证公钥可信度，只信任通过特定机构颁发的公钥，这个机构就是CA。

CA在对公钥认证时，会将序列化、用途、颁发者、有效时间等打包签名，形成一个「数字证书」。

由于CA是知名且可行的，因此其公钥也是可信。

![image-20210912212017275](https://gitee.com/tobing/imagebed/raw/master/image-20210912212017275.png)

#### TLS组成

TLS包含几个子协议，常用的有记录协议、警告协议、握手协议、变更密码规范协议。

+ 记录协议：规定TLS收发数据的基本单位；
+ 警报协议：相对发发出警报信息，如不支持旧版本、证书有问题；
+ 握手协议：协商TLS版本号、随机数、密码套件等信息；
+ 变更密码规范协议：告诉对方后继的数据是明文。

#### TLS握手过程

TLS握手的过程如下：

![image-20210912213932249](https://gitee.com/tobing/imagebed/raw/master/image-20210912213932249.png)  

1. 三次握手建立TCP连接；
2. 客户端发送「Client Hello」；
   + Client Hello：客户端版本(Version)、支持的密码套件(Chiper suites)、随机数(Random)
3. 服务器返回「Server Hello/Certificate/Server Key Exchange/Server Hello Done」
   + Server Hello：随机数(Server Random)、本次使用的密码套件
   + Certificate：服务端的数字证书
   + Server Key Exchange：ECDHE的公钥
   + Server Hello Done：TLS握手完毕
4. 客户端拿到服务器证书，逐级验证证书的真实性，使用证书验证签名，确认服务器的身份；
5. 客户端发送「Client Key Exchange/Change Chipher Spec/Encrypted Handshake Message」
   + Client Key Exchange：根据密码套件生成一个ECDHE公钥
   + Change Cipher Spec：改变密码规范，即后面开始改用对称机密方式
   + Encrypted Handshake Message：

### HTTPS优化

HTTPS连接大致可以划分为两部分：

+ 建立连接时使用非对称加密握手；
+ 握手之后的对称加密报文传输；

与HTTP相比，HTTPS主要增加了TLS握手过程，其中还包含了一些隐性消耗：

+ 产生密钥交换的临时公私钥对ECHDE；
+ 验证证书是访问CA获取CRL或OCSP；
+ 非对称加密解密处理；

计算机中优化可以分为「硬件优化」和「软件优化」：

> 硬件优化

HTTPS是计算密集型，不是I/O密集型，对于加快网卡、带宽、SSD储存堆优化效果影响不大。采用硬件优化可以选择：

+ 更快的CPU：加速加密解密，内建AES优化
+ SSL加速卡：加速加密解密，调用特定API
+ SSl加速服务器：让加密解密运算通过专门的集群计算。

> 软件优化

软件优化可以分为：软件升级、协议优化、证书优化、会话复用

+ 软件优化：升级Linux内核、Nginx版本、OpenSSL等；
+ 协议优化：尽量使用TLS1.3；
+ 证书优化：优化证书传输(使用ECDSA取代RSA)、优化证书验证；
+ 会话复用：将主密钥缓存重用





























