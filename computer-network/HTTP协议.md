# HTTP协议

## 概述

### HTTP简介

HTTP，超文本传输协议。

+ 协议：HTTP是一个用于计算机世界的协议，使用计算机能够理解的语言确立一种计算机之间交流通信的规范，以及相关的各种控制和错误处理的方式。
+ 传输：HTTP是一个在计算机中专门用于两点间传输数据的约定和规范。
+ 超文本：超文本意味着超越了普通文本，能够从一个超文本跳转到另一个超文本。

HTTP是计算机中专门用于两点之间传送文字、图片、音频、视频等超文本数据的约定和规范。

HTTP不是孤立的协议，通常运行在TCP/IP协议栈之上，依靠IP协议实现寻址和路由、TCP协议可以是实现可靠传输、DNS协议实现域名炒作、SSL/TLS协议实现安全通信。

### HTTP发展

#### HTTP/1.0

HTTP/1.0 版本在 1996 年正式发布 ，相比于0.9版本，有以下区别：

1. 增加HEAD、POST等新方法；
2. 增加了响应状态码，标记可能的错误原因；
3. 引入协议版本号的概念；
4. 引入了HTTP Header概念，让HTTP处理请求和响应更加灵活；
5. 传输的数据不再仅限与文本。

HTTP/1.0不是一个「标准」，只是记录实践和模式的参考文档，不具有收集约束力。

#### HTTP/1.1

1999 年，HTTP/1.1发布了RFC文档（编号为 2616），正式确立了延续十余年的传奇。HTTP/1.1是对HTTP/1.0的小幅度修正，但它是一个「正式标准」。相比于HTTP/1.0，HTTP/1.1主要有以下改变：

1. 添加PUT、DELETE等新方法；
2. 增加缓存管理和控制；
3. 明确连接管理、允许持久连接；
4. 允许响应数据的分开，有利于传输大文件；
5. 强制要求Host头，让互联网主机托管称为可能。

HTTP/1.1的推出是众望所归，互联网在它的保驾护航下迈开大步，由此走上了康庄大道，开启了后继的Web1.0、Web2.0的时代。

由于HTTP/1.1太过与庞大而复杂，因此在2014年又做了一次修订，原来的一个大文档被拆分成了六份较小的文档，编号为 7230-7235，优化了一些细节，但此外没有任何实质性的改动。  

#### HTTP/2.0

HTTP/1.1发布之后，互联网呈现爆发式增长，这期间也出现了对HTTP不满的意见。主要是连接慢，无法跟上迅速发展的互联网。由于HTTP/1.1一致岿然不动，后来Google实现开发了浏览器的Chrome，然后退出了新的SPDY协议。由于Chrome的用户占有率高，互联网标准化组织以Google的SPDY为基础开始制定新的HTTP协议。

2015年，HTTP/2.0发布，RFC编号7540。HTTP/2.0的制定充分考虑了当今互联网的现状：宽带、移动、不安全，在高度兼容HTTP/1.1的同时性能方面进行了很多的努力，主要特点有：

1. 二进制协议，不再是纯文本；
2. 可以发起多个请求，废弃1.1的管道；
3. 使用专用算法压缩头部，减少数据传输量；
4. 允许服务器主动向客户端推送数据；
5. 增请了安全性，「事实上」要求加密通信。

尽管HTTP/2.0已经退出几年，但由于HTTP/1.1太过于经典和强势，目前普及率还较低。

[Historical trends in the usage statistics of site elements for websites](https://w3techs.com/technologies/history_overview/site_element/all)

#### HTTP/3.0

在HTTP/2.0处于草案时，Google有发明了一个新的协议QUIC，初始它使用与Chrome。但依托于其庞大的用户量以及数据量，推动QUCI协议称为互联网的既定事实。

2018年，互联网标准化组织将HTTP over QUIC更名为「HTTP/3.0」，HTTP/3正式进入标准化制定阶段。

### HTTP相关概念

#### CDN

浏览器和服务器是HTTP协议的两个端点，但浏览器通常不会直接连接到服务器，而需要通过一些中间节点。其中包含了CDN。

CDN，Content Delivery  Network，内容分发网络。它应用了HTTP协议汇总的缓存和代理技术，代替源站响应客户端的请求。

CND可以缓存源站的数据，让浏览器的请求不用到达源站服务器，直接在中间节点就可以获取响应。一般而言，CDN可以找到距离用户最近的节点， 大幅度降低响应时间。

CDN是如今互联网中一项重要的基础设施，除了可以实现网络加速，还提供负载均衡、安全防护、边缘计算、跨运营商网络等，能够成倍放大源站服务器的服务能力。

#### TCP/IP

TCP/IP协议是目前网络中事实上的标准通信协议。它是一系列网络通信协议的统称，该协议有四层，包含了：应用层、运输层、网络层、链接层。

TCP/IP协议中最重要的两个协议时TCP和IP协议：

+ IP协议，解决寻址和路由问题，以及然后两节点间传输数据。

IP协议使用IP地址来定位互联网上的每一台计算机。目前使用的IP协议版本大多数时v4，其地址使用32位存储，通过「点分十进制」来表示。

+ TCP，传输控制协议，基于IP协议提供可靠的、字节流形式的通信。

「可靠」代表数据不丢失，「字节流」代表数据完整性。

#### DNS

在TCP/IP协议中，IP层使用IP地址来表示计算机。这种数字形式的方式在方便于在计算机中表示，但对于人类而言并不方便记忆和输入。

域名系统（Domain Name System）采用有意义的名字来作为IP地址的等价替代。为了实现域名与IP的等价替换，需要对域名进行解析。

#### URI/URL

TCP/IP中的IP地址标识了网络中的主机，DNS可以帮助我们记忆网络中的主机地址。URI则是可以唯一标识互联网中的资源。

URI，统一资源标识符，通常表示在是URL。URL是URI的一个子集。

URI主要有三个基本部分构成：

+ 协议名：访问该资源使用的协议，如HTTP、FTP等
+ 主机名：互联网主机的标识，如IP地址、域名
+ 路径：资源在主机中的位置，使用「/」分割多级目录

#### HTTPS

通过TCP/IP、DNS和URI，可以方便地定位的互联网任意一台主机的任意文件。但是互联网中的通信是不安全的，为了能够实现数据的安全传输，于是有了HTTPS。

HTTPS相当于HTTP+SSL/TLS+TCP/IP。其中

+ SSL：Secure Socket Layer，由网景公司发明，发展到3.0标准化，改为TLS
+ TLS：Transport Layer Security

SSL使用密码学研究成果，结合对称、非对称加密、摘要算法、数字签名、数字证书等技术，可以在不安全的环境中为通信双方创建宇哥秘密的、安全的传输通道。

#### 代理

代理是HTTP协议中请求返和应答方的中间一环，可以转发客户端的请求，也可以转发服务器的应答。常见的代理有：

+ 匿名代理：完全隐匿被代理的集群，外界看到的只有代理服务器；
+ 透明代理：传输过程中「透明开放」，外界既知道代理，也值得客户端；
+ 正向代理：靠近客户端，代表客户端向服务器发送请求；
+ 反向代理：靠近服务器端，代表服务器响应客户端的请求；

代理在传输过程插入一个「中间层」，因此可以在这里做很多事情：

+ 负载均衡：把访问请求均衡分散到多太机器，实现访问集群化；
+ 内容缓存：缓存上下行数据，减轻后端压力；
+ 安全防护：隐匿IP，使用WAF等工具抵御网络攻击，包含被代理的机器；
+ 数据处理：提供压缩、加密等额外的功能。

### TCP/IP模型

TCP/IP协议是事实上的网络通信标准，TCP通过提出「分层」的概念，把复制的网络通信分为多个层次，在把每个层次分配给不同的职责，层次内只专心做自己的事情。用「分而治之」的思想，可以把大问题拆分为数个小问题，从而解决网络通信的难题。

TCP/IP协议一共有四层，自下而上：

+ 链路层：复制以太网、WIFI等底层网络发送原始数据包，工作在网课上，使用MAC地址标记设备；
+ 网际层：主要包含了IP协议，这一层通过IP地址取代MAC地址，把许多局域网、广域网连接成一个虚拟的大网络，在这个网络找具体设备是需要把IP地址翻译为MAC地址；
+ 传输层：保证IP地址标记的两点之间传输数据。包含TCP和UDP两种协议，TCP是有状态协议，需要先建立连接才能发送数据，能保证数据不重复；UDP是无状态协议，不事先建立连接，可以发送任意数据，不保证数据能够发送到对方。TCP数据是连续的「字节流」，有先后顺序，UDP是否分散的小数据包，是顺序发，乱序收的；
+ 应用层：有各种具体应用协议，如SSH、FTP、SMTP、HTTP等。

TCP/IP在工作时，协议栈会按照以下流程工作(以HTTP通信为例)：

1. HTTP将HTML等超文本数据添加上HTTP协议数据打包成HTTP数据包；
2. TCP层会将HTTP数据包添加上TCP头部；
3. TCP数据包到达网络层会被添加上IP头；
4. 在数据链路层会被添加长MAC头等信息；
5. 接收方收到或者会将其进行依次解包。





### OSI分层模型

TCP/IP发明于1970，当时除了很多其他协议，网络的协议比较混乱。这时国际标准组织未来统一标注，于是提出了OSI模型，将网络分为七层，分别是：

+ 物理层：网络的物理形式，如电缆、光纤、网卡、集线器等；
+ 数据链路层：基本相当于TCP/IP的链路层；
+ 网络层：相当于TCP/IP的网际层；
+ 传输层：相当于TCP/IP的传输层；
+ 会话层：维护网络中的连接状态，即保持会优化和同步；
+ 表示层：把数据转换为合适、可理解的语法和语义；
+ 应用层：面向具体应用传输数据。

鉴于TCP/IP协议已经是事实上的标准，因此OSI发时就表明是一个参考模型，指导具体网络协议的实现。

与TCP/IP协议相比，OSI模型主要有以下特点：

+ TCP/IP是纯软件的协议栈，没有规定网络应有的网络设备；
+ OSI模型通过物理层规范了网络的物理设备；
+ TCP/IP的每一层只有名字没有编号；
+ OSI模型为每一层明确了标号，最底层是第一层，最上面是第七层，便于表示；

![image-20210909133028642](https://gitee.com/tobing/imagebed/raw/master/image-20210909133028642.png)

由于OSI分成模型在四层上划分太细，而TCP/IP实际应用时的会话管理、编码转换、压缩等和具体应用经常联系很紧密，很难分开。如HTTP协议包含了连接管理和数据格式定义。



### HTTP请求的过程

> 通过IP地址的方式进行HTTP请求

HTTP协议运行再TCP/IP协议基础上，使用TCP协议实现数据的可靠传输，因此浏览器要使用HTTP协议收发数据，首先需要建立TCP链接。

抓包分析可以知道，浏览器使用5208端口，服务器使用80端口。经过SYN、SYN/ACK、ACK三个包之后，浏览器与服务器的TCP连接建立起来。

建立了可靠的TCP连接之后，HTTP协议开始工作。于是浏览器开始安装HTTP协议规定的格式，发送一个「GET / HTTP/1.1」的请求报文。

随后Web服务器回来浏览器发送的HTTP请求报文，表示在TCP协议层面收到了该报文。

Web服务器收到报文之后会按照HTTP协议的规定来解析报文，判断浏览器需要进行的动作。

Web服务器通过解析HTTP报文发现需要获取目录下的默认文件，就从磁盘中读取文件，再拼接成HTTP格式的报文，发送回去一个「HTTP/1.1 200 OK」的HTTP包。

浏览器在收到Web服务器的HTTP请求报文之后，也会先服务器回复一个ACK响应，表示TCP协议层面收到了该报文。

浏览器拿到响应数据之后，对内容进行解析，如对HTML、JavaScript、CSS等进行解析。

> 通过域名的方式进行HTTP请求

与通过IP地址方式进行HTTP请求不同，通过域名访问的时候需要多一步将域名转换为IP地址，需要使用DNS进行域名到IP地址的转换。

由于直接使用外部的DNS服务器速度较慢，通常在域名解析的过程存在多级缓存。实现浏览器会先查看本地缓存是否存在需要访问的域名；如果没有会查看操作系统的缓存；如果仍然没有会检查本地的域名解析文件hosts；如果没有才会请求外部的DNS服务器。

+ [Firefox 浏览器缓存](about:networking#dns)

> 真实环境的HTTP请求

1. 访问互联网上的主机时，需要接入到互联网中；
2. 在接入网络时，网络运营商会给设备分配一个IP地址，这些地址通常是动态分配的；
3. 当需要使用域名访问网站时，需要进行域名解析；
4. 一般会经历浏览器缓存、操作系统缓存、本地DNS、根DNS、顶级DNS、权威DNS的解析；
5. 由于CDN的存在，DNS解析的过程可能会得出一个CDN服务器的IP地址；
6. 在CND中，缓存了大部分网站中的静态资源，如图片、CSS，因此会有部分请求不需要发送到APPLE，CDN可以直接响应；
7. 对于由PHP、Java等后台服务器动态生成的页面属于「动态资源」，CDN无法缓存，这是只能从目标网站获取；
8. 目标网站对外表现是一个IP地址，为了保证高并发，内部需要一系列架构机制；
9. 通常服务器的入口是负载均衡设备，如四层LVS或七层Nginx，而后面是许多的服务器过程的集群；
10. 负载均衡设备会先访问系统里的缓存服务器，来减轻后端应用服务器的压力。如Redis等；
11. 至此，一个来自的服务器请求顺利被处理完成，准备将结果返回到浏览器；
12. 响应结果在返回时，仍然需要经过的路由器、网关、代理；
13. 如果一个资源允许缓存，经过CDN时会对其进行缓存，这样一来下次获取该资源就可以直接从CDN返回；
14. 最后，响应结果回到浏览器，被其浏览器解析，如果解析发现存在超链接指向其他资源，会重复上述的过程请求数据，直到所有的数据都下载完。

### HTTP 报文

HTTP协议规范了报文的格式，规定了其组成成分，解析规则，处理策略等。

#### 报文头部

HTTP头数据都是ASCII的文本，容易理解。HTTP协议有三大部分组成：

+ 起始行：描述请求或相应的基本信息，对于请求报文是请求行，响应报文是状态行；【header部分】
+ 头部：使用key-value形式详细说明报文；【header部分】
+ 消息正文：实际传输的数据，不一定是文本，可以是图片、视频等二进制数据。【body】

HTTP协议固定报文必须要由header，body可以没有。

![image-20210909230949756](https://gitee.com/tobing/imagebed/raw/master/image-20210909230949756.png)

**请求行**

请求报文的起始行，简要描述了客户端要如何操作服务端的资源。可以细分为三部分：

+ 请求方法：一个动词，如GET/POST，表示对资源的操作；
+ 请求目标：通常是有个URI，标记了请求方法要操作的资源；
+ 版本号：报文使用的HTTP协议版本。

三部分通常使用空格分隔，最后使用换行表示结束。

**状态行**

响应报文的起始行表示了服务器响应的状态。可以细分为三部分：

+ 版本号：表示报文使用的HTTP协议版本；
+ 状态码：三位数，用代码的形式表示处理结果，如200/500等；
+ 原因：作为数字状态码补充。

**头部字段**

头部字段是key-value形式，key和value之间使用「:」分隔，使用CRLF换行表示字段结束。使用头字段是需要注意以下几点：

1. 字段名不区分大小写；
2. 字段名不允许出现空格，可以使用「-」，不可以使用「_」；
3. 字段名后面必须紧挨着「:」，不能有空格，「:」后字段值有多个空格；
4. 字段的顺序没有意义；
5. 字段原则上不能重复，重复这个字段本身的语义允许，如Set-Cookie。

HTTP协议规定了很多的头部字段，实现了各种功能，但基本上可以分为四大类。

+ 通用字段：在请求头和响应头都可以出现；
+ 请求字段：仅在请求头出现；
+ 响应字段：仅在响应头出现；
+ 实体字段：属于通用字段，专门描述body的额外信息。

host：请求字段，唯一一个HTTP/1.1固定必须出现的字段，告诉服务器这个请求由哪个主机处理，一个计算机托管多个虚拟主机时通过该字段选择；

**user-agent**：请求字段，使用一个字符串描述HTTP请求的客户端，服务器依赖它来返回最合适此浏览器显示的页面；

**date**：通用字段，通常出现在响应头，表示HTTP报文创建的时间，客户端可以使用这个字段搭配其他字段决定缓存策略；

**server**：响应字段，告诉客户端当前Web服务的软件名称和版本号，如百度的BWS/1.1。这个字段会将服务器部分信息暴露给外界，因此可能会存在安全风险；

**content-length**：报文的body长度，没有这个字段表示body不定长，需要使用chunked方式分段传输。

#### 标准请求方法

HTTP/1.1规定了八种方法，单词都必须大写。

+ **GET：获取资源，元老级方法；**

  在URI使用「#」可以在获取页面后直接定位到某个标签所在的位置；使用if-Modified-Since字段就变成了「有条件的请求」，仅当资源内修改时才会执行获取动作；使用Range字段就是「范围请求」，获取资源的一部分数据。

+ **HEAD：获取资源的元信息；**

  HEAD是GET方法简化版，响应头与GET完全相同，可以用在不真正获取资源的场合，避免body数据的浪费；如检查一个文件是否存在，检查文件是否有最新版本；

+ **POST：向资源提交数据；**

  POST和PUT方法相URI指定的资源提交数据，数据放在body中。

  POST通常表示新建，PUT通常表示修改；

+ **PUT：类似POST；**

  PUT使用较少，功能与POST相近。

+ **DELETE：删除资源；**

  DELETE方法指示服务器删除资源。

+ **CONNECT：建立特殊的连接隧道；**

  比较特殊，要求服务器为客户端和另一条远程服务器建立一条特殊的连接隧道，Web服务器在中间充当了代理的角色。

+ **OPTIONS：列出对资源可行的方法；**

  列出可对资源的操作方法，在响应头的Allow字段返回，功能有限。

+ **TRACE：追踪请求-响应的传输路径。**

  对于HTTP链路的测试或诊断，可以显示出请求-响应的传输路径。但存在漏洞，通常被禁用。

安全：在HTTP协议中，安全是指请求方法不会破坏服务器上的资源，即不会对服务器上的资源实际上造成修改，只有GET和HEAD符合。

幂等：多次执行相同的操作，结果相同。GET、PUT和HEAD是幂等的，POST不是幂等的。

















