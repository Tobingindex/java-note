# MySQL

参考资料：

《MySQL必知必会》

《Java开发手册》

## 基本概念

> 简述对存储过程的理解

+ MySQL 5开始添加了存储过程的支持；
+ 存在一些SQL需要针对多张表编写多条SQL语句；
+ 除此之外，需要执行的具体语句的顺序不合适固定的，需要根据查询条件确定；
+ 使用储存过程可以创建包含一条或多条MySQL语句的集合，用于复用；
+ 使用存储过程主要有3个好处，简单、安全、高性能。
+ 简单：存储过程将多条SQL封装起来，使用者只需要调用即可；
+ 安全：业务的修改仅需要改变存储过程内部逻辑即可，可以减少Bug出现的概率；
+ 高性能：使用储存过程比单独使用MySQL更快；
+ 总而言之，储存过程类似于一个函数，可以将复杂的SQL操作封装到一个存储过程中；
+ 存储过程的使用者无需指定请内部的实现逻辑便可以直接调用；

+ 在《Java开发手册》禁止使用存储过程，因为存储过程难以调试和扩展，没有移植性；



> 简述对触发器的理解

+ MySQL 5开始添加了对触发器的支持；
+ 与其他DMBS相比，MySQL 5支持的触发器功能有限；
+ 触发器可以在某些事件发生时自动执行；
+ 在MySQL中触发器可以响应DELETE/INSERT/UPDATE三种语句；
+ 创建触发器的时候需要使用安全访问权限，触发器是自动执行的；
+ 如果INSRT、UPDATE、DELETE能够执行，相关的触发器也能执行；
+ 使用触发器可以保证数据的一致性，如大小写、格式等；



> 简述SQL中左连接和右连接的区别

+ 左连接与右连接都是外连接的一种，两者主要区别是驱动表不一样；
+ 在外连接查询时，第一个要需要查询的表称为驱动表；
+ 左连接选择左边为驱动表；右连接选择右边为驱动表；
+ 对于外连接，需要先针对驱动表查询得到的结果，分别到被驱动表中查找匹配；
+ 当驱动表的记录在被驱动表招不到匹配的时候，仍然需要加入结果集中；
+ 如对于左连接而言，需要根据where条件确定出在左边表的记录；
+ 之后根据左边表的记录依次到右边表中根据on进行匹配；
+ 如果匹配则将左右两边的记录加入结果集，反之将左边记录加入结果集；



> 简述对数据库中锁的理解

+ 锁是保证并发事务下数据一致性的一种手段；
+ 锁的对象是事务，用于锁定数据库中的独享，如表、页、行；
+ 一般而言锁的对象在事务commit或rollback之后机型释放；
+ 锁本质上是内存中的一个结构，当一个事务想要对记录进行修改，首先会看内存中有没有这条记录的锁结构；
+ 在MySQL中锁按照事务操作的行为可以分为读写锁，按照事务操作的对象访问可以将锁分为多粒度锁；
+ 在MySQL中，不同存储引擎多锁的支持不一样；
+ 对于InnoDB支持的粒度最小的锁是行锁、MyISAM支持的粒度做小的锁是表锁；



> 简述对表锁、行锁以及页锁的理解

+ InnoDB支持不同粒度的锁；



简述对行锁的实现方法分类的理解
简述对数据库中锁升级的理解
简述对死锁以及解决死锁的理解
简述对数据库中悲观锁和乐观锁的理解
简述对事务的理解
简述数据库并发操作可能产生的异常(4种)
简述对事务隔离级别的理解
简述不可重复读和幻读的区别
简述对Record Lock、Gap Lock以及Next-Key Lock的理解
简述对数据库中封锁的理解.
简述数据库事务的传播行为
简述第一范式、第二范式与第三范式各自做了什么?

## 引擎

> 简述对数据库引擎的认识

+ 插件式的表存储引擎是MySQL区别于其他数据库的最重要特点；
+ MySQL的架构划分为两部分：Server层和存储引擎层；
+ Sever层提供了一系列数据库系统必须的，但与存储引擎无关的接口，而存储引擎层则主要负责底层物理结构的实现；
+ MySQL定义了存储引擎层的接口，不同的储存引擎可以在遵循这个接口的基础实现不同的细节；
+ 存储引擎的好处是，每个存储引擎都有各自的特点，可以根据具体应用建立不同存储引擎表；



> 简述MyISAM和InnoDB的区别和认识

【InnoDB】

+ InnoDB支持事务，主要面向OLTP应用；特点是支持行锁设计、支持外建；
+ InnoDB将数据存放在逻辑的表空间，用于自身进行管理；
+ InnoDB使用MVCC来实现高并发，实现了SQL四种标准的4种隔离级别，默认为「可重复读」；
+ InnoDB使用next-key lock策略避免幻读；
+ InnoDB提供插入缓冲、二次写和自适应哈希索引、预读等高性能、高可用的功能；
+ InnoDB使用聚簇索引来储存表中数据，每个表的储存按照主键的顺序进行存放；
+ InnoDB底层使用B+树结构储存实现索引；

【MyISAM】

+ MyISAM存储引擎不支持事务，使用表锁的设计，支持全文索引，主要面向OLAP应用；
+ MyISAM将表数据存储在两个文件：数据文件和索引文件；
+ MyISAM是非聚簇的，即数据文件和索引文件单独存储；
+ 除此之外MyISAM还支持表的压缩；
+ MyISAM底层使用B树实现索引。



> 简述MyISAM和InnoDB的应用场景

+ InnoDB支持事务，提供参照完整性的实现，主要面向OLTP应用；
+ MyISAM不支持事务，主要面向OLAP应用；




## 索引

> 简述什么是索引?

+ 数据库索引是一种数据结构，可以加快数据库记录的查找；
+ 适当的索引可以加快应用程序的整体性能；
+ 但太多的索引反而会降低应用程序的性能；



> 简述索引的分类
>
> 简述对B-Tree索引的理解
>
> 简述对哈希索引的理解
>
> 简述对全文索引的理解

+ InnoDB支持的索引类型有：B+树索引、全文索引和哈希索引(AHI)；
+ InnoDB支持的哈希索引是自适应的，即InnoDB会根据表的使用情况为表生成哈希索引；
+ InnoDB存储引擎会监控表的各个索引页的查询，当任务建立哈希索引可以带来速度提升，则建立哈希索引；
+ 自适应哈希所以可以看做是一种查询缓存；
+ InnoDB主要通过对索引列建立对应的B+树结构来实现数据的快速；
+ B+树结构中叶子节点保存了真实的数据内容，对于聚集索引保存的是整行数据，对于辅助保存的是对应记录的主键信息；
+ B+树结构中的非叶子节点保存了访问叶子节点的索引信息；
+ InnoDB默认根据主键id使用B+树建立聚簇索引来储存数据；
+ 由于B+树的构建特点，可以使得用户在使用索引查询数据的时候运用左前缀法则；
+ 但是对于左模糊匹配，将无法利用上索引，需要全表扫描；
+ 全文索引可以用于解决左右模糊匹配的查询问题；
+ 全文索引通过分析全文中的词信息，对其进行统计，分析，建立隐式；



> 简述索引的原理(为什么索引能加快查询)

+ 对于InnoDB而言，索引本质上是一种B+树的数据结构；
+ InnoDB中数据是页为基本单位储存在磁盘上，存储引擎将数据按顺序存放在B+树上；
+ 当需要定位一行数据时，如果遍历所有数据来比较，性能会很长，包含数据量和IO读写问题；
+ 通过B+树这种数据结构，可以为数据页的数据创建索引信息；
+ 通过这些索引页可以将跳过大量的数据页的访问；
+ 这样一来，我们可以通过访问多级索引页，快速定位数据页。



> 主键与唯一性索引的区别

+ 主键索引一定是唯一索引，唯一索引不一定是主键索引；
+ 主键可能可以唯一标识一行属性或属性组，一个表只能有一个主键，但可以多个唯一索引；
+ 主键还可以与外建构成参照完整性约束，防止数据不一致；
+ 主键列不允许空值，但唯一索引可以允许出现空值；



> 为什么加索引后写入修改删除变慢?

+ 创建索引本质是根据键值顺序创建一个新的数据结构；
+ 对于InnoDB存储引擎而言，创建一个索引就是创建一颗新的B+树；
+ 当每次需要删除或修改数据时，除了需要维护聚餐索引树，还需要额外维护B+索引树；
+ 索引树越多，需要维护的地方也就越多，性能也会随着下降。



> 简述使用索引的优缺点

+ 创建索引之后，可以家很快数据的查查询效率；
+ 但使用索引也会有相应的代价，主要包含空间代价和时间代价；
+ 空间代价表示，每创建一个索引，实际上是创建一颗B+树，每课树的一个都是一个页，一页默认16KB；
+ 时间代价表示，在删除和修改数据时，属于需要修改聚簇索引树，还需要修改辅助索引树；
+ 辅助索引树越多，维护的数据也就也多，性能也会随之下降。



> 简述对聚簇索引的理解

+ 聚簇索引具有两大特点，索引中记录按照主键顺序有序存放，B+树的叶子节点对应表中的完整真实事件；
+ 聚簇索无需手动创建，有InnoDB存储引擎为我们自动创建；



简述对非聚集索引的理解

+ 对于非聚集索引，创建B+树时是按照指定的列顺序进行创建；
+ B+树的叶子节点中储存的不再是完整数据，而是记录了主键的值；
+ 使用非聚集索引时，其查找某项数据的流程如下：
+ 1）根据非聚集索引字段，在非聚集索引树上快速定位该字段值对应的主键；
+ 2）根据主键值，到主键表中查询大相应的数据进行返回。



> 简述聚簇索引和非聚簇索引间的区别.

+ 比较规则不同：非聚集索引按照指定的列顺序进行排序；聚集索引按照主键大小顺序进行排序；
+ 叶子节点不同：非聚集索引的叶子节点储存的是「列+主键」；聚簇索引则储存的是完整数据记录；



> 简述对覆盖索引的理解

+ 索引覆盖可以避免回表的问题；
+ 当查询所需要的列的数据已经在非聚集索引、辅助索引中已经具备；
+ 这时可以不需要回主表在查询，避免了回表操作；
+ 尤其对于范围查询，如果在辅助索引中获得了多个主键数据；
+ 这些主键的数据可能具备随机性，分布在不同的数据页；
+ 如果需要回表则会存在大量的随机IO，性能很差。



简述对联合索引的理解

+ 可以为多个列创建索引，称为联合索引，联合索引树的创建会依次按照列的顺序进行排序；

+ 联合索引的创建具有这些特点：
+ 每个目录项有涉及到的列组成，每条记录先按照第一列排序，第一列相同的按照第二列排序，以此类推；
+ B+树的叶子节点的记录数据有这些列共同组成。



> 简述索引的最左原则

+ 最左原则包含了两层含义：匹配左边的列和匹配列前缀。
+ 匹配左边的列表示，在搜索语句中可以不包含全部联合索引的列，只需要包含左边即可；
+ 匹配列前缀表示，在单列的模糊搜索，如果查询条件符合右模糊，可以利用上部分索引；

+ 最左原则的原理基于B+树的创建方式；
+ 对于联合索引，B+树在创建时会按照从左到右的列的顺序进行存放，当最左边的列值相同，会根据第二个列的顺序依次创建，第二第三列以此类推；
+ 当我们使用的查询条件是最左边的列的时候，由于B+树的是按照最左边的列进行排序，因此可以利用上部分索引；
+ 对于单字段索引，B+树创建的时候是根据字符串的每个字符从左到右顺序进行存放，因此可以具有相同的性质；



> 简述索引失效的情况

+ 查询条件违反了最左法则：使用了左模糊查询，或跳过了左边的索引列；
+ 所以索引列上做了操作，如计算、函数、类型转换等会导致索引失效；
+ 使用不等于(!=、<>)会导致索引失效；
+ 字符串不加单引号会导致索引失效；
+ 使用or连接或导致索引失效；
+ 多个order by，排序的顺序与索引创建的顺序不一致；
+ 尽量使用索引覆盖，负责可能由于回表成本太多而导致放弃使用索引。



> [简述为什么要使用联合索引?](https://infocenter-archive.sybase.com/help/index.jsp?topic=/com.sybase.dc33621_33620_33619_1250/html/ptallbk/ptallbk297.htm)

+ 使用联合索引具有以下好处：
  1. 联合索引可以提供索引覆盖的概率；
  2. 如果具有多个联合列的等值查询，可以更加精确定位数据，减少回表的带来的随机IO；
  3. 使用唯一的联合索引可以保证数据正确性；
  4. 联合索引有时候可以避免创建多棵索引树，一定程度节省空间。



> 简述索引优化的不冗余原则

+ 创建适量 的索引，不要创建不需要的索引；



> 简述索引优化的最大选择性原则.



> 简述索引的应用注意事项.

> 简述对MySQL中普通索引唯一索引和主索引的理解

> 简述MySQL中的常用数据类型

+ 日期和时间类型

  | 类型      | 大小  | 范围          | 格式                | 用途           |
  | --------- | ----- | ------------- | ------------------- | -------------- |
  | DATE      | 3byte | 1000年~9999年 | YYYY-MM-DD          | 日期值         |
  | TIME      | 3byte | -838h~838h    | HH:MM:SS            | 时间或持续时间 |
  | YEAR      | 1byte | 1901年~2155年 | YYYY                | 年份           |
  | DATETIME  | 8byte | 1000年~9999年 | YYYY-MM-DD HH:MM:SS | 日期时间       |
  | TIMESTAMP | 4byte | 1970年~2038年 | YYYYMMDD HHMMSS     | 日期时间戳     |

+ timestamp与datetime的区别

  |          | timestamp                               | datetime         |
  | -------- | --------------------------------------- | ---------------- |
  | 时区信息 | 储存                                    | 不存储           |
  | 插入NULL | 自动转换为当前时间                      | 会储存NULL值     |
  | 占用空间 | 4byte                                   | 8byte            |
  | 使用场景 | 跟踪记录的变化                          | 储存特定的字段值 |
  | 含义     | 一个时间点                              | 日期和时间       |
  | 储存     | 转变为UTC时间保存，查询时转变为当前时区 | 直接保存不需要转 |

  需要提供全球服务或跨时区服务，优先选择timestamp；

  希望在不用时区显示同一个时间，现在datetime；

  时间跨度很大，timestamp不能表示，只能使用datetime；

> 简述B树和B+树在用于文件系统时的区别

