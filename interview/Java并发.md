# Java并发

## 进程与线程基础

> 简述对线程的理解线程和进程的区别

【进程】

+ 进程是操作系统对运行中程序的抽象，有利于管理处于运行中各种各样的程序；
+ 有了进程的抽象，使得应用程序在运行时仿佛独占了整个CPU；
+ 操作系统利用虚拟内存机制，为每个进程方提供独立的虚拟地址空间；
+ 虚拟地址空间可用保证多个进程高效安全的共享物理内存；
+ 进程是操作系统中资源分配的最小单位；
+ 操作通过PCB保存进程的状态、虚拟内存状态、打开的文件等。

【线程】

+ 由于进程创建、进程间数据共享、进程间通信、上下文切换开销大；
+ 操作系统在进程内部提出了更加轻量的执行单元：线程；
+ 同一个进程中的线程拥有独立的运行栈和指针寄存器，而且可以共享同一个进程中堆和方法区；
+ 与进程类似，每个线程也有自己TCB用来保存自身的运行状态、内存映射以及标识符等信息。

【纤程/协程】

+ 主流的操作系统线程用户线程与内核线程一一对应，用户线程的调度由系统来管理；
+ 因此用户线程的切换不仅包含了内核态和用户态的切换，而且线程的调度不可控；
+ 如在生产者消费者模式中，生产者在生产了足够多的数据之后，需要阻塞等待消费者的消费；
+ 但是操作系统对线程的调度是不不可控的，消费者可以需要多次的切换调度才能够执行到消费。



> 简述线程的生命周期状态转移

+ Java中线程有6种不同的状态：NEW、RUNNABLE、BLOCKED、WAIT、TIME_WAIT、TERMINATED；
+ NEW：表示线程被构造，但还没调用start方法；
+ RUNNABLE：表示线程处于就绪或运行两种状态；
+ BLOCKED：表示线程阻塞在锁；
+ WAITING：表示进程进入等待状态，需要等待其他线程做出一些的特定的操作；
+ TIME_WAITING：超时等待，不同于WAITING，可以在指定时间内自行你返回；
+ TERMINATED：表示当前线程已经执行完毕。

+ NEW==>RUNNABLE：Thread.start
+ RUNNABLE==>BLOCKED：等待进入synchronized方法或synchronized块；
+ RUNNABLE==>WAITING：Object.wait、Object.join、LockSupport.park；
+ RUNNABLE==>TIME_WAITING：Thread.sleep、Object.wait、Object.join、LockSupport.parkNanos、LockSupport.parkUntil；
+ RUNNABLE==>TERMINATED：执行完毕
+ BLOCKED==>RUNNABLE：获得锁
+ WAITING==>RUNNABLE：Object.notify、Object.notifyAll、LockSupport.unpark
+ TIME_WAITING==>RUNNABLE：Object.notify、Object.notifyAll、LockSupport.unpark



> 简述对线程中锁池与等待池的认识

+ Java中每个对象都有两个池，锁池（同步度列）和等待池（等待队列）；
+ 线程在获取锁之后，如果获取失败，就会进入锁池中等待；
+ 线程在获取锁之后，需



> wait vs sleep vs yield

+ wait/sleep/yield都可以暂停线程方法；
+ sleep/yield定义在Thread中，wati定义在Object中；
+ wait常用线程间通信，会释放持有的对象的Monitor；
+ sleep用于短暂暂停当前线程，不会释放持有的Monitor；
+ yield用于释放线程占用的CPU资源，让其他线程有机会运行，但不保证某个特定线程能够获得CPU资源；



> sleep vs wait

+ sleep是Thread类的静态方法，用于短暂暂停当前执行的线程，不会释放持有的monitor；
+ wait是Object类的成员方法，用于线程间的通信，执行时会释放还有的monitor；
+ sleep执行后被唤醒，会立即进入就绪RUNNABLE状态；
+ wait执行之后被唤醒，需要再次获得锁之后才能继续执行；
+ sleep可以在任何地方进行调用；wait方法仅能在获得了monitor之后采用调用；
+ 进入wait的线程能够被notify或notifyAll唤醒；
+ sleep进入睡眠之后不能通过notify或notifyAll唤醒；

>sleep vs yield

+ yield会暂停当前执行的相差，让有同样优先级的正在等待的线程有机会执行；
+ 调用yield方法之后什么时候运行完全由调度器决定，该方法不保证当前线程会被暂停或停止；
+ sleep可以用于短暂暂停当前线程执行，将CPU使用权还给调度器；
+ sleep方法返回之后，线程不保证获得CPU，会先进入就行状态；

> 简述join(long)与sleep(long)的区别

+ 当前运行线程调用另一个线程的join方法，当前线程会进入阻塞状态直到另一个线程运行
+ Thread.join内部调用了wait方法，while循环判断目标线程是否存活；
+ 因此join与sleep的区别可以看做是wait与sleep的区别



> 简述run()与start()的区别

+ 可以通过Thread.start来启动一个新的线程来运行run方法里面的内容，不能重复调用；
+ 如果直接调用run方法，和调用普通方法没有差别，仍然在主线程中执行；



> 简述os中的线程模型
>
> 简述用户线程和内核线程的区别

+ 操作系统中根据用户态应用还是内核态应用创建的线程，可以分为用户态线程和你核态线程；
+ 内核态线程由操作系统调度器直接管理，用户态线程则是有优化创建，不直接受调度器 管理；
+ 通常而言，用户态线程比内核态线程更加轻量级，创建开销更小，但功能有限，部分功能需要与内核态先协作完成；
+ 为了实现用户态线程与内核态线程的协作，操作系统会建立用户态线程和内核态线程的关系；
+ 操作系统中的多线程模型主要有三种：多对一、一对一、多对多。
  + 多对一：多个用户态线程映射给单一的内核态线程；
  + 一对一：每个用户态线程对应一个内核态线程；
  + 多对多：N个拥护他线程对应N个内核态线程。



> 简述os如何调度线程.

+ 每个线程都会自己的线程控制块(TCB)用于保存自身相关信息；
+ 操作系统通过TCB来保存线程信息；
+ TCP会保存线程的运行状态、内存映射、标识符等信息；
+ 操作系统通常会通过时钟中断，在指定时间片到达之后，切换另外的线程进行执行；
+ 这是被切换的线程的运行信息会通过TCP保存下来。



> 简述对协程的认识

+ 主流的操作系统采用一对一的线程模型，用户态线程与内核态线程具有一对一的关系；
+ 可以认为用户态线程的执行几乎完全受到操作系统的调度器管理；
+ 但随着计算机的发展，应用程序变得越来越复杂，在复杂引用中，每个线程各司其职；
+ 与操作系统调度器相比，应用程序对对线程的语义和执行状态更加了解，因此可能做出更优的调度决策。
+ 除此之外，用户态线程更加轻量，比内核态线程的创建和切换开销要低很多，更多使用拥护他线程有利于整个系统个的可扩展性；
+ 这种情况下，操作系统开始提供更多对用户态线程-协程的支持；
+ 协程的调度中涉及的上下文切换比进程的更加轻量，执行成本更低。



> 简述Java线程的本质

+ JVM中的线程实现本质上就是操作系统中的线程；



> 简述如何判断线程是否持有Java对象的锁

+ 可以通过Thread.holdsLock判断一个Thread是否持有Java对象的锁；



> 简述为何wait与notify必须在同步块内

+ wait与notify都在同步块中，可以避免「lost wake up」问题；
+ 比如在生产者-消费者模型中，生产者线程负责count--，消费者消除负责count++；

+ 生产者/消费者都通过count的值来判断是否应该wait/notify；
+ 但在这上面的过程中，检查count和调用wait之间，count可能会被修改；
+ 如消费者在判断count与决定wait之间，可能发生线程上下文切换，切换到生产者；
+ 生产者执行count++，执行notify唤醒一个线程，此时切换回到消费者；
+ 消费者判断count之后，继续执行wait，进入等待，消费者睡前；
+ 在上述过程中，由于消费者的count判断与wait执行不是原子性，造成的身份证的notify丢失。



> 简述如何结束线程

+ Thread.stop可以终止一个线程的执行，但是这些API在JDK1.1之后过期了；
+ 因为在终止一个线程是不会保证现成的资源正常释放，通常没有给与线程完成资源释放工作的机会，因此会导致程序在不确定状态下；
+ 比较安全终止线程的方式是：定义一个全局变量，用于决定是否终止线程；

+ 在run方法中while循环中，循环判断全局变量的值以及判断中断标志；
+ 定义一个终止方法用来修改全局变量，使变量不满足whlie中的条件；
+ 可以通过中断和终止方法来安全结束线程；



> 简述对interrupt方法的认识
>
> 调用interrupt 一定会抛出异常么?

+ 其他线程可以通过调用一个线程的interrupt的对该线程进行中断；
+ 线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted来判断是否被中断；
+ 线程内部也可以调用静态方法Thread.interrupted对线程中断标识为进行复位；
+ 在声明抛出InterruptedException的方法之前，Java虚拟机会先该线程中断；



> 为什么要在抛出InterruptedException 的时候清除掉中断状态?

+ 抛出InterruptedException可以认为是对中断操作的一种响应；
+ 对中断的处理应该将中断状态进行清除；



> 什么场景适合用多线程，什么场景适合单线程?



为什么要使用多线程?

多线程是不是肯定比单线程好?

简述如何减少上下切换的方法

简述线程中start()与run()的区别

简述并行和并发的区别

简述线程死锁与死锁的避免方式

线程池设计时要考虑什么因素

简述线程池的基本组成部分

线程池分别适合什么场景

简述线程池的实现方式

简述几种常见的线程池

简述对ThreadPoolExecutor的认识

简述对ThreadLocal的认识简述对ThreadLocalMap的认识

简述Thread、ThreadLocal 以及ThreadLocalMap的关联性

简述ThreadLocal的内存泄露以及解决方案

#### 同步

简述synchronized的内部实现以及优化

简述Java对象头的结构

简述对Monitor的认识

简述synchronized的优点和缺点

简述Lock和synchronized的区别

简述对volatile的认识

简述volatile读写内存的语义

简述对指令重排序的认识

如何理解volatile保证内存有序性?

简述Lock和synchronized的使用场景

简述CAS与synchronized的使用场景

简述CountDownLatch与CyclicBarrier的区别及使用场景

简述CountDownLatch的源码实现

简述CyclicBarrier的源码实现

#### AQS

简述对AQS的理解
简述AQS的原理
简述AQS对资源的共享方式
简述AQS的主要API

#### 锁

简述乐观锁与悲观锁的概念

简述乐观锁存在的问题

简述悲观锁存在的问题

简述对可重入锁的认识

简述对共享锁和独占锁的理解

简述对公平锁与非公平锁的认识

简述对自旋锁的认识

简述ReetrantLock的内部实现

简述ReetrantLock相比synchronized提供的新特性

简述ReetrantLock如何实现公平锁与非公平锁

简述锁升级时MarkWord中的标志位变化情况

简述锁升级涉及几种锁的优缺点

简述对偏向锁的认识

简述对轻量级锁的理解

简述对重量级锁的认识

简述锁膨胀的过程

简述对锁清除、锁粗化的理解

简述对分段锁的理解

简述处理器如何实现原子操作

简述Java中如何实现原子操作

简述CAS实现原子操作的三大问题以及解决方案

简述CAS的实现原理

简述CAS缺点

简述CAS与synchronized使用场景对比

#### 系统级同步

简述对指令重排序的认识

简述内存屏障的分类

简述顺序一致性模型与JMM模型的区别

简述volatile读写内存的语义

简述JMM内存屏障的种类

## 其他

> 聊聊伪共享

+ 现代计算机体系中，CPU通常会引入缓存机制来加速内存中数据的读取；
+ 在CPU的缓存中，操作是面向缓存行的，一个缓存的大小通常是64字节；
+ 如果两个共享变量被同时读到一行缓存行中，对其中一个变量的操作会导致该缓存行锁定，这将会导致读到同一缓冲行的共享变量只能被串行访问；
+ 由于错误地将共享变量放到同一缓存行中，人命称这种方式为false-share（伪共享）。
+ 发生伪共享时，可以通过追加字节码的方式来填充整个缓存行，使一个共享变量占据一个缓存行；
+ 追加字节码有两种方式，一是定义无用的变量占用，使其恰好占据一个缓存行大小；
+ JDK内部的源码还可以使用Contended注解来自适应填充；
+ Thread源码中使用到了该注解

