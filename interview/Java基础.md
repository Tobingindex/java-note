# Java基础

## Object基类

> 简述对equals方法的理解，==与equalse的区别？

+ 默认情况下，equals使用==等价；
+ equals会比较对象的地址，这是只有在比较同一个对象时才会返回true；
+ 通常比较会在需要比较两个对象的场景中，都需要重写equals方法；
+ equals方法必须满足以下特点：
  + 自反性：对于任何非空引用x，x.equals(x)返回true；
  + 对称性：任何非空引用x和y，y.equals(x)为true，x.equals(y)为true；
  + 传递性：任何非空引用x、y、z，y.equals(x)，x.equals.(z)，则y.equals(z)；
  + 一致性：对于非空引用x和y，多次调用x.equals(y)的结果始终一致；
  + 对于任何非空引用值，x.equals(null)==false；



> 简述对hashcode()方法的理解

+ 返回对象的哈希码值；这个方法引入是为了提高哈希表的性能；
+ hashCode编写的时候应该符合以下性质：
  + Java一次程序执行期间，多次调用hashCode方法，返回的地址应该一致；
  + 同一程序的多次执行中，调用hashCode方法，返回的地址不要求一致；
  + 两个对象的equals相等，那么这两个对象的hashCode应该相等；
  + 如果两个对象的equals不相等，不要两个对象的hashCode不相等；
+ Object的hashCode实现默认是返回对象内存地址的整数表现形式；
+ String对hashCode进行重写，根据内部的字符序列运算，如果字符序列相等hashCode相等；
+ 一个好的hashCode方法应该产生分布均匀的散列码，主要可以避免HashMap或HashSet某个区域的负载太重；
+ hashCode涉及到HashSet和HashMap等槽运算的位置，重写hashCode很有必要；



> 为什么重写equals0方法就必须重写hashcode方法

+ 每个覆盖了equals方法的类，都不行覆盖hashCode方法；
+ 如果不这样做，将会违反hashCode的通用约定，从而导致类无法结合所有基于散列的集合一起正常工作，这些类包含了HashMap和HashSet。



> 简述对clone方法的理解

+ 调用此方法会创建并返回一个该对象的副本；
+ 拷贝的精确含义取决于需求，一般而言可以分为深拷贝和浅拷贝；
+ 通常而言，返回的对象应该独立于原有的对象；
+ 为了是这种独立性，可能需要在原有返回对象之前重写该方法，使得返回的对象的一个或多个字段实现拷贝；
+ 深拷贝：拷贝出来目标对象的指针和源对象的指针指向同一片内存空间；
+ 深拷贝：拷贝时不仅复制对象的所有非引用成员变量，还要为引用类型的独享创建新的实例，并初始化为形参实例值；



> 简述浅拷贝和深拷贝的区别

+ 浅拷贝：对于基础数据类型实现值传递，对于引用数据类型实现引用传递；
+ 深拷贝：对于基本数据类型实现值传递，对于引用数据类型，创建一个新的对象，复制其内容；
+ Object#clone方法可以实现对象拷贝，在具体编写实现类的是需要实现Cloneable接口，否则会抛出ClassNotSupportException；
+ Object#clone的默认实现是浅拷贝；
+ 如果需要实现深拷贝，主要有两种方式：序列化和递归调用clone方法；




> 简述深拷贝的实现方式

+ 实现深拷贝主要有两种方式：序列化和递归调用clone方法；
+ 序列化：先通过某种方式将对象序列化，在反序列化回来，得到新的对象；
+ 递归调用：在clone方法中，对于引用数据类型，仍然调用clone方法；



> 简述一个数组的复制方法

+ 数组拷贝可以有3种方法；
+ Arrays.copyOf方法；
+ System.arraycopy方法;
+ Object.clone方法；



> Arrays.copyOf与System.arraycopy的区别

+ System.arraycopy将源数组中的内容从指定位置开始复制到目标数组中的指定位置；
+ System.arraycopy在复制的时候，JVM会检查类型和目标类型是否相同；
+ System.arraycopy是有个native方法，依赖于其他语言是实现，通过JNI访问。
+ Arrays.copyOf在System.arraycopy的基础上提供了额外的功能；
+ Arrays.copyOf在进行复制时会创建新的数组，当长度不一致可能会阶段或填充内容；
+ Arrays.copyOf的目标类型与源数组类型可以不同，这时会通过反射实现，会增加性能开销；
+ Arrays.copyOf底层调用了System.arraycopy；

## 数据类型

> 简述基本数据类型及其所占字节数

| 基础数据类型 | 占用大小 | 概述                  |
| ------------ | -------- | --------------------- |
| byte         | 1byte    | 有符号字节型          |
| short        | 2byte    | 有符号短整型          |
| int          | 4byte    | 有符号整形            |
| long         | 8byte    | 有符号长整型          |
| float        | 4byte    | 单精度浮点数          |
| double       | 8byte    | 双精度浮点数          |
| boolean      | 1byte    | 布尔类型              |
| char         | 2byte    | 无符号16位Unicode字符 |



> 为什么char类型是双字节

+ char类型用于表示Unicode编码的单个字符，通常用于表示字符常量；
+ Unicdoe1.0的时候还没使用到65536的一半；
+ 因此当时Java决定采用16位的Unicode编码；
+ 但随着时间的发展，Unicode中添加了大量的汉语、日语和韩文；
+ 如今16位的char类型以及不能满足所有Unicode字符的需要；



> 简述Java中包装类及装箱、拆箱

+ 有时候需要将int类型转换为对象；
+ Java为所有的基本数据类型提供了对一个对应的类，这些类称为包装类；
+ 这些包装类是不可变的，一旦创建就不允许修改其中的值；
+ 同时包装类是final的，不允许定义其子类；
+ Java SE5开始，引入了自动装箱、自动拆箱特性；
+ 自动装箱允许将基础数据类型赋给包装类；
+ 自动拆箱允许将包装类类型复制给基础数据类型；
+ 自动装箱规范要求小于127的boolean、byte、char和-128~127之间的short和int会被包装到固定对象中；
+ 这样一来，这些范围内的自动装箱的包装类的地址引用是一致的；
+ 自动装箱和自动拆箱是由编译器实现的，编译器在生成类的字节码的时候，会插入必要的方法地调用；
+ 自动装箱本质上是插入了「包装类.valueOf(基础类型数据)」；
+ 自动拆箱本质上是插入了「包装类.xxxValue()」；



> 简述隐式类型转换、显示类型转换及使用中可能出现的问题

![image-20210921130602787](https://gitee.com/tobing/imagebed/raw/master/image-20210921130602787.png)

+ 实心箭头是自动类型装换，无信息丢失；虚线箭头是强制类型装换，可能有精度损失；

【隐式类型转换】

+ 当两种不同类型数据进行二元操作时，需要先将两个操作数转为同一类型，再进行计算；
+ 如果存在一个为double，另一个装换为double；
+ 如果存在一个为float，另一个装换为float；
+ 如果存在一个为long，另一个装换为long；
+ 负责两个操作数都会被转换为int类型；

【显示类型转换】

+ 显示类型转换，顾名思义就是需要使用括号表示强制类型转换；
+ 强制类型可能会存在精度丢失问题；



> 简述包装类中的缓存

+ 在自动装箱时规定
+ 对于小于127的boolean、byte、char和·-128~127的short和int类型都会被包装到固定的对象；
+ 具体而言就是JVM启动时会缓存这些范围的对象



> 简述Integer 中valueOf方法的实现

+ 在Integer.valueOf方法中，对于~128和127的值，会直接从缓存中返回；
+ 其他范围则会创建一个新的对象进行返回；



> 简述字符型常量和字符串常量的区别

+ 形式上，字符型常量是使用单引号扩起来的一个字符；字符串常量是使用双引号括起来的0个或多个字符；
+ 在含义上，字符常量相当于一个整形，可以参与表达式运算；字符串常量代表一个地址
+ 在空间上，字符常量仅占用2个字节，字符串处理占用若干个字节；



> 简述包装类存在的意义

+ Java是存面向对象的语言，一切都可以看做对象；
+ 基本数据类型不是独享，不属于任何的类；
+ 在Java中部分数据结构只能支持接收对象类型；
+ 如对于泛型只适用于对象，不能使用基础数据类型，要使用它们必须将其包装为对象；
+ 包装类的出现可以简化集合框架处理对象；
+ 对于这些场景需要将基本数据类型转换为对象类型，对于这种转换引入了包装类；
+ 包装类将基本数据类型进行封装，将其赋予了对象的外观；
+ 包装类主要有两种用途；
+ ①将简单的数据类型转换为对象；
+ ②将字符串转换为数据类型，提供了大量的parseXXX；

## Java编码

//TODO

+ http://c.biancheng.net/cpp/html/3420.html
+ https://exploringjs.com/impatient-js/ch_unicode.html
+ http://unicode.org/glossary/#codespace
+ https://zhuanlan.zhihu.com/p/51202412
+ https://cloud.tencent.com/developer/article/1137611

简述对Java字符、字节、编码的理解

简述为什么需要编码.

简述内码和外码的含义与区别

简述GBK和GB2312的区别

简述UTF-8、UTF-16和UTF-32的区别

+ UTF-8、UTF-16和UTF-32是Uncidoe的三种码点编码的方式；
+ 每种格式的尾部表示了其代码单元的大小；
+ UTF-32使用32位来储存代码单元；每个代码点对一个代码单元；
+ UTF-32是唯一一种采用定长编码的格式；
+ 其他UTF编码采用不同数量的代码单元来表明单个代码点；
+ UTF-16使用16位代码单元；



简述UTF-8、UTF-16和UTF-32的应用场景

> 简述码点和代码单元

+ 代码点表示Unicode字符的数字；
+ 代码单元是对代码点进行编码的数字，用于储存或传输Unicode文本。
+ 一个或多个代码单元对单个代码点进行编码；
+ 每个代码单元具有相同大小，这取决与使用的编码格式；
+ 流行的UTF8使用8位代码单元；

## String

> 从源码层面简述对String类的了解

+ Stirng声明为final，不可以被继承；
+ String实现了Serializable接口，表示字符串可以被序列化；
+ String实现了Comparable接口，表示字符串可以比较；
+ JDK8及之前内部采用`fina char[] value`用于储存字符串数据，JDK9采用 `final byte[]`。
+ String代表不可变的字符序列；
+ 当字符串重新复制时，需要重写指定内存区域赋值，不能使用原有value进行赋值；
+ 当对象现有字符串进行连接，需要重新制定内存区域赋值，不能使用原有的value进行赋值；
+ 当调用String的replace方法修改字符或字符串时，需要重新指定内存区域赋值，不能对于原有的value赋值；



> 简述String不可变性带来的好处

+ String不可变性主要从性能和安全两方面来考虑；
+ Java中的字符串常量池的存在是为了性能优化；
+ 字符串常量池是Java堆中的一个特殊区域；
+ 创建一个String对象时，首先会字符串常量池中操作是否存在；
+ 如果存在该字符，直接返回字符串的引用，不去创建新的对象；
+ 这样一来可以减少JVM的内存开销，提高性能；
+ 如果String可变，将无法共享同一字符串常量，字符串常量池也没有意义。
+ Java 设计者认为共享带来的效率远胜于提取、拼接字符串带来的低效率；
+ 除此之外，字符串的不可变性可以使得其hash值被缓存，提供hash运算效率；



> 简述String中equals方法如何实现

+ 先判断是否instanceof String；
+ 在判断长度是否相等；
+ 最后挨个判断内部的value数组的内容是否相等；



> 简述String、StringBuilder 和StringBuffer的区别与认识

+ String是不可变的，可以为一个String对象赋值给多个引用；
+ 因为String是只读的，因此执行它的任何引用都不能修改它的值，这样也不会影响到其他引用；
+ 但是由于String的不可变性，在字符串进行拼接或需改的时候，必须要创建其他的对象；
+ 如果通过String进行字符串的拼接，为了生成最终的String对象，需要产生无用的中间对象；
+ 通过使用StringBuilder类可以避免产生太多的无用的中间对象；
+ 在拼接完毕之后，可以使用StringBuilder的toString方法来创建出一个String对象。
+ StringBuffer是StringBuilder的线程安全版，在单线程下使用StringBuilder的性能比StringBuffer要高一点；两者API是相同的。

> 简述对字符串常量池的认识

+ 字符串常量池是JVM中用于储存字符串的特殊内存区域；
+ 由于字符串的不可变，JVM可以同在池中仅为每个字符串创建一份数据；
+ 其他所有String变量可以分配到字符串常量池中同样的值；
+ 在创建一个String类的时候，会到字符串常量池中寻找，如果存在会直接返回该引用；
+ 如果不存在，会将其添加到字符串常量池并将其引用返回；
+ 在JDK7之前，JVM将字符串常量池放在永久代中，这个空间具有固定的大小，不适合运行时控制，且不符合垃圾回收的条件；
+ JDK7开始，Java字符串常量池储存在堆空间中，有JVM进行垃圾回收，降低了OOM的风险；
+ 需要注意当使用new的方式创建字符串是，不会去常量池检查是否具有相同的对象；
+ 使用字面量的方式赋值采会到字符串常量池中检查；



> 简述业务中如何优化字符串拼接

+ 通常是使用StringBuilder进行字符串的拼接；



> 简述String中final 的应用

+ 如果字符串不可变，使用final修饰，可以优化字符串的拼接过程；
+ 字符串拼接的时候，如果发现String对象不可变，会直接将其优化为拼接的内容；
+ 这样一来可以减少StringBuilder的对象的创建，和中间对象的创建；

## 关键字、修饰符与特殊运算符

> 简述对static关键字的理解

+ 当一个类中的字段或方法不依赖与特定的对象实例，可以将其定义为static；
+ 如果将字段或方法定义为static，每个类中仅有一个这样的字段或方法；
+ 这个类的多个实例可以共享这个static域的内容；
+ static修饰的字段或方法可以对象名或类名的方式进行调用，通常推荐使用类名方式调用；
+ 由于static的作用域要比普通实例域的生命周期要长，因此static中不能访问普通字段或普通方法；



> 简述父子类的初始化顺序(静态变量、静态语句块、实例变量、普通语句块、构造函数)

+ 一个类在加载的时候，会在初始化阶段执行`clinit<>()`函数；
+ javac编译器会将类中的静态变量以及静态代码块收集作为`clinit<>()`的内容；
+ 当一个子类完成`clinit<>()`操作时，父类已经完成了该操作；
+ 构造函数在对象创建的时候被调用；
+ 在类的构造器执行前，其执行器父类的构造器；
+ 父类静态变量和静态语句块、子类静态代码块、父类的普通语句块、父类构造函数、子类普通语句块、子类构造函数；



> 简述内部类与static 关键字的关系、访问权限以及初始化时机

+ 内部类是定义在另一个类内部的类；
+ 内部类的方法可以访问外部类定义所在的数据，包含私有数据；
+ 内部类可以对同一个包中其他类隐藏起来；
+ Java中的普通内部类的对象具有一个隐式的引用，该引用指向了实例化该内部对象的外部类对象；
+ 通过这个隐式的引用，内部类可以访问外部类的全部状态；
+ 对于static内部类，没有这种附加的指针；
+ 内部类是一种编译器现象，与虚拟机无关；
+ 编译器会把内部类翻译成用$分隔外部类名与内部类名的常规类文件，虚拟机对其一无所知；



> 简述final 关键字的作用

+ final通常指修饰的字段、方法和类不可变；
+ final修饰字段时，表明这个字段只能被初始化一次，并且初始化完成之后不能改变；
+ 对于基本数据类型初始化完成之后其数字不能改变；
+ 对于引用数据类型初始化完成之后其对象引用不能改变，但不限制里面的内容不能改变；
+ 基于不可变性，可以使得编译器把常量进行代入计算，减少运行期的负担；
+ final修饰参数时，意味着在方法中不能改变参数指向的对象或基本变量；
+ final修饰参数主要用于传递数据给匿名内部类；
+ final修饰方法时可以给方法上锁，防止子类通过覆盖重写来改变方法的行为；
+ 类中的所有private方法都会隐式地指定为final；
+ final修饰类时意味着该类不能被继承，final类内部的方法会隐式地指定为final；



> 简述使用final 关键字的好处

+ final修饰的变量可以利用编译器的静态优化代码；
+ 如对于final类型的字符串，将两者进行拼接会比普通局部变量优化很多；
+ 对于final修饰的类变量，由于只能被初始化一次，编译器会其他用到这个变量的地方替换为最终来到引用；

> 简述static与final修饰变量所处JVM内存模型中的位置

+ final修饰的变量又称为常量；
+ 在JVM中常量和静态常量等数据都储存在方法区中；
+ JDK1.7之前，方法区被放在被放在永久代中实现；
+ JDK1.7的时候，处于永久代中的字符串常量池和、静态常量都被移出；
+ JDK1.8，废弃了永久代，方法区的实现在元空间中实现；



> 简述native的含义

+ native关键字只能用来修饰方法；
+ native修饰方法是表示方法的实现需要调用其他编程语言的代码，如C或C++；

【四种功能】

+ 通过native可以使用其他编程语言编写的系统调用或库实现接口；
+ 可以访问只能从其他语言访问的系统或硬件资源；
+ 可以将C/C++编写的遗留代码继承到Java程序中；
+ 可以使用Java中的任意代码调用硬件编译的动态加载库；

【三个目的】

+ 使用native可以提高系统性；
+ 实现机器级/内存级通信；
+ 使用已经存在的遗留的非java代码；

+ native主要是用于提高性能，但native关键字打破了java的平台无关性；



> 简述运算符instanceof的含义以及应用场景

+ instanceof可以检测一个对象是否为某个类或接口的实例；
+ 当null使用instanceof运算符，始终会返回一个false；
+ 通常instanceof与类型擦除一起使用；
+ 在将父类转换为子类之前，也应该使用instanceof进行检查，如equals方法；





简述super关键字的含义

> 简述super与this的区别

+ 在实例方法或构造函数中，this可以或当前对象的引用；
+ 可以在实例方法或构造器中通过this来获取当前对象的任何成员；
+ 在构造器中还可以调用同一个类的另一个构造器(如果存在对另一个构造器的调用，必须在构造器第一行)；
+ super可以引用父类对象，当子类与父类具有相同的成员段时，可以通过super显式指定使用父类的成员；
+ super关键字也可以用于根据参数调用父类的构造函数；
+ 调用super必须是类构造器的第一行，如无显式调用Java编译器会自动对超类的无参构造器的调用；



> 简述private，protected，public，default的区别

+ private仅对本类可见；类、接口、变量、方法。
+ public对所有类可见：使用对象：类、接口、变量、方法。
+ protected对本包和所有子类可见。使用对象是：接口、变量，不能修饰外部类。
+ defalut同一个包可见，不使用任何修饰符。使用对象是：类、接口、变量、方法。

## 面向对象

> 简述面向对象三大特征

+ 面向对象的三大特征是，封装、继承、多态；
+ 封装隐藏了一个对象的实现细节，使得对象内部的状态不为其他对象访问，对象的数据只能通过接口来访问；
+ 封装使得对象可以被看成一个「黑盒子」，可以对数据进行保护。一个对象实现方法的改变，不影响其他相关对象；
+ 通过封装可以是实现隐式保护、保护数据安全、隔离复杂度；
+ Java中通过权限修饰符实现封装特性。
+ 继承可以让一个类包含另一个类的状态和行为，除此之外，这个类还有自己的状态和行为；
+ 当一个类从另一个类继承而来，多态使得子类可以代替父类。
+ 

简述重写和重载的区别

构造器可以重写么?

简述抽象类的相关特性

简述接口的相关特性

简述接口和抽象类的区别

接口与抽象类在不同JDK版本中的变化

简述通过实例对象.方法名这种调用过程都做了什么

为什么在父类中要定义一一个没有参数的空构造函数

简述静态类和单例的区别

简述成员变量与局部变量的区别

简述静态方法和实例方法的区别

为什么Java中只有值传递

#### 常量池

简述对Java中的字符串常量池的认识

字符串常量池随JDK版本的位置变化

简述Java中的Class常量池

简述Java中的运行时常量池



#### 异常

简述对异常的理解

简述异常的继承体系

简述Exception和Error的区别

oom是Error还是Exception

简述所知的运行时异常和编译时异常

简述throw和throws的区别



#### 泛型

简述对泛型的理解

简述对泛型擦除的认识



#### 反射

简述对反射的理解

简述反射的应用场景

简述反射的优缺点

#### 枚举

简述对枚举的理解

简述枚举与常量类的区别

简述枚举的本质

简述枚举与序列化的关系



#### 序列化

简述对Java序列化的理解

简述Java序列化的相关特性

简述Java序列化的几种方式

简述对ArrayList中序列化的认识

简述Java序列化背后的原理(源码)

简述Java序列化中serialVersionUID的作用

简述Java序列化中父类相关问题



#### 代理

简述对静态代理的理解

简述对动态代理的理解

简述对cglib 代理的理解

简述cglib和jdk的这两者之间性能的区别

动态代理用多了之后对内存方面有什么影响

动态代理、反射生产的对象在jvm 的哪里?会不会影响到永久代或者是8以后的元空
间?