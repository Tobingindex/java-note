# Java基础

## Object基类

> 简述对equals方法的理解，==与equalse的区别？

+ 默认情况下，equals使用==等价；
+ equals会比较对象的地址，这是只有在比较同一个对象时才会返回true；
+ 通常比较会在需要比较两个对象的场景中，都需要重写equals方法；
+ equals方法必须满足以下特点：
  + 自反性：对于任何非空引用x，x.equals(x)返回true；
  + 对称性：任何非空引用x和y，y.equals(x)为true，x.equals(y)为true；
  + 传递性：任何非空引用x、y、z，y.equals(x)，x.equals.(z)，则y.equals(z)；
  + 一致性：对于非空引用x和y，多次调用x.equals(y)的结果始终一致；
  + 对于任何非空引用值，x.equals(null)==false；



> 简述对hashcode()方法的理解

+ 返回对象的哈希码值；这个方法引入是为了提高哈希表的性能；
+ hashCode编写的时候应该符合以下性质：
  + Java一次程序执行期间，多次调用hashCode方法，返回的地址应该一致；
  + 同一程序的多次执行中，调用hashCode方法，返回的地址不要求一致；
  + 两个对象的equals相等，那么这两个对象的hashCode应该相等；
  + 如果两个对象的equals不相等，不要两个对象的hashCode不相等；
+ Object的hashCode实现默认是返回对象内存地址的整数表现形式；
+ String对hashCode进行重写，根据内部的字符序列运算，如果字符序列相等hashCode相等；
+ 一个好的hashCode方法应该产生分布均匀的散列码，主要可以避免HashMap或HashSet某个区域的负载太重；
+ hashCode涉及到HashSet和HashMap等槽运算的位置，重写hashCode很有必要；



> 为什么重写equals0方法就必须重写hashcode方法

+ 每个覆盖了equals方法的类，都不行覆盖hashCode方法；
+ 如果不这样做，将会违反hashCode的通用约定，从而导致类无法结合所有基于散列的集合一起正常工作，这些类包含了HashMap和HashSet。



> 简述对clone方法的理解

+ 调用此方法会创建并返回一个该对象的副本；
+ 拷贝的精确含义取决于需求，一般而言可以分为深拷贝和浅拷贝；
+ 通常而言，返回的对象应该独立于原有的对象；
+ 为了是这种独立性，可能需要在原有返回对象之前重写该方法，使得返回的对象的一个或多个字段实现拷贝；
+ 浅拷贝：拷贝出来目标对象的指针和源对象的指针指向同一片内存空间；
+ 深拷贝：拷贝时不仅复制对象的所有非引用成员变量，还要为引用类型的独享创建新的实例，并初始化为形参实例值；



> 简述浅拷贝和深拷贝的区别

+ 浅拷贝：对于基础数据类型实现值传递，对于引用数据类型实现引用传递；
+ 深拷贝：对于基本数据类型实现值传递，对于引用数据类型，创建一个新的对象，复制其内容；
+ Object#clone方法可以实现对象拷贝，在具体编写实现类的是需要实现Cloneable接口，否则会抛出ClassNotSupportException；
+ Object#clone的默认实现是浅拷贝；
+ 如果需要实现深拷贝，主要有两种方式：序列化和递归调用clone方法；




> 简述深拷贝的实现方式

+ 实现深拷贝主要有两种方式：序列化和递归调用clone方法；
+ 序列化：先通过某种方式将对象序列化，在反序列化回来，得到新的对象；
+ 递归调用：在clone方法中，对于引用数据类型，仍然调用clone方法；



> 简述一个数组的复制方法

+ 数组拷贝可以有3种方法；
+ Arrays.copyOf方法；
+ System.arraycopy方法;
+ Object.clone方法；



> Arrays.copyOf与System.arraycopy的区别

+ System.arraycopy将源数组中的内容从指定位置开始复制到目标数组中的指定位置；
+ System.arraycopy在复制的时候，JVM会检查类型和目标类型是否相同；
+ System.arraycopy是有个native方法，依赖于其他语言是实现，通过JNI访问。
+ Arrays.copyOf在System.arraycopy的基础上提供了额外的功能；
+ Arrays.copyOf在进行复制时会创建新的数组，当长度不一致可能会阶段或填充内容；
+ Arrays.copyOf的目标类型与源数组类型可以不同，这时会通过反射实现，会增加性能开销；
+ Arrays.copyOf底层调用了System.arraycopy；

## 数据类型

> 简述基本数据类型及其所占字节数

| 基础数据类型 | 占用大小 | 概述                  |
| ------------ | -------- | --------------------- |
| byte         | 1byte    | 有符号字节型          |
| short        | 2byte    | 有符号短整型          |
| int          | 4byte    | 有符号整形            |
| long         | 8byte    | 有符号长整型          |
| float        | 4byte    | 单精度浮点数          |
| double       | 8byte    | 双精度浮点数          |
| boolean      | 1byte    | 布尔类型              |
| char         | 2byte    | 无符号16位Unicode字符 |



> 为什么char类型是双字节

+ char类型用于表示Unicode编码的单个字符，通常用于表示字符常量；
+ Unicdoe1.0的时候还没使用到65536的一半；
+ 因此当时Java决定采用16位的Unicode编码；
+ 但随着时间的发展，Unicode中添加了大量的汉语、日语和韩文；
+ 如今16位的char类型以及不能满足所有Unicode字符的需要；



> 简述Java中包装类及装箱、拆箱

+ 有时候需要将int类型转换为对象；
+ Java为所有的基本数据类型提供了对一个对应的类，这些类称为包装类；
+ 这些包装类是不可变的，一旦创建就不允许修改其中的值；
+ 同时包装类是final的，不允许定义其子类；
+ Java SE5开始，引入了自动装箱、自动拆箱特性；
+ 自动装箱允许将基础数据类型赋给包装类；
+ 自动拆箱允许将包装类类型复制给基础数据类型；
+ 自动装箱规范要求小于127的boolean、byte、char和-128~127之间的short和int会被包装到固定对象中；
+ 这样一来，这些范围内的自动装箱的包装类的地址引用是一致的；
+ 自动装箱和自动拆箱是由编译器实现的，编译器在生成类的字节码的时候，会插入必要的方法地调用；
+ 自动装箱本质上是插入了「包装类.valueOf(基础类型数据)」；
+ 自动拆箱本质上是插入了「包装类.xxxValue()」；



> 简述隐式类型转换、显示类型转换及使用中可能出现的问题

![image-20210921130602787](https://gitee.com/tobing/imagebed/raw/master/image-20210921130602787.png)

+ 实心箭头是自动类型装换，无信息丢失；虚线箭头是强制类型装换，可能有精度损失；

【隐式类型转换】

+ 当两种不同类型数据进行二元操作时，需要先将两个操作数转为同一类型，再进行计算；
+ 如果存在一个为double，另一个装换为double；
+ 如果存在一个为float，另一个装换为float；
+ 如果存在一个为long，另一个装换为long；
+ 负责两个操作数都会被转换为int类型；

【显示类型转换】

+ 显示类型转换，顾名思义就是需要使用括号表示强制类型转换；
+ 强制类型可能会存在精度丢失问题；



> 简述包装类中的缓存

+ 在自动装箱时规定
+ 对于小于127的boolean、byte、char和-128~127的short和int类型都会被包装到固定的对象；
+ 具体而言就是JVM启动时会缓存这些范围的对象



> 简述Integer 中valueOf方法的实现

+ 在Integer.valueOf方法中，对于~128和127的值，会直接从缓存中返回；
+ 其他范围则会创建一个新的对象进行返回；



> 简述字符型常量和字符串常量的区别

+ 形式上，字符型常量是使用单引号扩起来的一个字符；字符串常量是使用双引号括起来的0个或多个字符；
+ 在含义上，字符常量相当于一个整形，可以参与表达式运算；字符串常量代表一个地址
+ 在空间上，字符常量仅占用2个字节，字符串处理占用若干个字节；



> 简述包装类存在的意义

+ Java是存面向对象的语言，一切都可以看做对象；
+ 基本数据类型不是独享，不属于任何的类；
+ 在Java中部分数据结构只能支持接收对象类型；
+ 如对于泛型只适用于对象，不能使用基础数据类型，要使用它们必须将其包装为对象；
+ 包装类的出现可以简化集合框架处理对象；
+ 对于这些场景需要将基本数据类型转换为对象类型，对于这种转换引入了包装类；
+ 包装类将基本数据类型进行封装，将其赋予了对象的外观；
+ 包装类主要有两种用途；
+ ①将简单的数据类型转换为对象；
+ ②将字符串转换为数据类型，提供了大量的parseXXX；

## Java编码

//TODO

+ http://c.biancheng.net/cpp/html/3420.html
+ https://exploringjs.com/impatient-js/ch_unicode.html
+ http://unicode.org/glossary/#codespace
+ https://zhuanlan.zhihu.com/p/51202412
+ https://cloud.tencent.com/developer/article/1137611

简述对Java字符、字节、编码的理解

简述为什么需要编码.

简述内码和外码的含义与区别

简述GBK和GB2312的区别

简述UTF-8、UTF-16和UTF-32的区别

+ UTF-8、UTF-16和UTF-32是Uncidoe的三种码点编码的方式；
+ 每种格式的尾部表示了其代码单元的大小；
+ UTF-32使用32位来储存代码单元；每个代码点对一个代码单元；
+ UTF-32是唯一一种采用定长编码的格式；
+ 其他UTF编码采用不同数量的代码单元来表明单个代码点；
+ UTF-16使用16位代码单元；

简述UTF-8、UTF-16和UTF-32的应用场景

> 简述码点和代码单元

+ 代码点表示Unicode字符的数字；
+ 代码单元是对代码点进行编码的数字，用于储存或传输Unicode文本。
+ 一个或多个代码单元对单个代码点进行编码；
+ 每个代码单元具有相同大小，这取决与使用的编码格式；
+ 流行的UTF8使用8位代码单元；

## String

> 从源码层面简述对String类的了解

+ Stirng声明为final，不可以被继承；
+ String实现了Serializable接口，表示字符串可以被序列化；
+ String实现了Comparable接口，表示字符串可以比较；
+ JDK8及之前内部采用`fina char[] value`用于储存字符串数据，JDK9采用 `final byte[]`。
+ String代表不可变的字符序列；
+ 当字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有value进行赋值；
+ 当对象现有字符串进行连接，需要重新制定内存区域赋值，不能使用原有的value进行赋值；
+ 当调用String的replace方法修改字符或字符串时，需要重新指定内存区域赋值，不能对于原有的value赋值；



> 简述String不可变性带来的好处

+ String不可变性主要从性能和安全两方面来考虑；
+ Java中的字符串常量池的存在是为了性能优化；
+ 字符串常量池是Java堆中的一个特殊区域；
+ 创建一个String对象时，首先会字符串常量池中操作是否存在；
+ 如果存在该字符，直接返回字符串的引用，不去创建新的对象；
+ 这样一来可以减少JVM的内存开销，提高性能；
+ 如果String可变，将无法共享同一字符串常量，字符串常量池也没有意义。
+ Java 设计者认为共享带来的效率远胜于提取、拼接字符串带来的低效率；
+ 除此之外，字符串的不可变性可以使得其hash值被缓存，提供hash运算效率；



> 简述String中equals方法如何实现

+ 先判断是否instanceof String；
+ 在判断长度是否相等；
+ 最后挨个判断内部的value数组的内容是否相等；



> 简述String、StringBuilder 和StringBuffer的区别与认识

+ String是不可变的，可以为一个String对象赋值给多个引用；
+ 因为String是只读的，因此执行它的任何引用都不能修改它的值，这样也不会影响到其他引用；
+ 但是由于String的不可变性，在字符串进行拼接或需改的时候，必须要创建其他的对象；
+ 如果通过String进行字符串的拼接，为了生成最终的String对象，需要产生无用的中间对象；
+ 通过使用StringBuilder类可以避免产生太多的无用的中间对象；
+ 在拼接完毕之后，可以使用StringBuilder的toString方法来创建出一个String对象。
+ StringBuffer是StringBuilder的线程安全版，在单线程下使用StringBuilder的性能比StringBuffer要高一点；两者API是相同的。



> 简述对字符串常量池的认识

+ 字符串常量池是JVM中用于储存字符串的特殊内存区域；
+ 由于字符串的不可变，JVM可以同在池中仅为每个字符串创建一份数据；
+ 其他所有String变量可以分配到字符串常量池中同样的值；
+ 在创建一个String类的时候，会到字符串常量池中寻找，如果存在会直接返回该引用；
+ 如果不存在，会将其添加到字符串常量池并将其引用返回；
+ 在JDK7之前，JVM将字符串常量池放在永久代中，这个空间具有固定的大小，不适合运行时控制，且不符合垃圾回收的条件；
+ JDK7开始，Java字符串常量池储存在堆空间中，有JVM进行垃圾回收，降低了OOM的风险；
+ 需要注意当使用new的方式创建字符串是，不会去常量池检查是否具有相同的对象；
+ 使用字面量的方式赋值采会到字符串常量池中检查；



> 简述业务中如何优化字符串拼接

+ 通常是使用StringBuilder进行字符串的拼接；



> 简述String中final 的应用

+ 如果字符串不可变，使用final修饰，可以优化字符串的拼接过程；
+ 字符串拼接的时候，如果发现String对象不可变，会直接将其优化为拼接的内容；
+ 这样一来可以减少StringBuilder的对象的创建，和中间对象的创建；

## 关键字、修饰符与特殊运算符

> 简述对static关键字的理解

+ 当一个类中的字段或方法不依赖与特定的对象实例，可以将其定义为static；
+ 如果将字段或方法定义为static，每个类中仅有一个这样的字段或方法；
+ 这个类的多个实例可以共享这个static域的内容；
+ static修饰的字段或方法可以对象名或类名的方式进行调用，通常推荐使用类名方式调用；
+ 由于static的作用域要比普通实例域的生命周期要长，因此static中不能访问普通字段或普通方法；



> 简述父子类的初始化顺序(静态变量、静态语句块、实例变量、普通语句块、构造函数)

+ 一个类在加载的时候，会在初始化阶段执行`clinit<>()`函数；
+ javac编译器会将类中的静态变量以及静态代码块收集作为`clinit<>()`的内容；
+ 当一个子类完成`clinit<>()`操作时，父类已经完成了该操作；
+ 构造函数在对象创建的时候被调用；
+ 在类的构造器执行前，其执行器父类的构造器；
+ 父类静态变量和静态语句块、子类静态代码块、父类的普通语句块、父类构造函数、子类普通语句块、子类构造函数；



> 简述内部类与static 关键字的关系、访问权限以及初始化时机

+ 内部类是定义在另一个类内部的类；
+ 内部类的方法可以访问外部类定义所在的数据，包含私有数据；
+ 内部类可以对同一个包中其他类隐藏起来；
+ Java中的普通内部类的对象具有一个隐式的引用，该引用指向了实例化该内部对象的外部类对象；
+ 通过这个隐式的引用，内部类可以访问外部类的全部状态；
+ 对于static内部类，没有这种附加的指针；
+ 内部类是一种编译器现象，与虚拟机无关；
+ 编译器会把内部类翻译成用$分隔外部类名与内部类名的常规类文件，虚拟机对其一无所知；



> 简述final 关键字的作用

+ final通常指修饰的字段、方法和类不可变；
+ final修饰字段时，表明这个字段只能被初始化一次，并且初始化完成之后不能改变；
+ 对于基本数据类型初始化完成之后其数字不能改变；
+ 对于引用数据类型初始化完成之后其对象引用不能改变，但不限制里面的内容不能改变；
+ 基于不可变性，可以使得编译器把常量进行代入计算，减少运行期的负担；
+ final修饰参数时，意味着在方法中不能改变参数指向的对象或基本变量；
+ final修饰参数主要用于传递数据给匿名内部类；
+ final修饰方法时可以给方法上锁，防止子类通过覆盖重写来改变方法的行为；
+ 类中的所有private方法都会隐式地指定为final；
+ final修饰类时意味着该类不能被继承，final类内部的方法会隐式地指定为final；



> 简述使用final 关键字的好处

+ final修饰的变量可以利用编译器的静态优化代码；
+ 如对于final类型的字符串，将两者进行拼接会比普通局部变量优化很多；
+ 对于final修饰的类变量，由于只能被初始化一次，编译器会其他用到这个变量的地方替换为最终来到引用；



> 简述static与final修饰变量所处JVM内存模型中的位置

+ final修饰的变量称为常量，static修饰的变量称为静态变量；
+ 在JVM中常量和静态常量等数据都储存在方法区中；
+ JDK1.7之前，方法区被放在被放在永久代中实现；
+ JDK1.7的时候，处于永久代中的字符串常量池和静态变量都被移出到堆中；
+ JDK1.8，废弃了永久代，方法区的实现在元空间中实现（字符串常量池、静态变量位于堆中，常量等位于元空间中）；



> 简述native的含义

+ native关键字只能用来修饰方法；
+ native修饰方法是表示方法的实现需要调用其他编程语言的代码，如C或C++；

【四种功能】

+ 通过native可以使用其他编程语言编写的系统调用或库实现接口；
+ 可以访问只能从其他语言访问的系统或硬件资源；
+ 可以将C/C++编写的遗留代码继承到Java程序中；
+ 可以使用Java中的任意代码调用硬件编译的动态加载库；

【三个目的】

+ 使用native可以提高系统性；
+ 实现机器级/内存级通信；
+ 使用已经存在的遗留的非java代码；

+ native主要是用于提高性能，但native关键字打破了java的平台无关性；



> 简述运算符instanceof的含义以及应用场景

+ instanceof可以检测一个对象是否为某个类或接口的实例；
+ 当null使用instanceof运算符，始终会返回一个false；
+ 通常instanceof与类型擦除一起使用；
+ 在将父类转换为子类之前，也应该使用instanceof进行检查，如equals方法；





简述super关键字的含义

> 简述super与this的区别

+ 在实例方法或构造函数中，this可以或当前对象的引用；
+ 可以在实例方法或构造器中通过this来获取当前对象的任何成员；
+ 在构造器中还可以调用同一个类的另一个构造器(如果存在对另一个构造器的调用，必须在构造器第一行)；
+ super可以引用父类对象，当子类与父类具有相同的成员段时，可以通过super显式指定使用父类的成员；
+ super关键字也可以用于根据参数调用父类的构造函数；
+ 调用super必须是类构造器的第一行，如无显式调用Java编译器会自动对超类的无参构造器的调用；



> 简述private，protected，public，default的区别

+ private仅对本类可见；类、接口、变量、方法。
+ public对所有类可见：使用对象：类、接口、变量、方法。
+ protected对本包和所有子类可见。使用对象是：接口、变量，不能修饰外部类。
+ defalut同一个包可见，不使用任何修饰符。使用对象是：类、接口、变量、方法。

## 面向对象

> 简述面向对象三大特征

+ 面向对象的三大特征是，封装、继承、多态；
+ 封装隐藏了一个对象的实现细节，使得对象内部的状态不为其他对象访问，对象的数据只能通过接口来访问；
+ 封装使得对象可以被看成一个「黑盒子」，可以对数据进行保护。一个对象实现方法的改变，不影响其他相关对象；
+ 通过封装可以是实现隐式保护、保护数据安全、隔离复杂度；
+ Java中通过权限修饰符实现封装特性。
+ 继承可以让一个类包含另一个类的状态和行为，除此之外，这个类还有自己的状态和行为；
+ 当一个类从另一个类继承而来，多态使得子类可以代替父类。



> 简述重写和重载的区别

【重写】

+ 重写是子列对父类允许访问的方法的实现过程就行重新编写，返回值和形参不能改变；
+ 重写的好处在于子类可以根据需求，定义自己特定的行为；
+ **重写方法不能抛出新的异常或比重写方法声明更加宽泛的异常**；
+ 重写必须保证重写函数名与参数列表完全相同，与返回的参数类型无关；
+ 重写方法访问权限不能比父类中被重写的方法的访问权限更低；
+ 声明为static或final的方法不能被重写；
+ 可以使用super关键字可以在子类中调用父类被重写的方法；
+ 可以使用@Override检查方法是正确重写；

【重载】

+ 重载在一个类中，方法名相同，参数不同，返回值可以相同也可以不同；
+ 每个重载的方法都必须都有一个独一无二的参数类型列表；
+ 重载最常用的就是构造器重载；

【重写与重载】

| 区别     | 重载       | 重写                             |
| -------- | ---------- | -------------------------------- |
| 参数列表 | 必须修改   | 不能修改                         |
| 返回类型 | 可以修改   | 不能修改                         |
| 异常     | 可以为修改 | 可以减少或删除，不能抛出新的异常 |
| 访问     | 可以修改   | 一定不能做更严格的限制           |

重写和重载是Java多态的的不同表现，重写是父类子类之间多态性的一种表现，重载可以理解为多态的具体表现形式；

+ 方法重载是一个类中定义了多个方法名相同，参数列表不同的，这种称为方法重载；
+ 方法重写是子类存在方法与父类的方法名相同，而且参数列表也相同，返回值也相同的方法；
+ 方法重载是有个类的多态性的体现，方法重写是子类与父类的一种多态性的表现；



> 构造器可以重写么?

+ 构造器无法重写，子类可以通过super调用父类不同重载的构造器；
+ 重写要求在父类中声明的内容，在子类中重新声明；
+ 父类的类名和子类的构造器是不一样的；



> 简述抽象类的相关特性

+ 面向对象的过程中，所有的对象可以通过类来进行描述；
+ 但是反过来，不是所有的类都是可以用来描述对象；
+ 如果一个类中没有包含足够的信息来描述一个具体的对象，这种类就是抽象类；
+ 抽象类不能实例化对象，但其成员变量、成员方法和构造方法的访问方式和普通类一致；
+ 抽象类必须被继承才能被使用，一个类只能被继承一次；

+ 在抽象类中可以定义抽象方法，如果一个类包含抽象方法，该类必须是抽象类；
+ 任何子类都必须重写父类的抽象方法，如果没有重写则需要将自己声明为抽象类；
+ 当然，抽象类可以不包含抽象方法。



> 简述接口的相关特性

+ 接口不是类，而是对类的一组描述定义；
+ 接口中所有方法默认都是public abstract，可以不提供public关键字；
+ 接口可以声明变量，且默认都是public static final修饰；
+ 类可以通过implement来实现多个接口，类必须要对实现的接口中的方法进行实现；



> 简述接口和抽象类的区别

+ Java中类只能是单继承，接口可以多实现；
+ 即一个类只能通过extends来继承一个抽象类，可以通过implements方法实现多个接口；
+ 抽象类的方法可以有方法体，而接口中的方法只能是抽象的；
+ 抽象类的成员变量可以各种类型，接口的成员变量只能是public static final类型；
+ 接口不能包含静态代码块以及静态方法，抽象类可以包含静态代码块和静态方法；

【注意】

+ JDK1.8之后，接口可以静态方法和方法体；
+ JDK1.8之后，接口可以包含具体实现的方法，称为默认方法，使用default修饰；
+ JDK1.9之后，接口运行定义为private，可以使得某些复用代码不会把方法暴露出去；



> 接口与抽象类在不同JDK版本中的变化

+ JDK1.8，接口可以包含 静态方法和方法体；
+ JDK1.8，接口可以包含具体实现的方法，称为[默认方法](https://www.runoob.com/java/java8-default-methods.html)，使用default修饰；
+ JDK1.9，接口运行包含private方法，private方法可以封装一共有的方法而不给暴露；



> 简述通过实例对象.方法名这种调用过程都做了什么

+ 方法调用不等于方法中代码的执行，方法阶段唯一的任务就是确定被调用方法的版本；
+ 一切的方法调用在Class文件中储存的都只是符号引用，而不是实际运行时的内存入口；
+ 方法调用需要将符号引用转换为运行时的内存入口地址，这种转换根据不同类型的方法可以分为两类：**解析调用和分派调用**；
+ 对于「编译器可见，运行期不变」的方法，可以在类加载的解析阶段将符号引用转换为直接引用，常见的有「静态方法、私有方法」。
+ 即对于「静态方法、私有方法」这类不可能通过继承或别的方式重写其他版本的可以在类加载阶段进行方法解析；
+ 
+ 方法调用分为两个阶段：静态解析和动态分配；
+ 其中静态解析发送在类加载阶段；
+ 在类加载阶段会根据静态类型决定具体调用的方法，这个阶段是重载实现过程；
+ 而动态分派阶段则发生在运行期间；
+ 由于静态解析阶段已经决定决定了需要执行那个方法，动态分配仅需要根据实际类型决定执行那个对象的方法即可，这个阶段是重写的实现过程；
+ 动态分配会自下而上搜索指定的方法，判断权限并将其进行执行；
+ 由于动态分配的过程非常频繁，Java虚拟机会在方法区中创建虚方法表来进行加速；
+ 虚方法表记录了类的各个方法的实际入口
+ 如果方法在子类中没有被重写，子类的虚方法表与父类的地址入口一致；
+ 如果子类中重写了该方法，子类虚方法表中的地址会替换为指向子类实现版本的入口地址；



> 为什么在父类中要定义一个没有参数的空构造函数

+ 如果一个类没有定义构造函数，JVM默认会为其添加一个空参的构造函数；
+ 如果一个类定义了带参的构造函数，JVM就不会为其创建空参的构造函数；
+ 如果父类中定义了带参构造，而没有显式定义空参构造函数；
+ 在其子类中构造函数中必须要使用super(参数)的方式进行调用，否则将会报错；
+ 因为子类构造器默认调用的是父类的空参构造器。



> [简述静态类和单例的区别](https://www.baeldung.com/java-static-class-vs-singleton)

| 单例模式                                                  | 静态类                                             |
| :-------------------------------------------------------- | :------------------------------------------------- |
| 单例是一种设计模式。                                      | 静态类基本上是在 Java 中将类组合在一起的一种方式。 |
| 一旦创建对象，就会分配内存。                              | 访问任何类成员后立即分配内存。                     |
| 单例实现可以有静态成员或实例成员。                        | 静态类只能包含静态成员。                           |
| 它可以实现任何其他需要的接口或基类。                      | 它不能实现接口或任何其他基类。                     |
| 单例类可以用作方法参数。                                  | 静态类不能用作方法参数。                           |
| 单例模式使用堆内存。                                      | 静态类使用栈内存。                                 |
| 它在垃圾收集器的范围内工作，因为它使用堆内存。            | 超出垃圾收集器的范围，因为它使用堆栈内存。         |
| 它支持依赖注入 (DI) 实现，因为 Singleton 遵循 OOPS 概念。 | 它不能实现依赖注入 (DI)，因为 DI 是接口驱动的。    |
| Singleton 是一种架构模式，而不是一种语言特性。            | 静态是一种语言特性，而不是一种架构模式。           |
| 可以处理对象。                                            | 它无法处理静态类，因为不能创建实例。               |



> 简述成员变量与局部变量的区别

+ 成员变量声明在类中，方法之外不用static修饰；局部变量声明在方法或构造方法或语句块中；

【局部变量】

+ 局部变量在方法、构造方法、语句块执行的时候创建，执行完成后被销毁；
+ 局部变量不能使用访问修饰符，只对声明它的方法、构造方法或语句块可见；
+ 局部变量是栈上分配，没有默认默认值，必须经过初始化才能使用；

【实例变量】

+ 实例变量初始化之后，每个实例的变量的值就确定；
+ 实例变量在对象创建的时候创建，对象销毁的时候销毁；
+ 实例变量具有默认值，可以使用访问修饰符对其使用访问权限进行限定；



> 简述静态方法和实例方法的区别

+ 实例方法依赖于具体的对象，在调用前需要创建具体的对象；
+ 静态方法依赖于类，不依赖任何对象，可以通过类名.的方式来调用；
+ 静态方法的生命周期比实例方法要长，因此实例方法可以调用静态方法，反之则不行；
+ 静态方法是类共享，同一个类的所有对象共享一个静态方法；
+ 实例方法是对象共享，同一个类的不同对象拥有不同的实例方法；



> 为什么Java中只有值传递

+ 值传递，在调用函数时，将实际参数的值复制一份传递到被调用函数中，在被调用函数中修改参数值不会影响原来实参的值；
+ 引用传递，在调用函数时，将实际参数地址直接传递到被调用函数中，在被调函数中修改参数值会影响原来实参的值。
+ Java中只有值传递，值传递的好处是调用的参数可以采用多种形式，如常量、变量或复杂表达式；

## 异常

> 简述对异常的理解

+ C语言以及早期的语言没有在语言层面处理错误的方式；
+ 早期的编程语言采用约定俗成的处理错误方式，通过返回值或设置标志位判断是否发生错误；
+ 这种约定俗成的方式要求程序员每次在调用的时候都要彻底进行错误检查，会使得代码难以阅读；
+ 后来人们决定采用强制规定的形式来消除异常处理中存在的问题；
+ 通过引入异常处理机制，可以降低错误代码的复杂度；
+ 使用了异常机制，不必在方法调用时进行检查，因为异常机制可以将错误进行捕获；
+ 异常机制不仅可以节省代码，还将「正常执行流程」与「异常情况处理流程」分离；
+ 总而言之，异常机制使得代码的阅读、编写和调试工作更加井井有条。



> 简述异常的继承体系
>
> 简述Exception和Error的区别

+ Java是面向对象的语言，Java中的异常通过类来体现；
+ Exception和Error都继承了Throwable类，Java中只有Throwable类实例能够采用try-catch或throw；
+ Exception和Error都是Java平台下对不同异常情况的分类；
+ Error是正常情况下，不大可能出现的错误，Error会导致程序不可恢复；
+ Exception是程序正常运行中可以预料的意外情况，可以被捕获并进行相应的处理；
+ Exception又分为「检查异常」和「不检查异常」；
+ 检查异常必须在源代码中显式捕获处理，会在编译期进行检查；
+ 不检查异常指运行时异常，通常是可以通过编码避免的逻辑错误；
+ 常见的检查 异常有IOException；
+ 常见的不检查异常有RuntimeException、ArrayIndexOutOfBoundException；
+ 在捕获异常的时候，通常不建议捕获通用的异常，而是捕获特定的异常；

> oom是Error还是Exception

+ 当Java堆中没有足够的空间分配对象，会抛出OOM异常；
+ 这种情况下，垃圾收集器无法腾出空间来容纳新的对象，堆也无法进一步扩展；
+ 此时系统将无法正常执行下去，属于Error



> 简述所知的运行时异常和编译时异常

+ 常见的非检查异常
  + ArithmeticException：异常的运算条件
  + ArrayIndexOutOfBoundsException：数组下标越界异常
  + ArrayStoreException：错误类型的数据存储到一个对象数组中引发异常
  + IllegalArgumentException：非法的参数异常
  + IllegalMonitorStateException：非法的监视器状态异常
  + IllegalStateException：非法的状态异常
  + IllegalThreadStateException：线程没有处于请求要求的状态抛出此异常
  + IndexOutOfBoundsException ：索引越界异常
  + NegativeArraySizeException：尝试创建负数大小的数组抛出此异常
  + NullPointerException：空指针异常
  + NumberFormatException：将字符串转换为数值，但字符串不能转换为适当格式抛出此异常
  + SecurityException：安全管理器抛出的异常
  + StringIndexOutOfBoundsException：索引为负数或超出字符串大小
  + UnsupportedOperationException：不支持请求的操作
+ 检查异常
  + ClassNotFoundException：应用程序尝试加载类的时候，找不到相应的类，抛出该异常
  + CloneNotSupportedException：调用Object的clone方法克隆对象，但对象类无法实现Cloneable接口时抛出此异常；
  + IllegalAccessException：拒绝访问一个类的时候，抛出此异常
  + InstantiationException：尝试使用newInstance方法创建一个类实例，但是由于对方是有个接口或抽象类而无法实例化，抛出此异常
  + InterruptedException：一个线程被另一个线程中断，抛出次异常
  + NoSuchFieldException：请求字段不存在
  + NoSuchMethodException：请求方法不存在
+ 异常常见的方法
  + **getMessage**：返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了。
  + **getCause**：返回一个Throwable 对象代表异常原因。
  + **printStackTrace**：打印toString()结果和栈层次到System.err，即错误输出流。
  + **getStackTrace**：返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底。
  + **fillInStackTrace**

> 简述throw和throws的区别

+ throw用于在代码中、函数或代码块中显式地抛出异常；
+ throws关键字在方法签名中用于声明函数在执行代码时可能抛出的异常；
+ throw后面抛出的是一次的实例，throws关键字后面是抛出的异常的类型；
+ throw异常只能 抛出一个异常，throws异常可以声明多个异常；
+ throws可以声明检查和非坚持的异常，但是throws只能用于传播检查异常；

## 泛型

> 简述对泛型的理解

+ Java泛型是JDK1.5引入的新特性；
+ 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型；
+ 泛型的本质是参数化类型，即可以将操作的数据类型指定为方法前面中的一种特殊参数；
+ 这种参数可以在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法；
+ 泛型能够让开发人员能够针对泛化的数据类型编写相同的算法，极大增强了编程语言的类型系统以及抽象能力；



> 简述对泛型擦除的认识

+ Java选择泛型的实现方式叫做「类型擦除式泛型」；
+ 与之相对的C#选择的是实现方式是「具现化式泛型」；
+ C#中的泛型无论是程序源码或编译后的中间语言表示、或运行时中都是保留泛型信息；
+ C#中`List<int>`和`List<string>`是两种不同类型，在系统运行期产生，有自己独立的虚方法表和类型数据；
+ Java中的泛型只留存在源码中，编译之后产生的字节码文件中；
+ 全部泛型都被替换为原来的裸类型，并且在相应的方法插入了强制的了类型转换代码；
+ 因此对于运行期的Java而言`List<Integer>`和`List<String>`是同一种类型；
+ Java的类型擦除式泛型无论是使用效果还是运行效率都落后于C#的具体化泛型；
+ Java的类型擦除式泛型唯一优势就是保证了以前没有使用泛型的库可以直接运行在Java5.0之上；
+ Java的类型擦除式泛型实现只需要在javac编译器上做出改进即可，无需修改字节码、和Java虚拟机；

【缺陷】

+ 类型擦除具有两方面缺陷：
  1. 不支持原始类型数据：由于不支持int、long等基础数据类型到Object类型之间的强制转换，因此Java选择不支持原始数据类型；
  2. 运行期无法取得泛型类型信息：由于运行期无法取得泛型信息，需要通过额外的泛型参数传递给Java虚拟机；

## 反射

> 简述对反射的理解

+ JVM在加载完类只会，会在方法区生成一个对应的Class类型的对象，这个对象包含了完整类的结构信息；
+ 这个Class对象就行一面镜子，可以反映类的内部结构，讲这种机制形象成为「反射」；
+ 反射允许我们在程序运行期间动态获取一个类的所有信息，并且能够直接操作该类任何对象内部属性以及方法；

> 简述反射的应用场景

+ 反射最常见的就是用于Spring框架；
+ Spring中Ioc通过反射来实现；
+ IoC，控制反转，即将对象的生命周期以及对象之间的关系等控制权从程序员较大Spring IoC容器；
+ Web容器在启动的时候回启动Spring容器，Spring容器在启动的时候回通过xml或扫描注解的发那个还是来创建各种bean，这种在运行期创建对象的返回正是反射；



> 简述反射的优缺点

+ 反射的优点是可扩展性高、可实现开发环境可视化、实现调试器和测试工具；
  + 可扩展性高：应用程序可以利用全限定类名创建可扩展对象的实例，使用外部用户自定义的类；
  + 开发环境可视化：可以通过反射获取类型信息，并对其进行可视化，可以帮助程序员编写正确的代码；
  + 调试器：调试器可以通过反射的方式获取类的私有成员信息；
  + 测试工具：测试工具可以利用反射自动调用类中定义的可被发现的API定义，确保一组测试中有较高的代码覆盖率；
+ 反射功能强大，但也存在缺点；
  + 反射涉及到动态类型解析，因此JVM无法对这些代码进行优化。因此反射操作的效率要比非反射的操作低很多；
  + 使用反射技术要求程序必须在一个没有安全限制的环境中，如果一个程序必须在有安全限制的环境中运行，就会存在问题；
  + 由于反射运行代码执行一些在正常情况下不被运行的操作，因此反射可能会导致意料之外的副作用，可能导致代码功能失调并破坏可移植性。

## 枚举

> 简述对枚举的理解

+ Java枚举是一种特殊的类，通常用于表示一组常量，如一年的4个季节，一个年的12个月，1个星期的7天等；
+ Java枚举使用enum关键字定义，各个常量使用逗号分割；
+ 尽管枚举看起来像一种新的数据类型，但是这个关键字只作用于编译器；
+ 从字节码层面，枚举仅仅是一个继承了java.lang.Enum、自动生成values和valueOf方法的普通Java类；



> 简述枚举与常量类的区别

+ JDK提供了专门针对enum实现了高度优化的Collection API，如EnumSet和EnumMap；
+ EnumSet内部表示为位向量，EnumMap内部表示为数组，两者表示形式非常紧凑且高效，相比于其他Collection API性能非常高效；
+ EnumSet和EnumMap是非同步的，使用时需要注意；
+ 枚举保证JVM中仅存在一个常量实例，可以安全使用「==」运算符比较两个变量；



> 简述枚举的本质

+ 枚举本质上是一个继承了java.lang.Enum，实现了Serializable接口的类；
+ 枚举本质上内部定义了一组预定义的常量，该常量必须等于其预定值之一；



> [简述枚举与序列化的关系](https://stackoverflow.com/questions/30671534/why-enum-singleton-are-serialization-safe)

+ 枚举类默认实现了Serializable接口，序列化对待enum有特殊对待；
+ 枚举序列化时仅仅储存了其class与常量的名称；
+ 反序列化时，这些信息用于炒作枚举类型现有的运行时对象；

+ 因此在异常运行中如果序列化同一个enum常量，将得到已序列化的同一运行时实例；
+ 但是在另一个JVM中进行反序列化时，hashCode可能会有所不同，但是这个不影响单例；
+ 综上所述，JVM保证enum仅有一个实例，因为枚举的序列化实现不会创建新的实例，而是会查找现有的常量；

## 序列化

> 简述对Java序列化的理解

+ Java提供了对象序列化机制，在该机制中，一个对象可以被表示为一个字节序列；
+ 该字节序列包含了该对象的数据、有关对象类型信息和存储子对象中数据的类型；
+ 可以通过ObjectInputStream和ObjectOutputStream来是实现反序列化和序列化一个对象；
+ 一个类的对象如果需要成功序列化，需要满足两个条件；
  + 实现了Serializable接口；
  + 所有属性是可序列化的，如果有属性不可序列化，需要标注为transient；



> 简述Java序列化的相关特性
>
> 简述Java序列化中serialVersionUID的作用
>
> 简述Java序列化中父类相关问题

+ 当一个Class实现了Serializable接口，它的子类也会实现Serializable接口；
+ 在一个引用了另外一个对象，这个对象也必须要实现Serializable接口，否则序列化时将会抛出NotSerializableException；
+ 当序列化独享中包含了一种Object对象，所有这些对象都必须是可序列化的，负责将会抛出NotSerializableException；
+ JVM会为每个序列化的Class分配一个版本号UID；
+ UID用于验证保存和加载的对象是否具有相同的属性，从而在序列化时保证兼容；
+ UID可以通过大多数IDE生成，往往会通过其类名、属性和相同访问修饰符；
+ 任何的改变都会导致不同的数字，并可能导致InvalidClassException；
+ 如果没显示指定UID，JVM会自动生成一个，但建议每个类添加UID；





> 简述对ArrayList中序列化的认识

+ ArrayList实现了Serializable接口，可以对其进行序列化与反序列化；
+ ArrayList中负责保存transient，因此该成员变量的内容不会被序列化；
+ ArrayList通过自定义writeObject和readObject方法来实现定制化的序列化与反序列化；
+ 在这两个方法中定义了elementData的序列化与反序列化策略；
+ 由于ArrayList动态数组，每次存储元素要满的时候回自动扩容；
+ 因此ArrayList中可能会存在很多null元素；
+ 为了保证不会同时对这么多的null对象同时进行序列化，ArrayList把数组设置为transient；
+ 并通过重写writeObject和readObject方法的方式将元素保存下来；

> 简述Java序列化的几种方式

> 简述Java序列化背后的原理(源码)



## 代理

> 简述对静态代理的理解

+ 代理模式可以在不改变原有类代码的情况下，通过引入代理类来给原始类附加功能；
+ 代理模式主要有两种实现方式：动态代理和静态代理
+ 静态代理在编译期就生成，对目标的每个方法增强都会通过手动完成；
+ 静态代理的实现主要有以下几个步骤：
  1. 定义一个接口以及实现类；
  2. 创建一个代理类实现该类；
  3. 将目标对象放到代理类中，任何代理类的对应方法调用目标类的对应方法，在调用前后对其进行这不过去把把关
+ 每个代理对象需要实现与目标对象一致的接口，一个接口增加方法，目标对象与代理对象都要进行修改，不利于代码维护；



> 简述对动态代理的理解

+ 动态代理在实现功能功能增强的时候，不需要针对每个目标对象单独创建一个代理类；
+ 动态代理的实现方式主要有两种：JDK动态代理和cglib动态代理；



> 简述对cglib 代理的理解

+ CGLIB动态代理基于CGLIB实现，CGLIB是一个基于ASM的动态字节码生成库，运行在运行期间对字节码进行修改和动态生成；
+ CGLIB通过继承的方式来实现代理；
+ CGLIB代理的编码过程分为以下步骤：
  1. 确定被代理的类；
  2. 自定义 MethodInterceptor 并在 intercept 方法进行对象增强；
  3. 通过Enhancer类的create方法创建对象；

> 简述cglib和jdk的这两者之间性能的区别

+ CGLib底层通过ASM字节码生成框架，使用字节码技术生成代理对象；
+ JDK1.6前比反射效率要高；
+ JDK1.7和JDK1.8jdk对动态代理有了优化，在调用次数较少的情况下，JDK代理效率高；



> 动态代理用多了之后对内存方面有什么影响

+ 大量使用动态代理会导致产生大量的动态类；
+ 当增强的类越多，就需要更大的方法区来保证动态生成的新的类型可以载入内存；



> 动态代理、反射生产的对象在jvm 的哪里?会不会影响到永久代或者是8以后的元空
> 间?

+ 动态代理、方式产生的类型数据在方法区中；
+ 在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代 理效率高于CGLib代理效率；
+ 只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点；
+ 但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。

