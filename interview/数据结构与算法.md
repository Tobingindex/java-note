# 数据结构与算法

> Hash如何实现？如何解决冲突？有几种解决方案？

+ Hash表可以看做是数组的延伸，由数组演化而来，利用了数组支持下标随机访问数据的特性；
+ Hash表的实现关键是将键值key转换为对应数组的下标，这个过程主要有哈希函数来实现；
+ Hash表中哈希函数主要关注两个特性：冲突概率小、运算高效；
+ 由于Hash表中创建的数组是有限的，而我们输入的数据是无限的；
+ 基于鸽巢原理，肯定会存在哈希冲突，即存在两个或以上的数据经过哈希函数运算得到同样的下标；
+ 对于哈希冲突的情况主要有两种解决方案：开放寻址法和链表法；
+ 开放寻址法：当出现哈希冲突，重新探测一个空闲的位置，将其插入；
  + 所有数据保存在一个数组，冲突代价高，装载因子不能太小，浪费更多内存空间❌
  + 删除数据麻烦，需要标记已删除数据❌
  + 数据存储在数组，可以有效利用CPU缓存加速✔️
  + 序列化简单✔️
+ 链表法：每个数组元素是一条链表，将哈希冲突的元素挂接在链表上；
  + 数据保存在链表，无法利用CPU缓存，序列化困难；
  + 数据保存在链表，无法利用CPU缓存，序列比较困难❌
  + 链表法的链表节点需要才创建，内存利用率较高✔️
  + 更加灵活，可以改造为红黑树等高级动态数据结构，实现更加高效的查找✔️



> 常见的排序算法的时间复杂度. 空间复杂度？

| 排序算法                                                     | 是否原地 | 是否稳定 | 时间复杂度 | 空间复杂度 | 备注        |
| ------------------------------------------------------------ | -------- | -------- | ---------- | ---------- | ----------- |
| 冒泡排序                                                     | ✔️        | ✔️        | O(n*n)     | O(1)       |             |
| 插入排序                                                     | ✔️        | ✔️        | O(n*n)     | O(1)       |             |
| 选择排序                                                     | ✔️        | ❌        | O(n*n)     | O(1)       |             |
| 归并排序                                                     | ❌        | ✔️        | O(nlogn)   | O(n)       |             |
| 快速排序                                                     | ✔️        | ❌        | O(nlogn)   | O(1)       |             |
| [希尔排序](https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F) | ✔️        | ❌        | O(nlogn)   | O(1)       |             |
| [桶排序](https://zh.wikipedia.org/wiki/%E6%A1%B6%E6%8E%92%E5%BA%8F) | ❌        | ✔️        | O(n+k)     | O(n*k)     | k：数的范围 |
| [计数排序](https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F) | ❌        | ✔️        | O(n+k)     | O(n+k)     | k：数的范围 |
| [基数排序](https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F) | ❌        | ✔️        | O(kn)      | O(k+N)     | k：数字位数 |

![image-20210918151923475](https://gitee.com/tobing/imagebed/raw/master/image-20210918151923475.png)

> 默写快排. 堆排和归并排序

+ 快排：
+ 归并：
+ 堆排：

> 快排在Java中的实现（源码）

+ Java的[Arrays.sort(int)](https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#sort(int[]))使用[双路快排](java.util.DualPivotQuicksort)实现；
+ DualPivotQuicksort实现包含了：计数、插入、选择、快排
+ 当需要排序的数据长度较短，选择使用计数排序，如byte、short等数据；
+ 当需要排序的数据长度较长，且数组长度较小时，使用插入排序；（插入排序复杂度系数小）
+ 当需要排序的数据长度较长，且数组长度中等时，使用归并排序；（浪费内存较少）
+ 当需要排序的数据长度较长，且数组长度较大时，使用双路排序；（快排是原地算法）



> 二叉搜索树的使用场景. 搜索的时间复杂度为？

+ 二叉搜索是为了实现快速查找而产生的，不仅支持快速查询、还支持快速删除和快速插入；
+ 二叉搜索树的数据复杂度为O(h)，h为树的高度；
+ 二叉搜索树的性能容易受到数据样本影响，极端情况下可能会退化为链表；



> 平衡查找树、红黑树的区别于认识？

+ 平衡二叉树是绝对平衡的二分查找树；
+ AVL为了维护这些绝对平衡的性质，需要在插入和删除元素的时候花费更多的资源进行维护；
+ 红黑树则是相对平衡的二分查找树；
+ 由于红黑树只需要维护相对平衡，在插入、删除元素的时候需要消耗的资源就更少；
+ 因此在实际使用哪种红黑树比AVL相比更加常见。



> B树、B+树的区别于认识？

【[B树](https://zh.wikipedia.org/wiki/B%E6%A0%91)】

+ B树，自平衡多叉树。适用于读写相对大的数据块的储存系统，如磁盘；
+ B树可以减少定位记录经历的中间过程，从而加快存取速度；
+ B树内部节点(非叶子)节点可以拥有可变数量的子节点；
+ 当数据插入和删除时，由于子节可变，因此无需先AVL那样频繁维护平衡度；
+ 2-3树是一种B树，每个及诶单那内部只能有2或3个子节点；

【[B+树](https://zh.wikipedia.org/wiki/B%2B%E6%A0%91)】

+ B+树是一种树形数据结构，常用于数据库和操作系统的文件系统；
+ B+树能够保证数据稳定有序，插入和修改拥有稳定的时间复杂度；
+ B+树与B树类似，通过预分配空间，来减少维护平衡度的操作，提高性能；

【[B树 vs B+树](https://www.geeksforgeeks.org/difference-between-b-tree-and-b-tree/)】

[BTree vs B+Tree](https://stackoverflow.com/questions/870218/what-are-the-differences-between-b-trees-and-b-trees)

| B树                                         | B+树                                       |
| ------------------------------------------- | ------------------------------------------ |
| 叶子和非叶子节点都有数据指针                | 只有叶子节点有数据指针                     |
| 不是是由key都在叶子上，通常搜索需要更多时间 | 所有key都在叶子节点上，搜索更快更准        |
| 树中不会维护重复的key                       | 保留重复的key，所有及诶单那都存在叶子      |
| 插入需要更多时间，有时候无法预测            | 插入相对更加容易，性能稳定                 |
| 删除非叶子节点非常复杂，树需要经过多次变换  | 删除任何节点都很容易，因为所有节点都在叶子 |
| 叶子节点之间不使用链表连接                  | 叶子节点之间使用链表连接                   |
| 不存在重复的key                             | 可能存在冗余的key                          |

总而言之，B树与B+树最大的不同有两点：数据存储的地方、叶子节点是否使用链表连接；

+ B树的数据既会存在于叶子节点，也会存储在非叶子节点；
+ B+树的数据只将数据存储在非叶子节点，索引项存储在非叶子节点；
+ 一般而言，索引项都会比数据项要小，将所有数据存储在叶子节点；
+ 可以使得非叶子可以储存更多的索引项，可以以更少的数据项定位更多的数据；（更高缓存命中率）
+ B树的叶子节点不使用链表连接；B+树的叶子节点链表连接；
+ 使用链表将叶子节点进行连接可以方便实现范围查询

> Trie树的认识？

> 默写拓扑排序并进行讲解

> 默写Floyd和Dijkstra

> 树形结构的认识