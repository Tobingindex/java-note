# 计算机网络

> 计算机网络体系结构？

+ 计算机网络体系结构主要有两个标准：OSI参考模型与TCP/IP模型；

+ 两个模型都采用分层的思想，即每层使用下层提供的服务，实现自己的功能和协议，并为上一层提供服务；

【OSI】

+ OSI参考模型将计算机分为七层，分别是：应用层、表示层、会话层、运输层、网络层、数据链路层、网络层。
+ OSI的应用层负责定义应用进程之间的交互规则，表示层主要提供数据压缩，数据加密以及数据描述的功能；会话层负责为两个通信实体之间创建和管理会话；
+ OSI的运输层主要为两个应用进程之间提供服务；
+ 计算机传输数据的链路很多，网络层主要任务是选择合适的网间路由和交换节点；
+ 两台计算机之间传输数据，总是一段一段地进行传送，数据链路层负责将网络层的IP数据包分装成帧，在两个相邻节点之间传送帧；
+ OSI物理层定义了传输接口的物理特征，屏蔽了传输介质的差异，实现计算机节点之间比特流的透明传输；

【TCP/IP】

+ 尽管OSI定义很标准，但是没有考虑到实际的需求，使得该模型很复杂，部分功能冗余；
+ 计算机网络实际标准是TCP/IP协议。
+ TCP/IP协议将计算机网络分为网络分为四层：应用层、运输层、网络互连层、网络访问层。
+ 应用层，对应OSI应用层、表示层、会话层，通过不同应用层协议提供不同的功能；
+ 运输层，对应OSI运输层，为上层应用层应用提供两种主要通信方式，TCP和UDP；
+ 其中TCP面向连接，提供可靠通信，UDP面向无连接，提供快速通信能力；
+ 网络互连层，对应OSI网络层，负责相同或不同网络的计算机之间通信，主要提供两大功能，寻址和分段，将运输层数据分段，并在选择不停的传送线路。
+ 网络接入层，对应OSI的数据链路层，负责监视数据在主机与网络之间的交换。

【两者异同】

+ OSI和TCP/IP都使用了分层模型来简化计算机网络设计，都提供了面向连接和无连接的两种通信方式；
+ OSI采用的是七层模型，对计算机网络划分的更为细致，而TCP/IP采用的是四层协议，且没有对网络层的定义；

【为什么去掉表示层与会话层】

+ 由于表示层与会话层的功能都是应用程序内部实现的，最终产生的是一个应用数据包，而应用程序之间很难实现代码共享，这两部分很难分开，于是在TCP/IP中将这两次划分到应用层中。

【数据在各层之间传输过程】

+ 发送端将应用程序封装好的应用层报文交给运输层；
+ 运输层收到报文添加上运输层首部（源端口、目的端口）交给网络互连层；
+ 网络互连层收到报文，为其添加上IP首部（原地址、目的地址、首部校验、TTL）交给网络接入层；
+ 网络接入层收到IP报文，IP封装成帧（添加上帧头帧尾、透明传输）并进行差错控制（CRC校验，丢弃错误的报文），最终将数据帧放到网络介质上传输。



> IP层的各种协议？

+ IP层主要向上提供鉴定灵活的、无连接的、尽最大努力交付的数据报访问；
+ IP层是TCP/IP体系中最主要的协议之一，与IP协议配套的还有四个协议；
+ ARP协议：地址解析协议，将IP地址转换为硬件地址(MAC地址)，解决同一局域网中主机或路由器IP地址和硬件地址映射问题；
+ RARP协议：逆地址解析协议，将硬件地址转换为IP地址；
+ ICMP协议：网际控制报文协议，报告IP数据报差错信息，包含「差错报告报文」与「询问报文」；
+ IGMP协议：网际组管理协议，主要实现多播功能；



> Ping命令做了什么？基于哪一层？

+ ping用于测试两个主机之间的连通性；
+ ping使用ICMP回送请求与回送回答报文；
+ ping是应用层直接使用网络层ICMP协议，没有通过TCP或UDP。



> 面向无连接和面向连接的服务

+ 运输层分别提供了面向连接的TCP协议和面向无连接的UDP协议。

【UDP】

+ UDP是无连接的，发送数据前不需要建立连接；
+ UDP使用尽最大努力交付，不保证可靠交付，也不使用拥塞控制；
+ UPD面向报文，无拥塞控制，适合多媒体通信需求；
+ UDP支持一对一、一对多、多对一和多对多通信；
+ UDP首部很小，只有8个字节；
+ UDP对应用层交下来的报文，既不合并，也不拆分，直接保留报文边界，交给IP层；
+ UDP对IP层交上来的UDP用户数据报，去除首部之后原封不动交给上层应用进程；

【TCP】

+ TCP是面向连接的运输层协议；
+ 每条TCP有两个端点，每个TCP连接只能是点对点；
+ TCP提供可靠交付服务，提供面向字节流的全双工通信；
+ TCP对应用进程一次把多长的报文发送给TCP缓存并不关系；
+ TCP根据对方给出窗口值和当前网络拥塞程度决定一个报文段包含多少个字节；（与UDP有很大的不同）
+ TCP会把较长的数据划分短一些在再传送。有可能等待积累足够多字节再构成报文段发送出去；
+ TCP连接的端点不是主机，而是套接字Socket。



> 为什么UDP实时性好？

+ 运输层主要有两个主要协议，一个是TCP，另一个就是UDP。
+ TCP为了保证可靠传输，可能会把较长的数据划分短一点，或把较少的积累足够多再构成报文端再发送出去，主要不利用实时性；
+ 而UDP使用时尽最大努力交付，不保证可靠交付，也不使用拥塞控制，报文首部结构简单，占用较少；
+ 同时UDP对于应用层交下来的报文既不合并也不拆分，直接保留报文边界，交给IP层；
+ 对于IP层交上来的UPD用户数据报，取出首部之后原封不动交个上传应用程序，这样的特性有利于实时传输。



> UDP数据报的组成？

+ UDP主要有两部分报文，数据部分和首部字段；
+ 首部有8个字节，由4个字段组成，每个字段两个字节；
+ 4个字段分别是：源端口、目的端口长度、校验和；
+ 计算校验和是还会加上「伪首部」，校验的是全部数据内容。



> TCP报文首部主要字段的含义？

+ TCP首部分为固定部分和扩展部分；
+ 固定部分包含了：
  + 源端口、目的端口：端口是运输层与应用层的服务接口；(16位，65536个)
  + 序号：报文段发送数据第一个字节的序号，TCP为数据流中每个字节编号；(32位)
  + 确认号：期望收到对方下一个报文段的数据的第一个字节序号；(32位)
  + 数据偏移：TCP报文的数据其实出距离TCP报文段其实多远，单位是4字节；(4位)
  + 保留字段：保留位今后使用；(6位)
  + URG：紧急字段，为1时表示紧急指针有效，告诉系统此报文有紧急数据，应尽快传输；
  + ACK：ACK=1，确认号字段有效，否则无效；
  + PSH：PSH=1，尽快交付接收应用进程，而不是等待缓存填满再交付；
  + RST：RST=1，TCP连接出现严重差错，必须释放里连接，重新建立运输连接；
  + SYN：SYN=1，是有一个连接请求或连接接收报文；
  + FIN：FIN=1，释放一个连接；
  + 窗口：让对方设置发送窗口的依据，单位为字节；(16位)
  + 校验和：校验首部和数据部分，校验是加上12字节伪首部；(16位)
  + 紧急指针：本报文中紧急数据字节数(紧急数据会放到报文段数据最前面，16位)
+ 可变部分：
  + 选项(长度可变)：最大报文段长度(MSS)，告诉对方自己接收报文段的数据字段最大长度；
  + 填充字段：还是首部长度是4字节整数倍。



> TCP可靠传输的实现？

【支持机制】

+ TCP通过：数据分块、序列号和确认应答、校验和、流量控制、拥塞控制、ARQ协议、超时重传；
+ 数据分块：应用层数据会被分割成TCP认为合适的发送数据库；
+ 序列号确认应答：TCP会为发送的数据每个字节编号，每次接收方收到数据都会对传输方进行确认应答；
+ 校验和：TCP将记录首部和数据部分的校验和，检查传输过程中报文段数据是否有差错，有差错则不确认；
+ 流量控制：为了避免对方来不及处理，TCP双方会维护固定的缓冲区，发送方发送数据量不超过接收端缓冲区；当接收方来不及处理发送方数据，会提示发送方降低发送速率，防止产生丢包。TCP通过滑动窗口协议来支持流量控制；
+ 拥塞控制：当网络中某个节点发送拥塞时，减少对网络中数据量的发送；
+ ARQ协议：发送完分组，会等待对方确认，收到确认之后才进行下面的数据发送；
+ 超时重传：TCP发出一个报文后，启动一个定时器，等待目的端确认收到这个报文段。如果超时没有接受，重复这个报文段。

【具体实现】

+ TCP连接的每一端必须设置两个窗口，发送窗口、接收窗口；
+ TCP机制通过字节序号进行控制，TCP所有确认基于序号确认而非报文段；
+ TCP两端的四个窗口经常处于动态变化，以适应不同的网络环境；



> ARQ协议？

+ ARQ，自动重传协议，TCP发出一个报文之后回去启动一个定时器，如果超时时间内没有收到确认，会自定将该数据报进行重传。这样可以使得接收方不需要请求发送方和重新请求魔鬼出错的分组，只需要不丢该分组确认即可。

+ 一发一确认的ARQ方式效率很低，通常使用的是**流水线传输**，即发送方连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认；对于接收方一般采用**累积确认**，即不必对收到的分组组个发送确认，而是对按序到达的最后一个分组发送确认即可。



> 流量控制？

+ 流量控制就是让发送方发送速率不要太快，要让接收方来得及接受，不要使网络发送阻塞；
+ TCP协议中的流量控制通过滑动窗口实现；
+ 当接收方来不及处理发送方的数据时，可以适当将滑动窗口变小，这样一来每次发送的数据就变小了；
+ 当接收方觉得对方发送的数据太慢，可以适当将滑动窗口调大，这样一来每次发送的数据就便多了；



> 拥塞控制及其算法？

+ 拥塞控制目的是让网络能承受现有的网络负荷，避免网络持续变差而进入瘫痪；
+ 拥塞控制是动态的过程，检查拥塞是困难的；
+ 拥塞控制主要有以下几种方法
  + 慢开始和拥塞避免：
  + 快重传和快恢复；

【拥塞窗口】

+ 发送方维持一个拥塞窗口，其大小取决于网络的拥塞程度，并动态变化；
+ 发送方让自己的发送窗口等于拥塞窗口；
+ 发送方控制窗口大小原则是，只要网络没有出现拥塞，拥塞窗口就增大一些，以便把更多分组发送出去；如果出现拥塞，拥塞窗口就减少一些，以减少注入为了中的分组中；

【慢开始算法】

+ 主机刚开始发送报文是，先设置拥塞窗口cwnd=1；
+ 没收到一个新的报文段确认，将拥塞窗口加1；
+ 通过上述的方法逐步增大发送端拿到拥塞窗口cwnd，使分组注入到网络的速率更合理；
+ 在使用慢开始算法时，没经过一次传输轮次，拥塞窗口cwnd加倍；
+ 慢开始算法的执行会受到「慢开始门限状态量ssthresh」限制；
+ 当cwnd大于ssthresh之后，不再使用慢开始算法，而改用拥塞避免算法；

【拥塞避免算法】

+ 拥塞避免的思路是个让拥塞窗口缓慢的增大，每经过一个RTT，不再把cwnd加倍，而是cwnd加1；

【出现拥塞】

+ 无论是慢开始还是拥塞避免阶段，只有发送方判断网络出现拥塞，就会被慢开始门限状态量减半；
+ 然后把拥塞窗口重新设置为1，执行慢开始算法；
+ 这样做的目的是迅速加锁主机发送到网络中的分组树，使得发送拥塞的路由器有足够时间吧队列中积压的分组处理完毕；

![image-20210913160131806](https://gitee.com/tobing/imagebed/raw/master/image-20210913160131806.png)

+ 乘法较少：网络慢开始还是拥塞避免阶段，出现一次超时，把慢开始门限值减半；
+ 加法增大：执行拥塞避免之后，在收到对所有报文确认好，cwnd加一，使其缓慢增大，防止网络过早出现拥塞。

【快重传】

+ 快重传可以使得在某些情况下可更早地重传丢失的报文段；

+ 快重传算法要求接收方每收到一个失序报文立即发出重复确认，这样可以让发送方及早知道**有报文段没有到达接收方**；
+ 发送方只要一连收到三个重复确认应当立即重传对方尚为收到的报文段；

【快恢复】

+ 发送端收到三个重复确认，执行「乘法计算」算法，对慢开始门限值减半，但接下来不执行慢开始；
+ 由于发送方认为网络可能没有发送拥塞，因此不再是慢开始，即不是将cwnd设置为1，而是设为慢开始门限值建表的数值，然后开始执行拥塞避免算法，是拥塞窗口缓慢的增加。

![image-20210913161115972](https://gitee.com/tobing/imagebed/raw/master/image-20210913161115972.png)



> 拥塞控制与流量控制的区别？

拥塞控制与流量控制的目的不一样：

+ 拥塞控制是保证无论能够承受现有的网络负荷，确保网络不瘫痪；
+ 拥塞控制是一个全局性的过程，涉及到网络行的所有主机、路由器，以及与降低网络传输性能能有关的所有因素；
+ 流量控制则是保证对方能够来得及处理，避免造成数据的丢包；
+ 流量控制是一个局部性的过程，通常设计的是发送端和接收端两个主机；



> TCP三次握手过程？

TCP连接连接前，服务器需要完成初始化只要会经历了以下过程：

1. 服务器初始化Socket、执行bind函数将服务绑定在一个众所周知的端口上；
2. 之后服务器执行listen函数，将原先的Socket转换为服务器端的Socket，最终服务器阻塞在Accept上等待客户端连接；

在服务器端准备就绪，客户端可以连接到服务器，连接过程如下：

1. 客户端初始化Socket、执行connect先服务器的地址和端口发送连接请求；
2. 客户端向服务器发送一个SYN请求报文，表示希望与服务器建立连接；
3. 服务器收到之后，如果同意则向客户端发送一个ACK，SYN报文表示同意客户端的连接，并希望与客户端建立连接；
4. 客户端收到服务器报文之后，发送ACK同意服务器的连接；
5. 以上三步执行完毕之后，服务器会通知上层应用，TCP连接已经建立。



> 为什么需要三次握手？

1. 三次握手的主要目的是确认双方的收发功能都是正常的，确保双方能够进行可靠通信；
2.   如果使用两次握手，客户端知道服务器的收发功能是否正常，服务器却不知道客户端接收是否正常；



> TCP释放连接的过程？

1. 主动关闭的一方A会先对方B发出连接释放请求；（FIN）
2. B收到A连接释放报文，会发出确认；（ACK）
3. 此时B会通知服务器A到B方向的数据传输关闭；【TCP处于版关闭状态】
4. 如果B没有要向A发送的数据，应用程序会通知TCP释放连接；（FIN+ACK）
5. A收到连接释放报文，必须发出确认；（ACK）
6. A在发出确认之后，必须要等待2MSL时间才进入关闭状态。





为什么挥手时不采用三次挥手？

为什么建立连接时三次握手，关闭连接时四次挥手？

TCP四次挥手、第四次挥手时一直丢包怎么办？

> 为什么客户端最后要等待2MSL？

1. 保证主动关闭的一方最后发送的ACK报文能够到达对方；
2. 防止「已失效的连接请求报文段」出现在本连接；
3. 客户端发送完最后一个ACK报文之后，经过2MSL，可以使得本连接持续时间内产生的所有报文段从网络上中消失；
4. 这样可以使得下一个新的连接中不会出现就的连接请求报文段；





如果已经建立连接，但是客户端突然出现故障怎么办？

UDP和TCP的区别？

HTTP请求报文的组成部分？

HTTP响应报文的组成部分？

HTTP状态码以及其意义？

长连接以及短链接的区别？

长连接与短链接的使用场景？

HTTP各个版本在功能上的演变？

如何解决HTTP的无状态性？

HTTP中Get和Post的区别？

HTTPS与HTTP的区别？

HTTPS握手的过程？

HTTPS绝对安全吗？

CA是什么？

SSL与TSL？

URL与URI的区别？

Cookie与Session认识？

Cookie的不可跨域性？

Session的创建与使用过程？ 

Session的生命周期？

Cookie与Session的应用场景以及区别？

浏览器输入URL地址到显示主页的过程发生了什么？

路由器与交换机的区别？

DNS寻址过程？

常见应用层协议对应的端口？

FTP为什么使用两个端口？

