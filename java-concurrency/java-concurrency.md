# java-concurrency

## 并发基础

多任务处理是现代计算机的必备技能。通过多任务处理，一方面可以充分利用计算机处理器的能力，另一方面可以提高程序的处理效率。

### 硬件效率与一致性

**缓存一致性**

绝大部分运算任务不能只靠处理器来完成，处理器至少与内存交换，如读取数据、储存运算结果。由于处理器与内存之间运算速度存在几个数量级差距，现代计算机系统通常引入高速缓存来作为内存与处理器之间的缓存：

+ 将运算器需要使用的数据复制到缓存，加快运算进行；
+ 运算接收从将结果放到缓存，再由缓存同步到内存，加快内存写入；

引入了高速缓存可以很好解决处理器与内存之间的速度矛盾，但是也引入了新的问题--缓存一致性问题。多路处理器系统中，每个处理器有自己的高速缓存，它们共享同一主内存。当多个处理器运算任务都设计同一块主存，就会可能导致各个缓存中数据不一致。

为了解决缓存一致性问题，需要各个处理器访问缓存时都需要遵循一些协议。在Java虚拟机中定义的「内存模型」可以避免缓存一致性问题。

**指令重排序**

除了添加高速缓存，为了让处理器内部运算单元尽可能被充分利用，处理器可能会对输入代码就行乱序优化。处理器只保证乱序优化的指令执行结果与顺序执行的结果是一致的，但不保证程序中各个语句计算的先后顺序与输入代码的顺序一致，因此如果存在一个任务依赖另外一个任务的中间结果，其他顺序性不能靠代码的先后顺序保证。

### Java内存模型

目的==>定义==>概念

《Java虚拟机规范》定义了「Java内存模型」来屏蔽各种硬件和操作系统的内存访问差异，可以实现让Java查询在各种平台下都能达到一致的内存访问效果。（保证足够严谨和足够宽松）

Java内存模型主要目的是**定义程序中的各种变量的访问规则**，此处的变量包含了被线程共享的实例字段、静态字段和构成数组对象的元素，不包括线程私有的局部变量和方法参数。

Java内存模型规定：<font style="color:red">**所有的变量保存在主内存中，每条线程都有自己的工作内存，线程的工作内存保存了该线程使用的变量的主内存副本。线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存的数据。不同线程之间无法直接访问对方的工作内存的变量，线程间变量值的传递需要经过主内存来完成。**</font>（不严谨地说，在Java层面，可以将主内存看做Java堆中的对象实例数据部分，工作内存看做虚拟机栈中的部分区域；在硬件层面，可以将主内存看做是为了内存，工作内存对应于寄存器和高数缓存）

**内存之间的交互操作**

Java内存模型定义了8钟操作来规范变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存，Java虚拟机实现时保证每种都是原子性的。对于没有被volatile修饰的64位数据类型的读写操作可以划分为两次32位操作进行（long和double的非原子性协定）。

| 操作   | 作用域   | 作用                                                     |
| ------ | -------- | -------------------------------------------------------- |
| lock   | 主内存   | 把变量标识为一条线程独占                                 |
| unlock | 主内存   | 把锁定状态的变量释放，从而可以被其他线程使用             |
| read   | 主内存   | 把一个变量的值从主内存传输到工作内存，以便于随后load使用 |
| load   | 工作内存 | 把read得到的变量值放到工作内存的变量副本中               |
| use    | 工作内存 | 把工作内存的变量值传递个执行引擎                         |
| assign | 工作内存 | 把执行引擎接收的值赋给工作内存的变量                     |
| store  | 工作内存 | 把工作内存中一个变量值传送给主内存，以便于随后write使用  |
| write  | 主内存   | 把store得到的变量放到主内存中                            |

store和write必须顺序执行，但不要求连续，可以是store=>store=>write=>write，同理read和load也是。

![jmm_8_type_instruction](https://gitee.com/tobing/imagebed/raw/master/jmm_8_type_instruction.jpg)

**volatile的变量语义**

volatile可以认为Java虚拟机提供的最轻量级的同步机制。当一个变量被volatile修饰，将具备两项特性：

+ 保证此变量对所有线程的**可见性**，即一条线程修改了这个变量值，新增对于其他线程可以立即得知；
+ volatile变量的指令**禁止重排序优化**，本质会在本地代码中插入许多内存屏障指令（立即将指令修改同步到主内存，从而让CPU无法对其进行重排序优化）来保证处理器不发生乱序执行。

**原子性、可见性与有序性**

Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性三个特征建立。

+ 原子性：Java内存模型直接保证read、 load、 assign、 use、 store和write6个操作的原子性；对于更大操作的原子性保证，Java内存模型提供了lock和unlock操作来满足需求，如synchronized。
+ 可见性：Java内存模型保证volatile修饰的变量，新值能够立即同步到主内存中，每次使用前能立即从主内存刷新；Java内存模型保证对一个变量执行unlock前必须把变量同步到主内存中（对应于synchronized）；Java内存模型保证被final修饰的字段在构造器中一旦被初始化完成，其他线程就能看见final字段的值。
+ 有序性：Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。  

**happen-before原则**

在Java内存模型中，happen-before原则定义两项操作之间的偏序关系，如操作A**先发生于**操作B，也即操作A产生的影响能够影响B，「影响」包含了修改内存中共享变量值、发送了消息、调用了方法等。

Java内存模型中存在下列天然的「happen-before」原则。

+ 程序次序规则：在一个线程内，按照控制流程，在前面的操作先发生于后面的操作；
+ 管程锁定规则：一个unlock操作先发生于后面对同一个锁的lock操作；
+ volatile变量规则：对一个volatile变量的写操作先发生于后面对这个变量的读操作；
+ 线程启动规则：Thread对象的start()方法先发生于次线程的每一个动作；
+ 线程终止规则：线程的所有操作先发生于对此线程的终止检查；
+ 线程中断规则：对线程的interrupt()方法的调用先发生于被中断线程的代码检测到中断事件的发生；
+ 对象终结规则：一个对象的初始化完成先发生于它的finalize()方法的开始；
+ 传递性：如果操作A先发生于操作B，操作B先发送与操作C，则操作A先发生于操作C。

Java语言无须任何同步手段保障就能成立的先行发生规则有且只有上面这些规则。

### Java与线程

线程是比进程更加轻量的调度执行单位，线程引入可以把进程的资源分配和执行调度分开。各个线程可以共享进程资源（内存地址、文件I/O等），又可以独立调度。目前线程是Java中进行处理器资源调度的最基本单位。

JDK1.3起，主流平台的主流商用Java虚拟机的线程模式普遍采用基于操作系统元素线程模型实现。如HotSpot中，每一个Java线程都是直接映射到一个操作系统原生线程来实现。

**线程调度**

线程调度主要有两种方式：协同式线程调度和抢占式线程调度。

+ 协同式：线程的执行时间有线程本身控制，线程工作结束会自己主动通知系统进行切换；实现简单、切换操作对线程自身可知；线程时间事件不可控。
+ 抢占式：线程由操作系统分配执行时间，线程切换不由线程本身决定；线程执行时间系统可控。【Java的线程调度方式】

**线程状态切换**

Java中定义了6中线程状态，任一时刻有且仅有一种状态，并且可以通过特定方法在不同状态之间切换。

+ **新建(New)**：创建后尚未启动的线程处于New。
+ **运行(Runnable)**：包括操作系统线程状态中的Running和Ready，线程可能正在执行或等待操作系统分配执行时间。
+ **无限期等待(Waiting)**：不会被分配处理器执行时间，等待其他线程显式唤醒。以下方法会导致线程进入该状态：
  + 没有Timeout的Object#wait()方法
  + 没有Timeout的Thread#join()方法
  + LockSupport#park()方法
+ **有限期等待(Timed Waiting)**：不会被分配处理器执行时间，但不需等待其他线程显式唤醒，在一定时间内又系统自动唤醒。以下方法会导致线程进入该状态：
  + Thread#sleep()方法
  + 没有Timeout的Object#wait()方法
  + 没有Timeout的Thread#join()方法
  + LockSupport#parkNanos()方法
  + LockSupport#parkUntil()方法
+ **阻塞(Blocked)**：线程被阻塞，等待获取到一个排他锁。在程序等待进入同步区域时，线程进入此状态。
+ **结束(Terminated)**：已终止线程的线程状态，线程以及结束执行。

### Java与协程

Java中每个线程都是直接映射到操作系统的一个原生线程实现。这种直接映射的方式天然缺陷就是切换、调度成本高昂，系统能够容纳的线程数量也很有限。

而现如今对于Web应用服务，无论是请求数量还是复杂度，相较于从前都有了大量的增加。对于服务的低响应时间以及去请求的高效处理也有了更高的需求。

对于创建这种元素映射的线程，在Java Web服务器中的线程池通常只能有几十个到两百个之间，当把数以百万计的请求往线程池中消费的时候，系统切换线程执行的成本将会很大。因此现在迫切粒度更小、切换成本更加低廉的调度单元，而有栈协程就是一种。

有栈协程的一种实现称为纤程。Oracle中对纤程定义为：<font style="color:red">**纤程就是一种轻量级用户线程，通过Java虚拟机而非操作系统来进行调度。一个纤程占用的空间很小，任务切换开销小，在程序中可以创建大量纤程。**</font>

对于纤程实现并发的代码分为两部分-**执行过程**和**调度器**。

+ 执行过程：用于维护执行线程，保护、恢复上下文状态；
+ 调度器：负责编排所有要执行的代码的顺序

执行过程与调度器分离，可以让用户自己选择控制其中一个或多个，而且Java中现有的调度器也可以被重用。

> 补充1：为什么映射到系统内核的线程切换调度的成本会很高？

内核线程的调度成本主要来源于用户态和核心态之间的切换，两种状态的切换开销主要来源于响应中断、保护和恢复线程的成本。由于程序包含了数据和代码两部分，代码在执行时需要依赖于上下文数据，对于系统而言，包含了储存在内存、缓存和寄存器中的数据。对于这些数据在线程发生切换时，必须要先妥善保管好，以便于切换回来程序仍然能正常执行。

这种保护和恢复现场的工作难免就会存在数据在各种寄存器、缓存之间的拷贝。这样一来就容易导致较大的开销。

### 线程安全

当多个线程同时访问同一个对象时，如果不考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的----《Java并发编程实战》

事实上，线程安全并非非真即假，而是可以按照线程安全的「安全程度」由弱到强来排序，可以将Java中对个各种操作共享数据分为以下五类：**不可变、绝对线程安全、相对线程安全、线程兼容、线程对立**。

**不可变**

不可变对象一定线程安全，无论对象的方法实现还是方法调用者，都不需要进行任何线程安全保护措施。

Java语言中，如果多线程共享的数据是一个基本数据类型，那么只要在定义是使用final关键字修饰就可以保证不可变；如果共享数据是工业对选哪个，需要对象自行保证其行为不会对其状态产生任何影响。

**绝对线程安全**

做到绝对安全，付出的时间和空间成本非常大。

**相对线程安全**

保证对这个对象单次操作是实现安全的，调用时不需要额外保障措施，但是**对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性**。

在Java语言中，大部分声称线程安全的类都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。

**线程兼容**

线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。 Java类库API中大部分的类都是线程兼容的，如ArrayList，LinkedList等。

**线程对立** 

线程对立是指不管调用端是否采取了同步措施， 都无法在多线程环境中并发使用代码。

**互斥同步**

 实现线程安全，常见的手段有采用**互斥同步**。

同步指多线程并发访问共享数据时，保证共享数据在同一时刻只被一条线程使用。互斥是实现同步的手段，有如临界区、互斥量、信号量等。

Java中最基本的互斥同步手段是synchronized关键字。synchronized关键字经过Javac编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。

+ 如果synchronized明确了对象参数，则以这个对象引用作为reference；
+ 如果synchronized没有指定对象参数，则根据synchronized修饰的方法类型决定是代码所在对象实例还是Class对象作为线程要持有的锁。

《Java虚拟机规范》规定执行monitorenter时，实现尝试获取对象的锁。如果这个对象没被锁定，或当期线程已经持有这个对象锁，则把锁计数加一（可重入）；在执行monitorexit将锁的计数减一。一旦计数为0，锁随即被释放。如果对象获取锁失败，当期线程就会被阻塞等待，只到锁被释放为止。

在上述过程中，持有锁是有个重量级的操作，主流Java虚拟机实现中，Java线程与操作系统线程一一映射，如果要阻塞或唤醒一个线程必须通过操作系统完成。这个过程不可避免会出现用户态到内核态的转换，这个转换需要耗费很多处理器时间。

**非阻塞同步**

互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销。互斥同步方式也称为阻塞方式，是一种**悲观**的并发策略。

这种方式总是认为只要不去做正确的同步措施，就会出现问题，为了共享数据是否出现竞争，都会进行加锁。这将导致用户态到核心态以及维护锁计数和检查是否有被阻塞线程需要被唤醒等开销。

随着硬件指令集的发展（指令支持原子性的「操作和冲突检查」），出现了基于冲突检测的乐观并发策略，即不管风险，先进行操作，如果没有其他线程争用共享数据，操作直接成功；如果共享数据被争用，在进行补偿措施。补偿措施包括不断重试，知道出现没有竞争的共享数据为止。（这种措施的代码通常也称为无锁）

**无同步方案**

除了上面两种方案，



> 补充1：ReentrantLock与synchronized

ReentrantLock是JDK5开始，Java类库新提供的java.util.concurrent包下的一个类。和synchronized类似，两者都是支持可重入。但是与synchronized相比，ReentrantLock主要有三种高级功能：

+ **等待可中断**：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情；
+ **可实现公平锁**：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，但这种方式效率较低；
+ **可以绑定多个条件**：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁； 而ReentrantLock则无须这样做，多次调用newCondition()方法即可。

> 补充2：原子性指令-CAS

CAS指令需要有三个操作数：变量的内存位置A、旧的预期值O、准备设置的新值N。指令执行时当且仅当内存地址为A处值为O时，将其更新为N。（这个过程保证原子性）

JDK5之后Java类库开始提供CAS操作，由`sun.misc.Unsafe#compareAndSwapInt()`和`sun.misc.Unsafe#compareAndSwapLong()`等几个方法提供。

引用Unsafe类设计上是提供给Java类库访问而不是用户程序调用，因此只有启动类加载器加载的Class才能访问。但如果真要访问可以通过反射来突破其限制。

CAS会存在「ABA问题」，可以使用AtomicStampedReference解决。

